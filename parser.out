Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> lan
Rule 1     lan -> pyt
Rule 2     lan -> line
Rule 3     pyt -> PYT lineP
Rule 4     lineP -> nlineP lineP
Rule 5     lineP -> nlineP
Rule 6     nlineP -> var EQUAL expression
Rule 7     nlineP -> EXIT LPAREN RPAREN
Rule 8     nlineP -> PRINT LPAREN var RPAREN
Rule 9     line -> nline line
Rule 10    line -> nline
Rule 11    line -> pyt
Rule 12    nline -> INTEGER var EQUAL expression SEMICOLON
Rule 13    nline -> var EQUAL expression SEMICOLON
Rule 14    nline -> EXIT LPAREN RPAREN SEMICOLON
Rule 15    nline -> PRINT LPAREN var RPAREN SEMICOLON
Rule 16    var -> IDVAR
Rule 17    expression -> expression PLUS term
Rule 18    expression -> expression MINUS term
Rule 19    expression -> term
Rule 20    term -> term TIMES factor
Rule 21    term -> term DIVIDE factor
Rule 22    term -> factor
Rule 23    factor -> NUMBER
Rule 24    factor -> var
Rule 25    factor -> LPAREN expression RPAREN

Terminals, with rules where they appear

DIVIDE               : 21
EQUAL                : 6 12 13
EXIT                 : 7 14
IDVAR                : 16
INTEGER              : 12
LPAREN               : 7 8 14 15 25
MINUS                : 18
NUMBER               : 23
PLUS                 : 17
PRINT                : 8 15
PYT                  : 3
RPAREN               : 7 8 14 15 25
SEMICOLON            : 12 13 14 15
TIMES                : 20
error                : 

Nonterminals, with rules where they appear

expression           : 6 12 13 17 18 25
factor               : 20 21 22
lan                  : 0
line                 : 2 9
lineP                : 3 4
nline                : 9 10
nlineP               : 4 5
pyt                  : 1 11
term                 : 17 18 19 20 21
var                  : 6 8 12 13 15 24

Parsing method: LALR

state 0

    (0) S' -> . lan
    (1) lan -> . pyt
    (2) lan -> . line
    (3) pyt -> . PYT lineP
    (9) line -> . nline line
    (10) line -> . nline
    (11) line -> . pyt
    (12) nline -> . INTEGER var EQUAL expression SEMICOLON
    (13) nline -> . var EQUAL expression SEMICOLON
    (14) nline -> . EXIT LPAREN RPAREN SEMICOLON
    (15) nline -> . PRINT LPAREN var RPAREN SEMICOLON
    (16) var -> . IDVAR

    PYT             shift and go to state 4
    INTEGER         shift and go to state 6
    EXIT            shift and go to state 8
    PRINT           shift and go to state 9
    IDVAR           shift and go to state 10

    lan                            shift and go to state 1
    pyt                            shift and go to state 2
    line                           shift and go to state 3
    nline                          shift and go to state 5
    var                            shift and go to state 7

state 1

    (0) S' -> lan .



state 2

    (1) lan -> pyt .
    (11) line -> pyt .

  ! reduce/reduce conflict for $end resolved using rule 1 (lan -> pyt .)
    $end            reduce using rule 1 (lan -> pyt .)

  ! $end            [ reduce using rule 11 (line -> pyt .) ]


state 3

    (2) lan -> line .

    $end            reduce using rule 2 (lan -> line .)


state 4

    (3) pyt -> PYT . lineP
    (4) lineP -> . nlineP lineP
    (5) lineP -> . nlineP
    (6) nlineP -> . var EQUAL expression
    (7) nlineP -> . EXIT LPAREN RPAREN
    (8) nlineP -> . PRINT LPAREN var RPAREN
    (16) var -> . IDVAR

    EXIT            shift and go to state 14
    PRINT           shift and go to state 15
    IDVAR           shift and go to state 10

    lineP                          shift and go to state 11
    nlineP                         shift and go to state 12
    var                            shift and go to state 13

state 5

    (9) line -> nline . line
    (10) line -> nline .
    (9) line -> . nline line
    (10) line -> . nline
    (11) line -> . pyt
    (12) nline -> . INTEGER var EQUAL expression SEMICOLON
    (13) nline -> . var EQUAL expression SEMICOLON
    (14) nline -> . EXIT LPAREN RPAREN SEMICOLON
    (15) nline -> . PRINT LPAREN var RPAREN SEMICOLON
    (3) pyt -> . PYT lineP
    (16) var -> . IDVAR

    $end            reduce using rule 10 (line -> nline .)
    INTEGER         shift and go to state 6
    EXIT            shift and go to state 8
    PRINT           shift and go to state 9
    PYT             shift and go to state 4
    IDVAR           shift and go to state 10

    nline                          shift and go to state 5
    line                           shift and go to state 16
    pyt                            shift and go to state 17
    var                            shift and go to state 7

state 6

    (12) nline -> INTEGER . var EQUAL expression SEMICOLON
    (16) var -> . IDVAR

    IDVAR           shift and go to state 10

    var                            shift and go to state 18

state 7

    (13) nline -> var . EQUAL expression SEMICOLON

    EQUAL           shift and go to state 19


state 8

    (14) nline -> EXIT . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 20


state 9

    (15) nline -> PRINT . LPAREN var RPAREN SEMICOLON

    LPAREN          shift and go to state 21


state 10

    (16) var -> IDVAR .

    EQUAL           reduce using rule 16 (var -> IDVAR .)
    TIMES           reduce using rule 16 (var -> IDVAR .)
    DIVIDE          reduce using rule 16 (var -> IDVAR .)
    SEMICOLON       reduce using rule 16 (var -> IDVAR .)
    PLUS            reduce using rule 16 (var -> IDVAR .)
    MINUS           reduce using rule 16 (var -> IDVAR .)
    RPAREN          reduce using rule 16 (var -> IDVAR .)
    EXIT            reduce using rule 16 (var -> IDVAR .)
    PRINT           reduce using rule 16 (var -> IDVAR .)
    IDVAR           reduce using rule 16 (var -> IDVAR .)
    $end            reduce using rule 16 (var -> IDVAR .)


state 11

    (3) pyt -> PYT lineP .

    $end            reduce using rule 3 (pyt -> PYT lineP .)


state 12

    (4) lineP -> nlineP . lineP
    (5) lineP -> nlineP .
    (4) lineP -> . nlineP lineP
    (5) lineP -> . nlineP
    (6) nlineP -> . var EQUAL expression
    (7) nlineP -> . EXIT LPAREN RPAREN
    (8) nlineP -> . PRINT LPAREN var RPAREN
    (16) var -> . IDVAR

    $end            reduce using rule 5 (lineP -> nlineP .)
    EXIT            shift and go to state 14
    PRINT           shift and go to state 15
    IDVAR           shift and go to state 10

    nlineP                         shift and go to state 12
    lineP                          shift and go to state 22
    var                            shift and go to state 13

state 13

    (6) nlineP -> var . EQUAL expression

    EQUAL           shift and go to state 23


state 14

    (7) nlineP -> EXIT . LPAREN RPAREN

    LPAREN          shift and go to state 24


state 15

    (8) nlineP -> PRINT . LPAREN var RPAREN

    LPAREN          shift and go to state 25


state 16

    (9) line -> nline line .

    $end            reduce using rule 9 (line -> nline line .)


state 17

    (11) line -> pyt .

    $end            reduce using rule 11 (line -> pyt .)


state 18

    (12) nline -> INTEGER var . EQUAL expression SEMICOLON

    EQUAL           shift and go to state 26


state 19

    (13) nline -> var EQUAL . expression SEMICOLON
    (17) expression -> . expression PLUS term
    (18) expression -> . expression MINUS term
    (19) expression -> . term
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (22) term -> . factor
    (23) factor -> . NUMBER
    (24) factor -> . var
    (25) factor -> . LPAREN expression RPAREN
    (16) var -> . IDVAR

    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 32
    IDVAR           shift and go to state 10

    var                            shift and go to state 27
    expression                     shift and go to state 28
    term                           shift and go to state 29
    factor                         shift and go to state 30

state 20

    (14) nline -> EXIT LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 33


state 21

    (15) nline -> PRINT LPAREN . var RPAREN SEMICOLON
    (16) var -> . IDVAR

    IDVAR           shift and go to state 10

    var                            shift and go to state 34

state 22

    (4) lineP -> nlineP lineP .

    $end            reduce using rule 4 (lineP -> nlineP lineP .)


state 23

    (6) nlineP -> var EQUAL . expression
    (17) expression -> . expression PLUS term
    (18) expression -> . expression MINUS term
    (19) expression -> . term
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (22) term -> . factor
    (23) factor -> . NUMBER
    (24) factor -> . var
    (25) factor -> . LPAREN expression RPAREN
    (16) var -> . IDVAR

    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 32
    IDVAR           shift and go to state 10

    var                            shift and go to state 27
    expression                     shift and go to state 35
    term                           shift and go to state 29
    factor                         shift and go to state 30

state 24

    (7) nlineP -> EXIT LPAREN . RPAREN

    RPAREN          shift and go to state 36


state 25

    (8) nlineP -> PRINT LPAREN . var RPAREN
    (16) var -> . IDVAR

    IDVAR           shift and go to state 10

    var                            shift and go to state 37

state 26

    (12) nline -> INTEGER var EQUAL . expression SEMICOLON
    (17) expression -> . expression PLUS term
    (18) expression -> . expression MINUS term
    (19) expression -> . term
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (22) term -> . factor
    (23) factor -> . NUMBER
    (24) factor -> . var
    (25) factor -> . LPAREN expression RPAREN
    (16) var -> . IDVAR

    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 32
    IDVAR           shift and go to state 10

    var                            shift and go to state 27
    expression                     shift and go to state 38
    term                           shift and go to state 29
    factor                         shift and go to state 30

state 27

    (24) factor -> var .

    TIMES           reduce using rule 24 (factor -> var .)
    DIVIDE          reduce using rule 24 (factor -> var .)
    SEMICOLON       reduce using rule 24 (factor -> var .)
    PLUS            reduce using rule 24 (factor -> var .)
    MINUS           reduce using rule 24 (factor -> var .)
    EXIT            reduce using rule 24 (factor -> var .)
    PRINT           reduce using rule 24 (factor -> var .)
    IDVAR           reduce using rule 24 (factor -> var .)
    $end            reduce using rule 24 (factor -> var .)
    RPAREN          reduce using rule 24 (factor -> var .)


state 28

    (13) nline -> var EQUAL expression . SEMICOLON
    (17) expression -> expression . PLUS term
    (18) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41


state 29

    (19) expression -> term .
    (20) term -> term . TIMES factor
    (21) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 19 (expression -> term .)
    PLUS            reduce using rule 19 (expression -> term .)
    MINUS           reduce using rule 19 (expression -> term .)
    EXIT            reduce using rule 19 (expression -> term .)
    PRINT           reduce using rule 19 (expression -> term .)
    IDVAR           reduce using rule 19 (expression -> term .)
    $end            reduce using rule 19 (expression -> term .)
    RPAREN          reduce using rule 19 (expression -> term .)
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43


state 30

    (22) term -> factor .

    TIMES           reduce using rule 22 (term -> factor .)
    DIVIDE          reduce using rule 22 (term -> factor .)
    SEMICOLON       reduce using rule 22 (term -> factor .)
    PLUS            reduce using rule 22 (term -> factor .)
    MINUS           reduce using rule 22 (term -> factor .)
    EXIT            reduce using rule 22 (term -> factor .)
    PRINT           reduce using rule 22 (term -> factor .)
    IDVAR           reduce using rule 22 (term -> factor .)
    $end            reduce using rule 22 (term -> factor .)
    RPAREN          reduce using rule 22 (term -> factor .)


state 31

    (23) factor -> NUMBER .

    TIMES           reduce using rule 23 (factor -> NUMBER .)
    DIVIDE          reduce using rule 23 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 23 (factor -> NUMBER .)
    PLUS            reduce using rule 23 (factor -> NUMBER .)
    MINUS           reduce using rule 23 (factor -> NUMBER .)
    EXIT            reduce using rule 23 (factor -> NUMBER .)
    PRINT           reduce using rule 23 (factor -> NUMBER .)
    IDVAR           reduce using rule 23 (factor -> NUMBER .)
    $end            reduce using rule 23 (factor -> NUMBER .)
    RPAREN          reduce using rule 23 (factor -> NUMBER .)


state 32

    (25) factor -> LPAREN . expression RPAREN
    (17) expression -> . expression PLUS term
    (18) expression -> . expression MINUS term
    (19) expression -> . term
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (22) term -> . factor
    (23) factor -> . NUMBER
    (24) factor -> . var
    (25) factor -> . LPAREN expression RPAREN
    (16) var -> . IDVAR

    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 32
    IDVAR           shift and go to state 10

    expression                     shift and go to state 44
    term                           shift and go to state 29
    factor                         shift and go to state 30
    var                            shift and go to state 27

state 33

    (14) nline -> EXIT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 45


state 34

    (15) nline -> PRINT LPAREN var . RPAREN SEMICOLON

    RPAREN          shift and go to state 46


state 35

    (6) nlineP -> var EQUAL expression .
    (17) expression -> expression . PLUS term
    (18) expression -> expression . MINUS term

    EXIT            reduce using rule 6 (nlineP -> var EQUAL expression .)
    PRINT           reduce using rule 6 (nlineP -> var EQUAL expression .)
    IDVAR           reduce using rule 6 (nlineP -> var EQUAL expression .)
    $end            reduce using rule 6 (nlineP -> var EQUAL expression .)
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41


state 36

    (7) nlineP -> EXIT LPAREN RPAREN .

    EXIT            reduce using rule 7 (nlineP -> EXIT LPAREN RPAREN .)
    PRINT           reduce using rule 7 (nlineP -> EXIT LPAREN RPAREN .)
    IDVAR           reduce using rule 7 (nlineP -> EXIT LPAREN RPAREN .)
    $end            reduce using rule 7 (nlineP -> EXIT LPAREN RPAREN .)


state 37

    (8) nlineP -> PRINT LPAREN var . RPAREN

    RPAREN          shift and go to state 47


state 38

    (12) nline -> INTEGER var EQUAL expression . SEMICOLON
    (17) expression -> expression . PLUS term
    (18) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 48
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41


state 39

    (13) nline -> var EQUAL expression SEMICOLON .

    INTEGER         reduce using rule 13 (nline -> var EQUAL expression SEMICOLON .)
    EXIT            reduce using rule 13 (nline -> var EQUAL expression SEMICOLON .)
    PRINT           reduce using rule 13 (nline -> var EQUAL expression SEMICOLON .)
    PYT             reduce using rule 13 (nline -> var EQUAL expression SEMICOLON .)
    IDVAR           reduce using rule 13 (nline -> var EQUAL expression SEMICOLON .)
    $end            reduce using rule 13 (nline -> var EQUAL expression SEMICOLON .)


state 40

    (17) expression -> expression PLUS . term
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (22) term -> . factor
    (23) factor -> . NUMBER
    (24) factor -> . var
    (25) factor -> . LPAREN expression RPAREN
    (16) var -> . IDVAR

    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 32
    IDVAR           shift and go to state 10

    term                           shift and go to state 49
    factor                         shift and go to state 30
    var                            shift and go to state 27

state 41

    (18) expression -> expression MINUS . term
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (22) term -> . factor
    (23) factor -> . NUMBER
    (24) factor -> . var
    (25) factor -> . LPAREN expression RPAREN
    (16) var -> . IDVAR

    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 32
    IDVAR           shift and go to state 10

    term                           shift and go to state 50
    factor                         shift and go to state 30
    var                            shift and go to state 27

state 42

    (20) term -> term TIMES . factor
    (23) factor -> . NUMBER
    (24) factor -> . var
    (25) factor -> . LPAREN expression RPAREN
    (16) var -> . IDVAR

    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 32
    IDVAR           shift and go to state 10

    factor                         shift and go to state 51
    var                            shift and go to state 27

state 43

    (21) term -> term DIVIDE . factor
    (23) factor -> . NUMBER
    (24) factor -> . var
    (25) factor -> . LPAREN expression RPAREN
    (16) var -> . IDVAR

    NUMBER          shift and go to state 31
    LPAREN          shift and go to state 32
    IDVAR           shift and go to state 10

    factor                         shift and go to state 52
    var                            shift and go to state 27

state 44

    (25) factor -> LPAREN expression . RPAREN
    (17) expression -> expression . PLUS term
    (18) expression -> expression . MINUS term

    RPAREN          shift and go to state 53
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41


state 45

    (14) nline -> EXIT LPAREN RPAREN SEMICOLON .

    INTEGER         reduce using rule 14 (nline -> EXIT LPAREN RPAREN SEMICOLON .)
    EXIT            reduce using rule 14 (nline -> EXIT LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 14 (nline -> EXIT LPAREN RPAREN SEMICOLON .)
    PYT             reduce using rule 14 (nline -> EXIT LPAREN RPAREN SEMICOLON .)
    IDVAR           reduce using rule 14 (nline -> EXIT LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 14 (nline -> EXIT LPAREN RPAREN SEMICOLON .)


state 46

    (15) nline -> PRINT LPAREN var RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 54


state 47

    (8) nlineP -> PRINT LPAREN var RPAREN .

    EXIT            reduce using rule 8 (nlineP -> PRINT LPAREN var RPAREN .)
    PRINT           reduce using rule 8 (nlineP -> PRINT LPAREN var RPAREN .)
    IDVAR           reduce using rule 8 (nlineP -> PRINT LPAREN var RPAREN .)
    $end            reduce using rule 8 (nlineP -> PRINT LPAREN var RPAREN .)


state 48

    (12) nline -> INTEGER var EQUAL expression SEMICOLON .

    INTEGER         reduce using rule 12 (nline -> INTEGER var EQUAL expression SEMICOLON .)
    EXIT            reduce using rule 12 (nline -> INTEGER var EQUAL expression SEMICOLON .)
    PRINT           reduce using rule 12 (nline -> INTEGER var EQUAL expression SEMICOLON .)
    PYT             reduce using rule 12 (nline -> INTEGER var EQUAL expression SEMICOLON .)
    IDVAR           reduce using rule 12 (nline -> INTEGER var EQUAL expression SEMICOLON .)
    $end            reduce using rule 12 (nline -> INTEGER var EQUAL expression SEMICOLON .)


state 49

    (17) expression -> expression PLUS term .
    (20) term -> term . TIMES factor
    (21) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 17 (expression -> expression PLUS term .)
    PLUS            reduce using rule 17 (expression -> expression PLUS term .)
    MINUS           reduce using rule 17 (expression -> expression PLUS term .)
    EXIT            reduce using rule 17 (expression -> expression PLUS term .)
    PRINT           reduce using rule 17 (expression -> expression PLUS term .)
    IDVAR           reduce using rule 17 (expression -> expression PLUS term .)
    $end            reduce using rule 17 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 17 (expression -> expression PLUS term .)
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43


state 50

    (18) expression -> expression MINUS term .
    (20) term -> term . TIMES factor
    (21) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 18 (expression -> expression MINUS term .)
    PLUS            reduce using rule 18 (expression -> expression MINUS term .)
    MINUS           reduce using rule 18 (expression -> expression MINUS term .)
    EXIT            reduce using rule 18 (expression -> expression MINUS term .)
    PRINT           reduce using rule 18 (expression -> expression MINUS term .)
    IDVAR           reduce using rule 18 (expression -> expression MINUS term .)
    $end            reduce using rule 18 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 18 (expression -> expression MINUS term .)
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43


state 51

    (20) term -> term TIMES factor .

    TIMES           reduce using rule 20 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 20 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 20 (term -> term TIMES factor .)
    PLUS            reduce using rule 20 (term -> term TIMES factor .)
    MINUS           reduce using rule 20 (term -> term TIMES factor .)
    EXIT            reduce using rule 20 (term -> term TIMES factor .)
    PRINT           reduce using rule 20 (term -> term TIMES factor .)
    IDVAR           reduce using rule 20 (term -> term TIMES factor .)
    $end            reduce using rule 20 (term -> term TIMES factor .)
    RPAREN          reduce using rule 20 (term -> term TIMES factor .)


state 52

    (21) term -> term DIVIDE factor .

    TIMES           reduce using rule 21 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 21 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 21 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 21 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 21 (term -> term DIVIDE factor .)
    EXIT            reduce using rule 21 (term -> term DIVIDE factor .)
    PRINT           reduce using rule 21 (term -> term DIVIDE factor .)
    IDVAR           reduce using rule 21 (term -> term DIVIDE factor .)
    $end            reduce using rule 21 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 21 (term -> term DIVIDE factor .)


state 53

    (25) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    EXIT            reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    PRINT           reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    IDVAR           reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    $end            reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 25 (factor -> LPAREN expression RPAREN .)


state 54

    (15) nline -> PRINT LPAREN var RPAREN SEMICOLON .

    INTEGER         reduce using rule 15 (nline -> PRINT LPAREN var RPAREN SEMICOLON .)
    EXIT            reduce using rule 15 (nline -> PRINT LPAREN var RPAREN SEMICOLON .)
    PRINT           reduce using rule 15 (nline -> PRINT LPAREN var RPAREN SEMICOLON .)
    PYT             reduce using rule 15 (nline -> PRINT LPAREN var RPAREN SEMICOLON .)
    IDVAR           reduce using rule 15 (nline -> PRINT LPAREN var RPAREN SEMICOLON .)
    $end            reduce using rule 15 (nline -> PRINT LPAREN var RPAREN SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 2 resolved using rule (lan -> pyt)
WARNING: rejected rule (line -> pyt) in state 2
