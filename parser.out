Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    VOID
    WITH

Grammar

Rule 0     S' -> line
Rule 1     line -> nline line
Rule 2     line -> nline
Rule 3     nline -> dtype var SCOLON
Rule 4     nline -> STR var SCOLON
Rule 5     nline -> fline
Rule 6     nline -> STR IDVAR EQUAL strvar SCOLON
Rule 7     nline -> BOOL MAIN LPAREN RPAREN lcb line rcb
Rule 8     nline -> RETURN LPAREN bval RPAREN SCOLON
Rule 9     nline -> ifsts
Rule 10    nline -> EXIT LPAREN RPAREN SCOLON
Rule 11    nline -> PRINT LPAREN pline RPAREN SCOLON
Rule 12    pline -> exp
Rule 13    pline -> STRING
Rule 14    nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb
Rule 15    nline -> WHILE LPAREN bexp RPAREN lcb line rcb
Rule 16    ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests
Rule 17    rcb -> RCB
Rule 18    lcb -> LCB
Rule 19    elsests -> ELSE lcb line rcb
Rule 20    elsests -> ELSE ifsts
Rule 21    elsests -> empty
Rule 22    numexp -> assign SCOLON
Rule 23    exp -> exp PLUS term
Rule 24    exp -> exp MINUS term
Rule 25    exp -> term
Rule 26    term -> term MUL fact
Rule 27    term -> term DIV fact
Rule 28    term -> term MOD fact
Rule 29    term -> fact
Rule 30    fact -> INTEGER
Rule 31    fact -> FLOAT
Rule 32    fact -> varval
Rule 33    fact -> bval
Rule 34    fact -> CHAR
Rule 35    varval -> var
Rule 36    varval -> var LBB exp RBB
Rule 37    bval -> TRUE
Rule 38    bval -> FALSE
Rule 39    var -> IDVAR
Rule 40    dtype -> INT
Rule 41    dtype -> FLT
Rule 42    dtype -> CHR
Rule 43    dtype -> BOOL
Rule 44    strvar -> STRING
Rule 45    strvar -> varval
Rule 46    bexp -> bexp andor bexp2
Rule 47    bexp -> bexp2
Rule 48    bexp2 -> bexp2 rln exp
Rule 49    bexp2 -> exp
Rule 50    rln -> DEQUAL
Rule 51    rln -> GTHEN
Rule 52    rln -> LTHEN
Rule 53    rln -> NOT
Rule 54    andor -> AND
Rule 55    andor -> OR
Rule 56    empty -> <empty>
Rule 57    assign -> varval EQUAL exp
Rule 58    assign -> varval EQUAL STRING
Rule 59    fline -> dtype numexp
Rule 60    fline -> numexp
Rule 61    nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON
Rule 62    nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON
Rule 63    arrt -> var
Rule 64    arrt -> LCB dws RCB
Rule 65    dws -> factarr COM dws
Rule 66    dws -> factarr
Rule 67    factarr -> fact
Rule 68    factarr -> STRING

Terminals, with rules where they appear

AND                  : 54
BOOL                 : 7 43
CHAR                 : 34
CHR                  : 42
COM                  : 65
COMMENT              : 
DEQUAL               : 50
DIV                  : 27
ELSE                 : 19 20
EQUAL                : 6 57 58 61 62
EXIT                 : 10
FALSE                : 38
FLOAT                : 31
FLT                  : 41
FOR                  : 14
GTHEN                : 51
IDVAR                : 6 39 61 62
IF                   : 16
INT                  : 40
INTEGER              : 30
LBB                  : 36 61 62
LCB                  : 18 64
LPAREN               : 7 8 10 11 14 15 16
LTHEN                : 52
MAIN                 : 7
MINUS                : 24
MOD                  : 28
MUL                  : 26
NOT                  : 53
OR                   : 55
PLUS                 : 23
PRINT                : 11
RBB                  : 36 61 62
RCB                  : 17 64
RETURN               : 8
RPAREN               : 7 8 10 11 14 15 16
SCOLON               : 3 4 6 8 10 11 14 22 61 62
STR                  : 4 6 62
STRING               : 13 44 58 68
TRUE                 : 37
VOID                 : 
WHILE                : 15
WITH                 : 
error                : 

Nonterminals, with rules where they appear

andor                : 46
arrt                 : 61 62
assign               : 14 22
bexp                 : 14 15 16 46
bexp2                : 46 47 48
bval                 : 8 33
dtype                : 3 59 61
dws                  : 64 65
elsests              : 16
empty                : 21
exp                  : 12 23 24 36 48 49 57
fact                 : 26 27 28 29 67
factarr              : 65 66
fline                : 5 14
ifsts                : 9 20
lcb                  : 7 14 15 16 19
line                 : 1 7 14 15 16 19 0
nline                : 1 2
numexp               : 59 60
pline                : 11
rcb                  : 7 14 15 16 19
rln                  : 48
strvar               : 6
term                 : 23 24 25 26 27 28
var                  : 3 4 35 36 63
varval               : 32 45 57 58

Parsing method: LALR

state 0

    (0) S' -> . line
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN lcb line rcb
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb
    (15) nline -> . WHILE LPAREN bexp RPAREN lcb line rcb
    (61) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (62) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (40) dtype -> . INT
    (41) dtype -> . FLT
    (42) dtype -> . CHR
    (43) dtype -> . BOOL
    (59) fline -> . dtype numexp
    (60) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN lcb line rcb elsests
    (22) numexp -> . assign SCOLON
    (57) assign -> . varval EQUAL exp
    (58) assign -> . varval EQUAL STRING
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) var -> . IDVAR

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 1
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19
    varval                         shift and go to state 21

state 1

    (0) S' -> line .



state 2

    (1) line -> nline . line
    (2) line -> nline .
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN lcb line rcb
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb
    (15) nline -> . WHILE LPAREN bexp RPAREN lcb line rcb
    (61) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (62) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (40) dtype -> . INT
    (41) dtype -> . FLT
    (42) dtype -> . CHR
    (43) dtype -> . BOOL
    (59) fline -> . dtype numexp
    (60) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN lcb line rcb elsests
    (22) numexp -> . assign SCOLON
    (57) assign -> . varval EQUAL exp
    (58) assign -> . varval EQUAL STRING
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) var -> . IDVAR

    $end            reduce using rule 2 (line -> nline .)
    RCB             reduce using rule 2 (line -> nline .)
    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    nline                          shift and go to state 2
    line                           shift and go to state 22
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19
    varval                         shift and go to state 21

state 3

    (3) nline -> dtype . var SCOLON
    (61) nline -> dtype . LBB RBB IDVAR EQUAL arrt SCOLON
    (59) fline -> dtype . numexp
    (39) var -> . IDVAR
    (22) numexp -> . assign SCOLON
    (57) assign -> . varval EQUAL exp
    (58) assign -> . varval EQUAL STRING
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB

    LBB             shift and go to state 24
    IDVAR           shift and go to state 7

    var                            shift and go to state 23
    numexp                         shift and go to state 25
    assign                         shift and go to state 14
    varval                         shift and go to state 21

state 4

    (35) varval -> var .
    (36) varval -> var . LBB exp RBB

    EQUAL           reduce using rule 35 (varval -> var .)
    MUL             reduce using rule 35 (varval -> var .)
    DIV             reduce using rule 35 (varval -> var .)
    MOD             reduce using rule 35 (varval -> var .)
    RBB             reduce using rule 35 (varval -> var .)
    PLUS            reduce using rule 35 (varval -> var .)
    MINUS           reduce using rule 35 (varval -> var .)
    RPAREN          reduce using rule 35 (varval -> var .)
    DEQUAL          reduce using rule 35 (varval -> var .)
    GTHEN           reduce using rule 35 (varval -> var .)
    LTHEN           reduce using rule 35 (varval -> var .)
    NOT             reduce using rule 35 (varval -> var .)
    AND             reduce using rule 35 (varval -> var .)
    OR              reduce using rule 35 (varval -> var .)
    SCOLON          reduce using rule 35 (varval -> var .)
    COM             reduce using rule 35 (varval -> var .)
    RCB             reduce using rule 35 (varval -> var .)
    LBB             shift and go to state 26


state 5

    (4) nline -> STR . var SCOLON
    (6) nline -> STR . IDVAR EQUAL strvar SCOLON
    (62) nline -> STR . LBB RBB IDVAR EQUAL arrt SCOLON
    (39) var -> . IDVAR

    IDVAR           shift and go to state 28
    LBB             shift and go to state 29

    var                            shift and go to state 27

state 6

    (5) nline -> fline .

    STR             reduce using rule 5 (nline -> fline .)
    BOOL            reduce using rule 5 (nline -> fline .)
    RETURN          reduce using rule 5 (nline -> fline .)
    EXIT            reduce using rule 5 (nline -> fline .)
    PRINT           reduce using rule 5 (nline -> fline .)
    FOR             reduce using rule 5 (nline -> fline .)
    WHILE           reduce using rule 5 (nline -> fline .)
    INT             reduce using rule 5 (nline -> fline .)
    FLT             reduce using rule 5 (nline -> fline .)
    CHR             reduce using rule 5 (nline -> fline .)
    IF              reduce using rule 5 (nline -> fline .)
    IDVAR           reduce using rule 5 (nline -> fline .)
    $end            reduce using rule 5 (nline -> fline .)
    RCB             reduce using rule 5 (nline -> fline .)


state 7

    (39) var -> IDVAR .

    LBB             reduce using rule 39 (var -> IDVAR .)
    EQUAL           reduce using rule 39 (var -> IDVAR .)
    SCOLON          reduce using rule 39 (var -> IDVAR .)
    MUL             reduce using rule 39 (var -> IDVAR .)
    DIV             reduce using rule 39 (var -> IDVAR .)
    MOD             reduce using rule 39 (var -> IDVAR .)
    RBB             reduce using rule 39 (var -> IDVAR .)
    PLUS            reduce using rule 39 (var -> IDVAR .)
    MINUS           reduce using rule 39 (var -> IDVAR .)
    RPAREN          reduce using rule 39 (var -> IDVAR .)
    DEQUAL          reduce using rule 39 (var -> IDVAR .)
    GTHEN           reduce using rule 39 (var -> IDVAR .)
    LTHEN           reduce using rule 39 (var -> IDVAR .)
    NOT             reduce using rule 39 (var -> IDVAR .)
    AND             reduce using rule 39 (var -> IDVAR .)
    OR              reduce using rule 39 (var -> IDVAR .)
    COM             reduce using rule 39 (var -> IDVAR .)
    RCB             reduce using rule 39 (var -> IDVAR .)


state 8

    (7) nline -> BOOL . MAIN LPAREN RPAREN lcb line rcb
    (43) dtype -> BOOL .

    MAIN            shift and go to state 30
    LBB             reduce using rule 43 (dtype -> BOOL .)
    IDVAR           reduce using rule 43 (dtype -> BOOL .)


state 9

    (8) nline -> RETURN . LPAREN bval RPAREN SCOLON

    LPAREN          shift and go to state 31


state 10

    (9) nline -> ifsts .

    STR             reduce using rule 9 (nline -> ifsts .)
    BOOL            reduce using rule 9 (nline -> ifsts .)
    RETURN          reduce using rule 9 (nline -> ifsts .)
    EXIT            reduce using rule 9 (nline -> ifsts .)
    PRINT           reduce using rule 9 (nline -> ifsts .)
    FOR             reduce using rule 9 (nline -> ifsts .)
    WHILE           reduce using rule 9 (nline -> ifsts .)
    INT             reduce using rule 9 (nline -> ifsts .)
    FLT             reduce using rule 9 (nline -> ifsts .)
    CHR             reduce using rule 9 (nline -> ifsts .)
    IF              reduce using rule 9 (nline -> ifsts .)
    IDVAR           reduce using rule 9 (nline -> ifsts .)
    $end            reduce using rule 9 (nline -> ifsts .)
    RCB             reduce using rule 9 (nline -> ifsts .)


state 11

    (10) nline -> EXIT . LPAREN RPAREN SCOLON

    LPAREN          shift and go to state 32


state 12

    (11) nline -> PRINT . LPAREN pline RPAREN SCOLON

    LPAREN          shift and go to state 33


state 13

    (14) nline -> FOR . LPAREN fline bexp SCOLON assign RPAREN lcb line rcb

    LPAREN          shift and go to state 34


state 14

    (22) numexp -> assign . SCOLON

    SCOLON          shift and go to state 35


state 15

    (15) nline -> WHILE . LPAREN bexp RPAREN lcb line rcb

    LPAREN          shift and go to state 36


state 16

    (40) dtype -> INT .

    LBB             reduce using rule 40 (dtype -> INT .)
    IDVAR           reduce using rule 40 (dtype -> INT .)


state 17

    (41) dtype -> FLT .

    LBB             reduce using rule 41 (dtype -> FLT .)
    IDVAR           reduce using rule 41 (dtype -> FLT .)


state 18

    (42) dtype -> CHR .

    LBB             reduce using rule 42 (dtype -> CHR .)
    IDVAR           reduce using rule 42 (dtype -> CHR .)


state 19

    (60) fline -> numexp .

    STR             reduce using rule 60 (fline -> numexp .)
    BOOL            reduce using rule 60 (fline -> numexp .)
    RETURN          reduce using rule 60 (fline -> numexp .)
    EXIT            reduce using rule 60 (fline -> numexp .)
    PRINT           reduce using rule 60 (fline -> numexp .)
    FOR             reduce using rule 60 (fline -> numexp .)
    WHILE           reduce using rule 60 (fline -> numexp .)
    INT             reduce using rule 60 (fline -> numexp .)
    FLT             reduce using rule 60 (fline -> numexp .)
    CHR             reduce using rule 60 (fline -> numexp .)
    IF              reduce using rule 60 (fline -> numexp .)
    IDVAR           reduce using rule 60 (fline -> numexp .)
    $end            reduce using rule 60 (fline -> numexp .)
    RCB             reduce using rule 60 (fline -> numexp .)
    INTEGER         reduce using rule 60 (fline -> numexp .)
    FLOAT           reduce using rule 60 (fline -> numexp .)
    CHAR            reduce using rule 60 (fline -> numexp .)
    TRUE            reduce using rule 60 (fline -> numexp .)
    FALSE           reduce using rule 60 (fline -> numexp .)


state 20

    (16) ifsts -> IF . LPAREN bexp RPAREN lcb line rcb elsests

    LPAREN          shift and go to state 37


state 21

    (57) assign -> varval . EQUAL exp
    (58) assign -> varval . EQUAL STRING

    EQUAL           shift and go to state 38


state 22

    (1) line -> nline line .

    $end            reduce using rule 1 (line -> nline line .)
    RCB             reduce using rule 1 (line -> nline line .)


state 23

    (3) nline -> dtype var . SCOLON
    (35) varval -> var .
    (36) varval -> var . LBB exp RBB

    SCOLON          shift and go to state 39
    EQUAL           reduce using rule 35 (varval -> var .)
    LBB             shift and go to state 26


state 24

    (61) nline -> dtype LBB . RBB IDVAR EQUAL arrt SCOLON

    RBB             shift and go to state 40


state 25

    (59) fline -> dtype numexp .

    STR             reduce using rule 59 (fline -> dtype numexp .)
    BOOL            reduce using rule 59 (fline -> dtype numexp .)
    RETURN          reduce using rule 59 (fline -> dtype numexp .)
    EXIT            reduce using rule 59 (fline -> dtype numexp .)
    PRINT           reduce using rule 59 (fline -> dtype numexp .)
    FOR             reduce using rule 59 (fline -> dtype numexp .)
    WHILE           reduce using rule 59 (fline -> dtype numexp .)
    INT             reduce using rule 59 (fline -> dtype numexp .)
    FLT             reduce using rule 59 (fline -> dtype numexp .)
    CHR             reduce using rule 59 (fline -> dtype numexp .)
    IF              reduce using rule 59 (fline -> dtype numexp .)
    IDVAR           reduce using rule 59 (fline -> dtype numexp .)
    $end            reduce using rule 59 (fline -> dtype numexp .)
    RCB             reduce using rule 59 (fline -> dtype numexp .)
    INTEGER         reduce using rule 59 (fline -> dtype numexp .)
    FLOAT           reduce using rule 59 (fline -> dtype numexp .)
    CHAR            reduce using rule 59 (fline -> dtype numexp .)
    TRUE            reduce using rule 59 (fline -> dtype numexp .)
    FALSE           reduce using rule 59 (fline -> dtype numexp .)


state 26

    (36) varval -> var LBB . exp RBB
    (23) exp -> . exp PLUS term
    (24) exp -> . exp MINUS term
    (25) exp -> . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (37) bval -> . TRUE
    (38) bval -> . FALSE
    (39) var -> . IDVAR

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    IDVAR           shift and go to state 7

    var                            shift and go to state 4
    exp                            shift and go to state 41
    term                           shift and go to state 42
    fact                           shift and go to state 43
    varval                         shift and go to state 46
    bval                           shift and go to state 47

state 27

    (4) nline -> STR var . SCOLON

    SCOLON          shift and go to state 51


state 28

    (6) nline -> STR IDVAR . EQUAL strvar SCOLON
    (39) var -> IDVAR .

    EQUAL           shift and go to state 52
    SCOLON          reduce using rule 39 (var -> IDVAR .)


state 29

    (62) nline -> STR LBB . RBB IDVAR EQUAL arrt SCOLON

    RBB             shift and go to state 53


state 30

    (7) nline -> BOOL MAIN . LPAREN RPAREN lcb line rcb

    LPAREN          shift and go to state 54


state 31

    (8) nline -> RETURN LPAREN . bval RPAREN SCOLON
    (37) bval -> . TRUE
    (38) bval -> . FALSE

    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    bval                           shift and go to state 55

state 32

    (10) nline -> EXIT LPAREN . RPAREN SCOLON

    RPAREN          shift and go to state 56


state 33

    (11) nline -> PRINT LPAREN . pline RPAREN SCOLON
    (12) pline -> . exp
    (13) pline -> . STRING
    (23) exp -> . exp PLUS term
    (24) exp -> . exp MINUS term
    (25) exp -> . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (37) bval -> . TRUE
    (38) bval -> . FALSE
    (39) var -> . IDVAR

    STRING          shift and go to state 59
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    IDVAR           shift and go to state 7

    pline                          shift and go to state 57
    exp                            shift and go to state 58
    term                           shift and go to state 42
    fact                           shift and go to state 43
    varval                         shift and go to state 46
    bval                           shift and go to state 47
    var                            shift and go to state 4

state 34

    (14) nline -> FOR LPAREN . fline bexp SCOLON assign RPAREN lcb line rcb
    (59) fline -> . dtype numexp
    (60) fline -> . numexp
    (40) dtype -> . INT
    (41) dtype -> . FLT
    (42) dtype -> . CHR
    (43) dtype -> . BOOL
    (22) numexp -> . assign SCOLON
    (57) assign -> . varval EQUAL exp
    (58) assign -> . varval EQUAL STRING
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) var -> . IDVAR

    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    BOOL            shift and go to state 62
    IDVAR           shift and go to state 7

    fline                          shift and go to state 60
    assign                         shift and go to state 14
    dtype                          shift and go to state 61
    numexp                         shift and go to state 19
    varval                         shift and go to state 21
    var                            shift and go to state 4

state 35

    (22) numexp -> assign SCOLON .

    STR             reduce using rule 22 (numexp -> assign SCOLON .)
    BOOL            reduce using rule 22 (numexp -> assign SCOLON .)
    RETURN          reduce using rule 22 (numexp -> assign SCOLON .)
    EXIT            reduce using rule 22 (numexp -> assign SCOLON .)
    PRINT           reduce using rule 22 (numexp -> assign SCOLON .)
    FOR             reduce using rule 22 (numexp -> assign SCOLON .)
    WHILE           reduce using rule 22 (numexp -> assign SCOLON .)
    INT             reduce using rule 22 (numexp -> assign SCOLON .)
    FLT             reduce using rule 22 (numexp -> assign SCOLON .)
    CHR             reduce using rule 22 (numexp -> assign SCOLON .)
    IF              reduce using rule 22 (numexp -> assign SCOLON .)
    IDVAR           reduce using rule 22 (numexp -> assign SCOLON .)
    $end            reduce using rule 22 (numexp -> assign SCOLON .)
    RCB             reduce using rule 22 (numexp -> assign SCOLON .)
    INTEGER         reduce using rule 22 (numexp -> assign SCOLON .)
    FLOAT           reduce using rule 22 (numexp -> assign SCOLON .)
    CHAR            reduce using rule 22 (numexp -> assign SCOLON .)
    TRUE            reduce using rule 22 (numexp -> assign SCOLON .)
    FALSE           reduce using rule 22 (numexp -> assign SCOLON .)


state 36

    (15) nline -> WHILE LPAREN . bexp RPAREN lcb line rcb
    (46) bexp -> . bexp andor bexp2
    (47) bexp -> . bexp2
    (48) bexp2 -> . bexp2 rln exp
    (49) bexp2 -> . exp
    (23) exp -> . exp PLUS term
    (24) exp -> . exp MINUS term
    (25) exp -> . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (37) bval -> . TRUE
    (38) bval -> . FALSE
    (39) var -> . IDVAR

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    IDVAR           shift and go to state 7

    bexp                           shift and go to state 63
    bexp2                          shift and go to state 64
    exp                            shift and go to state 65
    term                           shift and go to state 42
    fact                           shift and go to state 43
    varval                         shift and go to state 46
    bval                           shift and go to state 47
    var                            shift and go to state 4

state 37

    (16) ifsts -> IF LPAREN . bexp RPAREN lcb line rcb elsests
    (46) bexp -> . bexp andor bexp2
    (47) bexp -> . bexp2
    (48) bexp2 -> . bexp2 rln exp
    (49) bexp2 -> . exp
    (23) exp -> . exp PLUS term
    (24) exp -> . exp MINUS term
    (25) exp -> . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (37) bval -> . TRUE
    (38) bval -> . FALSE
    (39) var -> . IDVAR

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    IDVAR           shift and go to state 7

    bexp                           shift and go to state 66
    bexp2                          shift and go to state 64
    exp                            shift and go to state 65
    term                           shift and go to state 42
    fact                           shift and go to state 43
    varval                         shift and go to state 46
    bval                           shift and go to state 47
    var                            shift and go to state 4

state 38

    (57) assign -> varval EQUAL . exp
    (58) assign -> varval EQUAL . STRING
    (23) exp -> . exp PLUS term
    (24) exp -> . exp MINUS term
    (25) exp -> . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (37) bval -> . TRUE
    (38) bval -> . FALSE
    (39) var -> . IDVAR

    STRING          shift and go to state 68
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    IDVAR           shift and go to state 7

    varval                         shift and go to state 46
    exp                            shift and go to state 67
    term                           shift and go to state 42
    fact                           shift and go to state 43
    bval                           shift and go to state 47
    var                            shift and go to state 4

state 39

    (3) nline -> dtype var SCOLON .

    STR             reduce using rule 3 (nline -> dtype var SCOLON .)
    BOOL            reduce using rule 3 (nline -> dtype var SCOLON .)
    RETURN          reduce using rule 3 (nline -> dtype var SCOLON .)
    EXIT            reduce using rule 3 (nline -> dtype var SCOLON .)
    PRINT           reduce using rule 3 (nline -> dtype var SCOLON .)
    FOR             reduce using rule 3 (nline -> dtype var SCOLON .)
    WHILE           reduce using rule 3 (nline -> dtype var SCOLON .)
    INT             reduce using rule 3 (nline -> dtype var SCOLON .)
    FLT             reduce using rule 3 (nline -> dtype var SCOLON .)
    CHR             reduce using rule 3 (nline -> dtype var SCOLON .)
    IF              reduce using rule 3 (nline -> dtype var SCOLON .)
    IDVAR           reduce using rule 3 (nline -> dtype var SCOLON .)
    $end            reduce using rule 3 (nline -> dtype var SCOLON .)
    RCB             reduce using rule 3 (nline -> dtype var SCOLON .)


state 40

    (61) nline -> dtype LBB RBB . IDVAR EQUAL arrt SCOLON

    IDVAR           shift and go to state 69


state 41

    (36) varval -> var LBB exp . RBB
    (23) exp -> exp . PLUS term
    (24) exp -> exp . MINUS term

    RBB             shift and go to state 70
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72


state 42

    (25) exp -> term .
    (26) term -> term . MUL fact
    (27) term -> term . DIV fact
    (28) term -> term . MOD fact

    RBB             reduce using rule 25 (exp -> term .)
    PLUS            reduce using rule 25 (exp -> term .)
    MINUS           reduce using rule 25 (exp -> term .)
    RPAREN          reduce using rule 25 (exp -> term .)
    DEQUAL          reduce using rule 25 (exp -> term .)
    GTHEN           reduce using rule 25 (exp -> term .)
    LTHEN           reduce using rule 25 (exp -> term .)
    NOT             reduce using rule 25 (exp -> term .)
    AND             reduce using rule 25 (exp -> term .)
    OR              reduce using rule 25 (exp -> term .)
    SCOLON          reduce using rule 25 (exp -> term .)
    MUL             shift and go to state 73
    DIV             shift and go to state 74
    MOD             shift and go to state 75


state 43

    (29) term -> fact .

    MUL             reduce using rule 29 (term -> fact .)
    DIV             reduce using rule 29 (term -> fact .)
    MOD             reduce using rule 29 (term -> fact .)
    RBB             reduce using rule 29 (term -> fact .)
    PLUS            reduce using rule 29 (term -> fact .)
    MINUS           reduce using rule 29 (term -> fact .)
    RPAREN          reduce using rule 29 (term -> fact .)
    DEQUAL          reduce using rule 29 (term -> fact .)
    GTHEN           reduce using rule 29 (term -> fact .)
    LTHEN           reduce using rule 29 (term -> fact .)
    NOT             reduce using rule 29 (term -> fact .)
    AND             reduce using rule 29 (term -> fact .)
    OR              reduce using rule 29 (term -> fact .)
    SCOLON          reduce using rule 29 (term -> fact .)


state 44

    (30) fact -> INTEGER .

    MUL             reduce using rule 30 (fact -> INTEGER .)
    DIV             reduce using rule 30 (fact -> INTEGER .)
    MOD             reduce using rule 30 (fact -> INTEGER .)
    RBB             reduce using rule 30 (fact -> INTEGER .)
    PLUS            reduce using rule 30 (fact -> INTEGER .)
    MINUS           reduce using rule 30 (fact -> INTEGER .)
    RPAREN          reduce using rule 30 (fact -> INTEGER .)
    DEQUAL          reduce using rule 30 (fact -> INTEGER .)
    GTHEN           reduce using rule 30 (fact -> INTEGER .)
    LTHEN           reduce using rule 30 (fact -> INTEGER .)
    NOT             reduce using rule 30 (fact -> INTEGER .)
    AND             reduce using rule 30 (fact -> INTEGER .)
    OR              reduce using rule 30 (fact -> INTEGER .)
    SCOLON          reduce using rule 30 (fact -> INTEGER .)
    COM             reduce using rule 30 (fact -> INTEGER .)
    RCB             reduce using rule 30 (fact -> INTEGER .)


state 45

    (31) fact -> FLOAT .

    MUL             reduce using rule 31 (fact -> FLOAT .)
    DIV             reduce using rule 31 (fact -> FLOAT .)
    MOD             reduce using rule 31 (fact -> FLOAT .)
    RBB             reduce using rule 31 (fact -> FLOAT .)
    PLUS            reduce using rule 31 (fact -> FLOAT .)
    MINUS           reduce using rule 31 (fact -> FLOAT .)
    RPAREN          reduce using rule 31 (fact -> FLOAT .)
    DEQUAL          reduce using rule 31 (fact -> FLOAT .)
    GTHEN           reduce using rule 31 (fact -> FLOAT .)
    LTHEN           reduce using rule 31 (fact -> FLOAT .)
    NOT             reduce using rule 31 (fact -> FLOAT .)
    AND             reduce using rule 31 (fact -> FLOAT .)
    OR              reduce using rule 31 (fact -> FLOAT .)
    SCOLON          reduce using rule 31 (fact -> FLOAT .)
    COM             reduce using rule 31 (fact -> FLOAT .)
    RCB             reduce using rule 31 (fact -> FLOAT .)


state 46

    (32) fact -> varval .

    MUL             reduce using rule 32 (fact -> varval .)
    DIV             reduce using rule 32 (fact -> varval .)
    MOD             reduce using rule 32 (fact -> varval .)
    RBB             reduce using rule 32 (fact -> varval .)
    PLUS            reduce using rule 32 (fact -> varval .)
    MINUS           reduce using rule 32 (fact -> varval .)
    RPAREN          reduce using rule 32 (fact -> varval .)
    DEQUAL          reduce using rule 32 (fact -> varval .)
    GTHEN           reduce using rule 32 (fact -> varval .)
    LTHEN           reduce using rule 32 (fact -> varval .)
    NOT             reduce using rule 32 (fact -> varval .)
    AND             reduce using rule 32 (fact -> varval .)
    OR              reduce using rule 32 (fact -> varval .)
    SCOLON          reduce using rule 32 (fact -> varval .)
    COM             reduce using rule 32 (fact -> varval .)
    RCB             reduce using rule 32 (fact -> varval .)


state 47

    (33) fact -> bval .

    MUL             reduce using rule 33 (fact -> bval .)
    DIV             reduce using rule 33 (fact -> bval .)
    MOD             reduce using rule 33 (fact -> bval .)
    RBB             reduce using rule 33 (fact -> bval .)
    PLUS            reduce using rule 33 (fact -> bval .)
    MINUS           reduce using rule 33 (fact -> bval .)
    RPAREN          reduce using rule 33 (fact -> bval .)
    DEQUAL          reduce using rule 33 (fact -> bval .)
    GTHEN           reduce using rule 33 (fact -> bval .)
    LTHEN           reduce using rule 33 (fact -> bval .)
    NOT             reduce using rule 33 (fact -> bval .)
    AND             reduce using rule 33 (fact -> bval .)
    OR              reduce using rule 33 (fact -> bval .)
    SCOLON          reduce using rule 33 (fact -> bval .)
    COM             reduce using rule 33 (fact -> bval .)
    RCB             reduce using rule 33 (fact -> bval .)


state 48

    (34) fact -> CHAR .

    MUL             reduce using rule 34 (fact -> CHAR .)
    DIV             reduce using rule 34 (fact -> CHAR .)
    MOD             reduce using rule 34 (fact -> CHAR .)
    RBB             reduce using rule 34 (fact -> CHAR .)
    PLUS            reduce using rule 34 (fact -> CHAR .)
    MINUS           reduce using rule 34 (fact -> CHAR .)
    RPAREN          reduce using rule 34 (fact -> CHAR .)
    DEQUAL          reduce using rule 34 (fact -> CHAR .)
    GTHEN           reduce using rule 34 (fact -> CHAR .)
    LTHEN           reduce using rule 34 (fact -> CHAR .)
    NOT             reduce using rule 34 (fact -> CHAR .)
    AND             reduce using rule 34 (fact -> CHAR .)
    OR              reduce using rule 34 (fact -> CHAR .)
    SCOLON          reduce using rule 34 (fact -> CHAR .)
    COM             reduce using rule 34 (fact -> CHAR .)
    RCB             reduce using rule 34 (fact -> CHAR .)


state 49

    (37) bval -> TRUE .

    MUL             reduce using rule 37 (bval -> TRUE .)
    DIV             reduce using rule 37 (bval -> TRUE .)
    MOD             reduce using rule 37 (bval -> TRUE .)
    RBB             reduce using rule 37 (bval -> TRUE .)
    PLUS            reduce using rule 37 (bval -> TRUE .)
    MINUS           reduce using rule 37 (bval -> TRUE .)
    RPAREN          reduce using rule 37 (bval -> TRUE .)
    DEQUAL          reduce using rule 37 (bval -> TRUE .)
    GTHEN           reduce using rule 37 (bval -> TRUE .)
    LTHEN           reduce using rule 37 (bval -> TRUE .)
    NOT             reduce using rule 37 (bval -> TRUE .)
    AND             reduce using rule 37 (bval -> TRUE .)
    OR              reduce using rule 37 (bval -> TRUE .)
    SCOLON          reduce using rule 37 (bval -> TRUE .)
    COM             reduce using rule 37 (bval -> TRUE .)
    RCB             reduce using rule 37 (bval -> TRUE .)


state 50

    (38) bval -> FALSE .

    MUL             reduce using rule 38 (bval -> FALSE .)
    DIV             reduce using rule 38 (bval -> FALSE .)
    MOD             reduce using rule 38 (bval -> FALSE .)
    RBB             reduce using rule 38 (bval -> FALSE .)
    PLUS            reduce using rule 38 (bval -> FALSE .)
    MINUS           reduce using rule 38 (bval -> FALSE .)
    RPAREN          reduce using rule 38 (bval -> FALSE .)
    DEQUAL          reduce using rule 38 (bval -> FALSE .)
    GTHEN           reduce using rule 38 (bval -> FALSE .)
    LTHEN           reduce using rule 38 (bval -> FALSE .)
    NOT             reduce using rule 38 (bval -> FALSE .)
    AND             reduce using rule 38 (bval -> FALSE .)
    OR              reduce using rule 38 (bval -> FALSE .)
    SCOLON          reduce using rule 38 (bval -> FALSE .)
    COM             reduce using rule 38 (bval -> FALSE .)
    RCB             reduce using rule 38 (bval -> FALSE .)


state 51

    (4) nline -> STR var SCOLON .

    STR             reduce using rule 4 (nline -> STR var SCOLON .)
    BOOL            reduce using rule 4 (nline -> STR var SCOLON .)
    RETURN          reduce using rule 4 (nline -> STR var SCOLON .)
    EXIT            reduce using rule 4 (nline -> STR var SCOLON .)
    PRINT           reduce using rule 4 (nline -> STR var SCOLON .)
    FOR             reduce using rule 4 (nline -> STR var SCOLON .)
    WHILE           reduce using rule 4 (nline -> STR var SCOLON .)
    INT             reduce using rule 4 (nline -> STR var SCOLON .)
    FLT             reduce using rule 4 (nline -> STR var SCOLON .)
    CHR             reduce using rule 4 (nline -> STR var SCOLON .)
    IF              reduce using rule 4 (nline -> STR var SCOLON .)
    IDVAR           reduce using rule 4 (nline -> STR var SCOLON .)
    $end            reduce using rule 4 (nline -> STR var SCOLON .)
    RCB             reduce using rule 4 (nline -> STR var SCOLON .)


state 52

    (6) nline -> STR IDVAR EQUAL . strvar SCOLON
    (44) strvar -> . STRING
    (45) strvar -> . varval
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) var -> . IDVAR

    STRING          shift and go to state 77
    IDVAR           shift and go to state 7

    strvar                         shift and go to state 76
    varval                         shift and go to state 78
    var                            shift and go to state 4

state 53

    (62) nline -> STR LBB RBB . IDVAR EQUAL arrt SCOLON

    IDVAR           shift and go to state 79


state 54

    (7) nline -> BOOL MAIN LPAREN . RPAREN lcb line rcb

    RPAREN          shift and go to state 80


state 55

    (8) nline -> RETURN LPAREN bval . RPAREN SCOLON

    RPAREN          shift and go to state 81


state 56

    (10) nline -> EXIT LPAREN RPAREN . SCOLON

    SCOLON          shift and go to state 82


state 57

    (11) nline -> PRINT LPAREN pline . RPAREN SCOLON

    RPAREN          shift and go to state 83


state 58

    (12) pline -> exp .
    (23) exp -> exp . PLUS term
    (24) exp -> exp . MINUS term

    RPAREN          reduce using rule 12 (pline -> exp .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72


state 59

    (13) pline -> STRING .

    RPAREN          reduce using rule 13 (pline -> STRING .)


state 60

    (14) nline -> FOR LPAREN fline . bexp SCOLON assign RPAREN lcb line rcb
    (46) bexp -> . bexp andor bexp2
    (47) bexp -> . bexp2
    (48) bexp2 -> . bexp2 rln exp
    (49) bexp2 -> . exp
    (23) exp -> . exp PLUS term
    (24) exp -> . exp MINUS term
    (25) exp -> . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (37) bval -> . TRUE
    (38) bval -> . FALSE
    (39) var -> . IDVAR

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    IDVAR           shift and go to state 7

    bexp                           shift and go to state 84
    bexp2                          shift and go to state 64
    exp                            shift and go to state 65
    term                           shift and go to state 42
    fact                           shift and go to state 43
    varval                         shift and go to state 46
    bval                           shift and go to state 47
    var                            shift and go to state 4

state 61

    (59) fline -> dtype . numexp
    (22) numexp -> . assign SCOLON
    (57) assign -> . varval EQUAL exp
    (58) assign -> . varval EQUAL STRING
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) var -> . IDVAR

    IDVAR           shift and go to state 7

    numexp                         shift and go to state 25
    assign                         shift and go to state 14
    varval                         shift and go to state 21
    var                            shift and go to state 4

state 62

    (43) dtype -> BOOL .

    IDVAR           reduce using rule 43 (dtype -> BOOL .)


state 63

    (15) nline -> WHILE LPAREN bexp . RPAREN lcb line rcb
    (46) bexp -> bexp . andor bexp2
    (54) andor -> . AND
    (55) andor -> . OR

    RPAREN          shift and go to state 85
    AND             shift and go to state 87
    OR              shift and go to state 88

    andor                          shift and go to state 86

state 64

    (47) bexp -> bexp2 .
    (48) bexp2 -> bexp2 . rln exp
    (50) rln -> . DEQUAL
    (51) rln -> . GTHEN
    (52) rln -> . LTHEN
    (53) rln -> . NOT

    RPAREN          reduce using rule 47 (bexp -> bexp2 .)
    AND             reduce using rule 47 (bexp -> bexp2 .)
    OR              reduce using rule 47 (bexp -> bexp2 .)
    SCOLON          reduce using rule 47 (bexp -> bexp2 .)
    DEQUAL          shift and go to state 90
    GTHEN           shift and go to state 91
    LTHEN           shift and go to state 92
    NOT             shift and go to state 93

    rln                            shift and go to state 89

state 65

    (49) bexp2 -> exp .
    (23) exp -> exp . PLUS term
    (24) exp -> exp . MINUS term

    DEQUAL          reduce using rule 49 (bexp2 -> exp .)
    GTHEN           reduce using rule 49 (bexp2 -> exp .)
    LTHEN           reduce using rule 49 (bexp2 -> exp .)
    NOT             reduce using rule 49 (bexp2 -> exp .)
    RPAREN          reduce using rule 49 (bexp2 -> exp .)
    AND             reduce using rule 49 (bexp2 -> exp .)
    OR              reduce using rule 49 (bexp2 -> exp .)
    SCOLON          reduce using rule 49 (bexp2 -> exp .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72


state 66

    (16) ifsts -> IF LPAREN bexp . RPAREN lcb line rcb elsests
    (46) bexp -> bexp . andor bexp2
    (54) andor -> . AND
    (55) andor -> . OR

    RPAREN          shift and go to state 94
    AND             shift and go to state 87
    OR              shift and go to state 88

    andor                          shift and go to state 86

state 67

    (57) assign -> varval EQUAL exp .
    (23) exp -> exp . PLUS term
    (24) exp -> exp . MINUS term

    SCOLON          reduce using rule 57 (assign -> varval EQUAL exp .)
    RPAREN          reduce using rule 57 (assign -> varval EQUAL exp .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72


state 68

    (58) assign -> varval EQUAL STRING .

    SCOLON          reduce using rule 58 (assign -> varval EQUAL STRING .)
    RPAREN          reduce using rule 58 (assign -> varval EQUAL STRING .)


state 69

    (61) nline -> dtype LBB RBB IDVAR . EQUAL arrt SCOLON

    EQUAL           shift and go to state 95


state 70

    (36) varval -> var LBB exp RBB .

    EQUAL           reduce using rule 36 (varval -> var LBB exp RBB .)
    MUL             reduce using rule 36 (varval -> var LBB exp RBB .)
    DIV             reduce using rule 36 (varval -> var LBB exp RBB .)
    MOD             reduce using rule 36 (varval -> var LBB exp RBB .)
    RBB             reduce using rule 36 (varval -> var LBB exp RBB .)
    PLUS            reduce using rule 36 (varval -> var LBB exp RBB .)
    MINUS           reduce using rule 36 (varval -> var LBB exp RBB .)
    RPAREN          reduce using rule 36 (varval -> var LBB exp RBB .)
    DEQUAL          reduce using rule 36 (varval -> var LBB exp RBB .)
    GTHEN           reduce using rule 36 (varval -> var LBB exp RBB .)
    LTHEN           reduce using rule 36 (varval -> var LBB exp RBB .)
    NOT             reduce using rule 36 (varval -> var LBB exp RBB .)
    AND             reduce using rule 36 (varval -> var LBB exp RBB .)
    OR              reduce using rule 36 (varval -> var LBB exp RBB .)
    SCOLON          reduce using rule 36 (varval -> var LBB exp RBB .)
    COM             reduce using rule 36 (varval -> var LBB exp RBB .)
    RCB             reduce using rule 36 (varval -> var LBB exp RBB .)


state 71

    (23) exp -> exp PLUS . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (37) bval -> . TRUE
    (38) bval -> . FALSE
    (39) var -> . IDVAR

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    IDVAR           shift and go to state 7

    term                           shift and go to state 96
    fact                           shift and go to state 43
    varval                         shift and go to state 46
    bval                           shift and go to state 47
    var                            shift and go to state 4

state 72

    (24) exp -> exp MINUS . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (37) bval -> . TRUE
    (38) bval -> . FALSE
    (39) var -> . IDVAR

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    IDVAR           shift and go to state 7

    term                           shift and go to state 97
    fact                           shift and go to state 43
    varval                         shift and go to state 46
    bval                           shift and go to state 47
    var                            shift and go to state 4

state 73

    (26) term -> term MUL . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (37) bval -> . TRUE
    (38) bval -> . FALSE
    (39) var -> . IDVAR

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    IDVAR           shift and go to state 7

    fact                           shift and go to state 98
    varval                         shift and go to state 46
    bval                           shift and go to state 47
    var                            shift and go to state 4

state 74

    (27) term -> term DIV . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (37) bval -> . TRUE
    (38) bval -> . FALSE
    (39) var -> . IDVAR

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    IDVAR           shift and go to state 7

    fact                           shift and go to state 99
    varval                         shift and go to state 46
    bval                           shift and go to state 47
    var                            shift and go to state 4

state 75

    (28) term -> term MOD . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (37) bval -> . TRUE
    (38) bval -> . FALSE
    (39) var -> . IDVAR

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    IDVAR           shift and go to state 7

    fact                           shift and go to state 100
    varval                         shift and go to state 46
    bval                           shift and go to state 47
    var                            shift and go to state 4

state 76

    (6) nline -> STR IDVAR EQUAL strvar . SCOLON

    SCOLON          shift and go to state 101


state 77

    (44) strvar -> STRING .

    SCOLON          reduce using rule 44 (strvar -> STRING .)


state 78

    (45) strvar -> varval .

    SCOLON          reduce using rule 45 (strvar -> varval .)


state 79

    (62) nline -> STR LBB RBB IDVAR . EQUAL arrt SCOLON

    EQUAL           shift and go to state 102


state 80

    (7) nline -> BOOL MAIN LPAREN RPAREN . lcb line rcb
    (18) lcb -> . LCB

    LCB             shift and go to state 104

    lcb                            shift and go to state 103

state 81

    (8) nline -> RETURN LPAREN bval RPAREN . SCOLON

    SCOLON          shift and go to state 105


state 82

    (10) nline -> EXIT LPAREN RPAREN SCOLON .

    STR             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    BOOL            reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    RETURN          reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    EXIT            reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    PRINT           reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    FOR             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    WHILE           reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    INT             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    FLT             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    CHR             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    IF              reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    IDVAR           reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    $end            reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    RCB             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)


state 83

    (11) nline -> PRINT LPAREN pline RPAREN . SCOLON

    SCOLON          shift and go to state 106


state 84

    (14) nline -> FOR LPAREN fline bexp . SCOLON assign RPAREN lcb line rcb
    (46) bexp -> bexp . andor bexp2
    (54) andor -> . AND
    (55) andor -> . OR

    SCOLON          shift and go to state 107
    AND             shift and go to state 87
    OR              shift and go to state 88

    andor                          shift and go to state 86

state 85

    (15) nline -> WHILE LPAREN bexp RPAREN . lcb line rcb
    (18) lcb -> . LCB

    LCB             shift and go to state 104

    lcb                            shift and go to state 108

state 86

    (46) bexp -> bexp andor . bexp2
    (48) bexp2 -> . bexp2 rln exp
    (49) bexp2 -> . exp
    (23) exp -> . exp PLUS term
    (24) exp -> . exp MINUS term
    (25) exp -> . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (37) bval -> . TRUE
    (38) bval -> . FALSE
    (39) var -> . IDVAR

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    IDVAR           shift and go to state 7

    bexp2                          shift and go to state 109
    exp                            shift and go to state 65
    term                           shift and go to state 42
    fact                           shift and go to state 43
    varval                         shift and go to state 46
    bval                           shift and go to state 47
    var                            shift and go to state 4

state 87

    (54) andor -> AND .

    INTEGER         reduce using rule 54 (andor -> AND .)
    FLOAT           reduce using rule 54 (andor -> AND .)
    CHAR            reduce using rule 54 (andor -> AND .)
    TRUE            reduce using rule 54 (andor -> AND .)
    FALSE           reduce using rule 54 (andor -> AND .)
    IDVAR           reduce using rule 54 (andor -> AND .)


state 88

    (55) andor -> OR .

    INTEGER         reduce using rule 55 (andor -> OR .)
    FLOAT           reduce using rule 55 (andor -> OR .)
    CHAR            reduce using rule 55 (andor -> OR .)
    TRUE            reduce using rule 55 (andor -> OR .)
    FALSE           reduce using rule 55 (andor -> OR .)
    IDVAR           reduce using rule 55 (andor -> OR .)


state 89

    (48) bexp2 -> bexp2 rln . exp
    (23) exp -> . exp PLUS term
    (24) exp -> . exp MINUS term
    (25) exp -> . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (37) bval -> . TRUE
    (38) bval -> . FALSE
    (39) var -> . IDVAR

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    IDVAR           shift and go to state 7

    exp                            shift and go to state 110
    term                           shift and go to state 42
    fact                           shift and go to state 43
    varval                         shift and go to state 46
    bval                           shift and go to state 47
    var                            shift and go to state 4

state 90

    (50) rln -> DEQUAL .

    INTEGER         reduce using rule 50 (rln -> DEQUAL .)
    FLOAT           reduce using rule 50 (rln -> DEQUAL .)
    CHAR            reduce using rule 50 (rln -> DEQUAL .)
    TRUE            reduce using rule 50 (rln -> DEQUAL .)
    FALSE           reduce using rule 50 (rln -> DEQUAL .)
    IDVAR           reduce using rule 50 (rln -> DEQUAL .)


state 91

    (51) rln -> GTHEN .

    INTEGER         reduce using rule 51 (rln -> GTHEN .)
    FLOAT           reduce using rule 51 (rln -> GTHEN .)
    CHAR            reduce using rule 51 (rln -> GTHEN .)
    TRUE            reduce using rule 51 (rln -> GTHEN .)
    FALSE           reduce using rule 51 (rln -> GTHEN .)
    IDVAR           reduce using rule 51 (rln -> GTHEN .)


state 92

    (52) rln -> LTHEN .

    INTEGER         reduce using rule 52 (rln -> LTHEN .)
    FLOAT           reduce using rule 52 (rln -> LTHEN .)
    CHAR            reduce using rule 52 (rln -> LTHEN .)
    TRUE            reduce using rule 52 (rln -> LTHEN .)
    FALSE           reduce using rule 52 (rln -> LTHEN .)
    IDVAR           reduce using rule 52 (rln -> LTHEN .)


state 93

    (53) rln -> NOT .

    INTEGER         reduce using rule 53 (rln -> NOT .)
    FLOAT           reduce using rule 53 (rln -> NOT .)
    CHAR            reduce using rule 53 (rln -> NOT .)
    TRUE            reduce using rule 53 (rln -> NOT .)
    FALSE           reduce using rule 53 (rln -> NOT .)
    IDVAR           reduce using rule 53 (rln -> NOT .)


state 94

    (16) ifsts -> IF LPAREN bexp RPAREN . lcb line rcb elsests
    (18) lcb -> . LCB

    LCB             shift and go to state 104

    lcb                            shift and go to state 111

state 95

    (61) nline -> dtype LBB RBB IDVAR EQUAL . arrt SCOLON
    (63) arrt -> . var
    (64) arrt -> . LCB dws RCB
    (39) var -> . IDVAR

    LCB             shift and go to state 114
    IDVAR           shift and go to state 7

    arrt                           shift and go to state 112
    var                            shift and go to state 113

state 96

    (23) exp -> exp PLUS term .
    (26) term -> term . MUL fact
    (27) term -> term . DIV fact
    (28) term -> term . MOD fact

    RBB             reduce using rule 23 (exp -> exp PLUS term .)
    PLUS            reduce using rule 23 (exp -> exp PLUS term .)
    MINUS           reduce using rule 23 (exp -> exp PLUS term .)
    RPAREN          reduce using rule 23 (exp -> exp PLUS term .)
    DEQUAL          reduce using rule 23 (exp -> exp PLUS term .)
    GTHEN           reduce using rule 23 (exp -> exp PLUS term .)
    LTHEN           reduce using rule 23 (exp -> exp PLUS term .)
    NOT             reduce using rule 23 (exp -> exp PLUS term .)
    AND             reduce using rule 23 (exp -> exp PLUS term .)
    OR              reduce using rule 23 (exp -> exp PLUS term .)
    SCOLON          reduce using rule 23 (exp -> exp PLUS term .)
    MUL             shift and go to state 73
    DIV             shift and go to state 74
    MOD             shift and go to state 75


state 97

    (24) exp -> exp MINUS term .
    (26) term -> term . MUL fact
    (27) term -> term . DIV fact
    (28) term -> term . MOD fact

    RBB             reduce using rule 24 (exp -> exp MINUS term .)
    PLUS            reduce using rule 24 (exp -> exp MINUS term .)
    MINUS           reduce using rule 24 (exp -> exp MINUS term .)
    RPAREN          reduce using rule 24 (exp -> exp MINUS term .)
    DEQUAL          reduce using rule 24 (exp -> exp MINUS term .)
    GTHEN           reduce using rule 24 (exp -> exp MINUS term .)
    LTHEN           reduce using rule 24 (exp -> exp MINUS term .)
    NOT             reduce using rule 24 (exp -> exp MINUS term .)
    AND             reduce using rule 24 (exp -> exp MINUS term .)
    OR              reduce using rule 24 (exp -> exp MINUS term .)
    SCOLON          reduce using rule 24 (exp -> exp MINUS term .)
    MUL             shift and go to state 73
    DIV             shift and go to state 74
    MOD             shift and go to state 75


state 98

    (26) term -> term MUL fact .

    MUL             reduce using rule 26 (term -> term MUL fact .)
    DIV             reduce using rule 26 (term -> term MUL fact .)
    MOD             reduce using rule 26 (term -> term MUL fact .)
    RBB             reduce using rule 26 (term -> term MUL fact .)
    PLUS            reduce using rule 26 (term -> term MUL fact .)
    MINUS           reduce using rule 26 (term -> term MUL fact .)
    RPAREN          reduce using rule 26 (term -> term MUL fact .)
    DEQUAL          reduce using rule 26 (term -> term MUL fact .)
    GTHEN           reduce using rule 26 (term -> term MUL fact .)
    LTHEN           reduce using rule 26 (term -> term MUL fact .)
    NOT             reduce using rule 26 (term -> term MUL fact .)
    AND             reduce using rule 26 (term -> term MUL fact .)
    OR              reduce using rule 26 (term -> term MUL fact .)
    SCOLON          reduce using rule 26 (term -> term MUL fact .)


state 99

    (27) term -> term DIV fact .

    MUL             reduce using rule 27 (term -> term DIV fact .)
    DIV             reduce using rule 27 (term -> term DIV fact .)
    MOD             reduce using rule 27 (term -> term DIV fact .)
    RBB             reduce using rule 27 (term -> term DIV fact .)
    PLUS            reduce using rule 27 (term -> term DIV fact .)
    MINUS           reduce using rule 27 (term -> term DIV fact .)
    RPAREN          reduce using rule 27 (term -> term DIV fact .)
    DEQUAL          reduce using rule 27 (term -> term DIV fact .)
    GTHEN           reduce using rule 27 (term -> term DIV fact .)
    LTHEN           reduce using rule 27 (term -> term DIV fact .)
    NOT             reduce using rule 27 (term -> term DIV fact .)
    AND             reduce using rule 27 (term -> term DIV fact .)
    OR              reduce using rule 27 (term -> term DIV fact .)
    SCOLON          reduce using rule 27 (term -> term DIV fact .)


state 100

    (28) term -> term MOD fact .

    MUL             reduce using rule 28 (term -> term MOD fact .)
    DIV             reduce using rule 28 (term -> term MOD fact .)
    MOD             reduce using rule 28 (term -> term MOD fact .)
    RBB             reduce using rule 28 (term -> term MOD fact .)
    PLUS            reduce using rule 28 (term -> term MOD fact .)
    MINUS           reduce using rule 28 (term -> term MOD fact .)
    RPAREN          reduce using rule 28 (term -> term MOD fact .)
    DEQUAL          reduce using rule 28 (term -> term MOD fact .)
    GTHEN           reduce using rule 28 (term -> term MOD fact .)
    LTHEN           reduce using rule 28 (term -> term MOD fact .)
    NOT             reduce using rule 28 (term -> term MOD fact .)
    AND             reduce using rule 28 (term -> term MOD fact .)
    OR              reduce using rule 28 (term -> term MOD fact .)
    SCOLON          reduce using rule 28 (term -> term MOD fact .)


state 101

    (6) nline -> STR IDVAR EQUAL strvar SCOLON .

    STR             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    BOOL            reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    RETURN          reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    EXIT            reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    PRINT           reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    FOR             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    WHILE           reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    INT             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    FLT             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    CHR             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    IF              reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    IDVAR           reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    $end            reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    RCB             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)


state 102

    (62) nline -> STR LBB RBB IDVAR EQUAL . arrt SCOLON
    (63) arrt -> . var
    (64) arrt -> . LCB dws RCB
    (39) var -> . IDVAR

    LCB             shift and go to state 114
    IDVAR           shift and go to state 7

    arrt                           shift and go to state 115
    var                            shift and go to state 113

state 103

    (7) nline -> BOOL MAIN LPAREN RPAREN lcb . line rcb
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN lcb line rcb
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb
    (15) nline -> . WHILE LPAREN bexp RPAREN lcb line rcb
    (61) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (62) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (40) dtype -> . INT
    (41) dtype -> . FLT
    (42) dtype -> . CHR
    (43) dtype -> . BOOL
    (59) fline -> . dtype numexp
    (60) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN lcb line rcb elsests
    (22) numexp -> . assign SCOLON
    (57) assign -> . varval EQUAL exp
    (58) assign -> . varval EQUAL STRING
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) var -> . IDVAR

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 116
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19
    varval                         shift and go to state 21

state 104

    (18) lcb -> LCB .

    STR             reduce using rule 18 (lcb -> LCB .)
    BOOL            reduce using rule 18 (lcb -> LCB .)
    RETURN          reduce using rule 18 (lcb -> LCB .)
    EXIT            reduce using rule 18 (lcb -> LCB .)
    PRINT           reduce using rule 18 (lcb -> LCB .)
    FOR             reduce using rule 18 (lcb -> LCB .)
    WHILE           reduce using rule 18 (lcb -> LCB .)
    INT             reduce using rule 18 (lcb -> LCB .)
    FLT             reduce using rule 18 (lcb -> LCB .)
    CHR             reduce using rule 18 (lcb -> LCB .)
    IF              reduce using rule 18 (lcb -> LCB .)
    IDVAR           reduce using rule 18 (lcb -> LCB .)


state 105

    (8) nline -> RETURN LPAREN bval RPAREN SCOLON .

    STR             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    BOOL            reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    RETURN          reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    EXIT            reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    PRINT           reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    FOR             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    WHILE           reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    INT             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    FLT             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    CHR             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    IF              reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    IDVAR           reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    $end            reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    RCB             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)


state 106

    (11) nline -> PRINT LPAREN pline RPAREN SCOLON .

    STR             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    BOOL            reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    RETURN          reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    EXIT            reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    PRINT           reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    FOR             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    WHILE           reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    INT             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    FLT             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    CHR             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    IF              reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    IDVAR           reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    $end            reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    RCB             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)


state 107

    (14) nline -> FOR LPAREN fline bexp SCOLON . assign RPAREN lcb line rcb
    (57) assign -> . varval EQUAL exp
    (58) assign -> . varval EQUAL STRING
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) var -> . IDVAR

    IDVAR           shift and go to state 7

    assign                         shift and go to state 117
    varval                         shift and go to state 21
    var                            shift and go to state 4

state 108

    (15) nline -> WHILE LPAREN bexp RPAREN lcb . line rcb
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN lcb line rcb
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb
    (15) nline -> . WHILE LPAREN bexp RPAREN lcb line rcb
    (61) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (62) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (40) dtype -> . INT
    (41) dtype -> . FLT
    (42) dtype -> . CHR
    (43) dtype -> . BOOL
    (59) fline -> . dtype numexp
    (60) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN lcb line rcb elsests
    (22) numexp -> . assign SCOLON
    (57) assign -> . varval EQUAL exp
    (58) assign -> . varval EQUAL STRING
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) var -> . IDVAR

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 118
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19
    varval                         shift and go to state 21

state 109

    (46) bexp -> bexp andor bexp2 .
    (48) bexp2 -> bexp2 . rln exp
    (50) rln -> . DEQUAL
    (51) rln -> . GTHEN
    (52) rln -> . LTHEN
    (53) rln -> . NOT

    RPAREN          reduce using rule 46 (bexp -> bexp andor bexp2 .)
    AND             reduce using rule 46 (bexp -> bexp andor bexp2 .)
    OR              reduce using rule 46 (bexp -> bexp andor bexp2 .)
    SCOLON          reduce using rule 46 (bexp -> bexp andor bexp2 .)
    DEQUAL          shift and go to state 90
    GTHEN           shift and go to state 91
    LTHEN           shift and go to state 92
    NOT             shift and go to state 93

    rln                            shift and go to state 89

state 110

    (48) bexp2 -> bexp2 rln exp .
    (23) exp -> exp . PLUS term
    (24) exp -> exp . MINUS term

    DEQUAL          reduce using rule 48 (bexp2 -> bexp2 rln exp .)
    GTHEN           reduce using rule 48 (bexp2 -> bexp2 rln exp .)
    LTHEN           reduce using rule 48 (bexp2 -> bexp2 rln exp .)
    NOT             reduce using rule 48 (bexp2 -> bexp2 rln exp .)
    RPAREN          reduce using rule 48 (bexp2 -> bexp2 rln exp .)
    AND             reduce using rule 48 (bexp2 -> bexp2 rln exp .)
    OR              reduce using rule 48 (bexp2 -> bexp2 rln exp .)
    SCOLON          reduce using rule 48 (bexp2 -> bexp2 rln exp .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72


state 111

    (16) ifsts -> IF LPAREN bexp RPAREN lcb . line rcb elsests
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN lcb line rcb
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb
    (15) nline -> . WHILE LPAREN bexp RPAREN lcb line rcb
    (61) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (62) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (40) dtype -> . INT
    (41) dtype -> . FLT
    (42) dtype -> . CHR
    (43) dtype -> . BOOL
    (59) fline -> . dtype numexp
    (60) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN lcb line rcb elsests
    (22) numexp -> . assign SCOLON
    (57) assign -> . varval EQUAL exp
    (58) assign -> . varval EQUAL STRING
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) var -> . IDVAR

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 119
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19
    varval                         shift and go to state 21

state 112

    (61) nline -> dtype LBB RBB IDVAR EQUAL arrt . SCOLON

    SCOLON          shift and go to state 120


state 113

    (63) arrt -> var .

    SCOLON          reduce using rule 63 (arrt -> var .)


state 114

    (64) arrt -> LCB . dws RCB
    (65) dws -> . factarr COM dws
    (66) dws -> . factarr
    (67) factarr -> . fact
    (68) factarr -> . STRING
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (37) bval -> . TRUE
    (38) bval -> . FALSE
    (39) var -> . IDVAR

    STRING          shift and go to state 124
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    IDVAR           shift and go to state 7

    dws                            shift and go to state 121
    factarr                        shift and go to state 122
    fact                           shift and go to state 123
    varval                         shift and go to state 46
    bval                           shift and go to state 47
    var                            shift and go to state 4

state 115

    (62) nline -> STR LBB RBB IDVAR EQUAL arrt . SCOLON

    SCOLON          shift and go to state 125


state 116

    (7) nline -> BOOL MAIN LPAREN RPAREN lcb line . rcb
    (17) rcb -> . RCB

    RCB             shift and go to state 127

    rcb                            shift and go to state 126

state 117

    (14) nline -> FOR LPAREN fline bexp SCOLON assign . RPAREN lcb line rcb

    RPAREN          shift and go to state 128


state 118

    (15) nline -> WHILE LPAREN bexp RPAREN lcb line . rcb
    (17) rcb -> . RCB

    RCB             shift and go to state 127

    rcb                            shift and go to state 129

state 119

    (16) ifsts -> IF LPAREN bexp RPAREN lcb line . rcb elsests
    (17) rcb -> . RCB

    RCB             shift and go to state 127

    rcb                            shift and go to state 130

state 120

    (61) nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .

    STR             reduce using rule 61 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    BOOL            reduce using rule 61 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    RETURN          reduce using rule 61 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    EXIT            reduce using rule 61 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    PRINT           reduce using rule 61 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    FOR             reduce using rule 61 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    WHILE           reduce using rule 61 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    INT             reduce using rule 61 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    FLT             reduce using rule 61 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    CHR             reduce using rule 61 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    IF              reduce using rule 61 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    IDVAR           reduce using rule 61 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    $end            reduce using rule 61 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    RCB             reduce using rule 61 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)


state 121

    (64) arrt -> LCB dws . RCB

    RCB             shift and go to state 131


state 122

    (65) dws -> factarr . COM dws
    (66) dws -> factarr .

    COM             shift and go to state 132
    RCB             reduce using rule 66 (dws -> factarr .)


state 123

    (67) factarr -> fact .

    COM             reduce using rule 67 (factarr -> fact .)
    RCB             reduce using rule 67 (factarr -> fact .)


state 124

    (68) factarr -> STRING .

    COM             reduce using rule 68 (factarr -> STRING .)
    RCB             reduce using rule 68 (factarr -> STRING .)


state 125

    (62) nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .

    STR             reduce using rule 62 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    BOOL            reduce using rule 62 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    RETURN          reduce using rule 62 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    EXIT            reduce using rule 62 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    PRINT           reduce using rule 62 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    FOR             reduce using rule 62 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    WHILE           reduce using rule 62 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    INT             reduce using rule 62 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    FLT             reduce using rule 62 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    CHR             reduce using rule 62 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    IF              reduce using rule 62 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    IDVAR           reduce using rule 62 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    $end            reduce using rule 62 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    RCB             reduce using rule 62 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)


state 126

    (7) nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .

    STR             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    BOOL            reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    RETURN          reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    EXIT            reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    PRINT           reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    FOR             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    WHILE           reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    INT             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    FLT             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    CHR             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    IF              reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    IDVAR           reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    $end            reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    RCB             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)


state 127

    (17) rcb -> RCB .

    STR             reduce using rule 17 (rcb -> RCB .)
    BOOL            reduce using rule 17 (rcb -> RCB .)
    RETURN          reduce using rule 17 (rcb -> RCB .)
    EXIT            reduce using rule 17 (rcb -> RCB .)
    PRINT           reduce using rule 17 (rcb -> RCB .)
    FOR             reduce using rule 17 (rcb -> RCB .)
    WHILE           reduce using rule 17 (rcb -> RCB .)
    INT             reduce using rule 17 (rcb -> RCB .)
    FLT             reduce using rule 17 (rcb -> RCB .)
    CHR             reduce using rule 17 (rcb -> RCB .)
    IF              reduce using rule 17 (rcb -> RCB .)
    IDVAR           reduce using rule 17 (rcb -> RCB .)
    $end            reduce using rule 17 (rcb -> RCB .)
    RCB             reduce using rule 17 (rcb -> RCB .)
    ELSE            reduce using rule 17 (rcb -> RCB .)


state 128

    (14) nline -> FOR LPAREN fline bexp SCOLON assign RPAREN . lcb line rcb
    (18) lcb -> . LCB

    LCB             shift and go to state 104

    lcb                            shift and go to state 133

state 129

    (15) nline -> WHILE LPAREN bexp RPAREN lcb line rcb .

    STR             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    BOOL            reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    RETURN          reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    EXIT            reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    PRINT           reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    FOR             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    WHILE           reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    INT             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    FLT             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    CHR             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    IF              reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    IDVAR           reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    $end            reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    RCB             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)


state 130

    (16) ifsts -> IF LPAREN bexp RPAREN lcb line rcb . elsests
    (19) elsests -> . ELSE lcb line rcb
    (20) elsests -> . ELSE ifsts
    (21) elsests -> . empty
    (56) empty -> .

    ELSE            shift and go to state 135
    STR             reduce using rule 56 (empty -> .)
    BOOL            reduce using rule 56 (empty -> .)
    RETURN          reduce using rule 56 (empty -> .)
    EXIT            reduce using rule 56 (empty -> .)
    PRINT           reduce using rule 56 (empty -> .)
    FOR             reduce using rule 56 (empty -> .)
    WHILE           reduce using rule 56 (empty -> .)
    INT             reduce using rule 56 (empty -> .)
    FLT             reduce using rule 56 (empty -> .)
    CHR             reduce using rule 56 (empty -> .)
    IF              reduce using rule 56 (empty -> .)
    IDVAR           reduce using rule 56 (empty -> .)
    $end            reduce using rule 56 (empty -> .)
    RCB             reduce using rule 56 (empty -> .)

    elsests                        shift and go to state 134
    empty                          shift and go to state 136

state 131

    (64) arrt -> LCB dws RCB .

    SCOLON          reduce using rule 64 (arrt -> LCB dws RCB .)


state 132

    (65) dws -> factarr COM . dws
    (65) dws -> . factarr COM dws
    (66) dws -> . factarr
    (67) factarr -> . fact
    (68) factarr -> . STRING
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (37) bval -> . TRUE
    (38) bval -> . FALSE
    (39) var -> . IDVAR

    STRING          shift and go to state 124
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    IDVAR           shift and go to state 7

    factarr                        shift and go to state 122
    dws                            shift and go to state 137
    fact                           shift and go to state 123
    varval                         shift and go to state 46
    bval                           shift and go to state 47
    var                            shift and go to state 4

state 133

    (14) nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb . line rcb
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN lcb line rcb
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb
    (15) nline -> . WHILE LPAREN bexp RPAREN lcb line rcb
    (61) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (62) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (40) dtype -> . INT
    (41) dtype -> . FLT
    (42) dtype -> . CHR
    (43) dtype -> . BOOL
    (59) fline -> . dtype numexp
    (60) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN lcb line rcb elsests
    (22) numexp -> . assign SCOLON
    (57) assign -> . varval EQUAL exp
    (58) assign -> . varval EQUAL STRING
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) var -> . IDVAR

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    fline                          shift and go to state 6
    assign                         shift and go to state 14
    line                           shift and go to state 138
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    ifsts                          shift and go to state 10
    numexp                         shift and go to state 19
    varval                         shift and go to state 21

state 134

    (16) ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .

    STR             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    BOOL            reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    RETURN          reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    EXIT            reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    PRINT           reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    FOR             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    WHILE           reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    INT             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    FLT             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    CHR             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    IF              reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    IDVAR           reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    $end            reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    RCB             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)


state 135

    (19) elsests -> ELSE . lcb line rcb
    (20) elsests -> ELSE . ifsts
    (18) lcb -> . LCB
    (16) ifsts -> . IF LPAREN bexp RPAREN lcb line rcb elsests

    LCB             shift and go to state 104
    IF              shift and go to state 20

    lcb                            shift and go to state 139
    ifsts                          shift and go to state 140

state 136

    (21) elsests -> empty .

    STR             reduce using rule 21 (elsests -> empty .)
    BOOL            reduce using rule 21 (elsests -> empty .)
    RETURN          reduce using rule 21 (elsests -> empty .)
    EXIT            reduce using rule 21 (elsests -> empty .)
    PRINT           reduce using rule 21 (elsests -> empty .)
    FOR             reduce using rule 21 (elsests -> empty .)
    WHILE           reduce using rule 21 (elsests -> empty .)
    INT             reduce using rule 21 (elsests -> empty .)
    FLT             reduce using rule 21 (elsests -> empty .)
    CHR             reduce using rule 21 (elsests -> empty .)
    IF              reduce using rule 21 (elsests -> empty .)
    IDVAR           reduce using rule 21 (elsests -> empty .)
    $end            reduce using rule 21 (elsests -> empty .)
    RCB             reduce using rule 21 (elsests -> empty .)


state 137

    (65) dws -> factarr COM dws .

    RCB             reduce using rule 65 (dws -> factarr COM dws .)


state 138

    (14) nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line . rcb
    (17) rcb -> . RCB

    RCB             shift and go to state 127

    rcb                            shift and go to state 141

state 139

    (19) elsests -> ELSE lcb . line rcb
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN lcb line rcb
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb
    (15) nline -> . WHILE LPAREN bexp RPAREN lcb line rcb
    (61) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (62) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (40) dtype -> . INT
    (41) dtype -> . FLT
    (42) dtype -> . CHR
    (43) dtype -> . BOOL
    (59) fline -> . dtype numexp
    (60) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN lcb line rcb elsests
    (22) numexp -> . assign SCOLON
    (57) assign -> . varval EQUAL exp
    (58) assign -> . varval EQUAL STRING
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) var -> . IDVAR

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 142
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19
    varval                         shift and go to state 21

state 140

    (20) elsests -> ELSE ifsts .

    STR             reduce using rule 20 (elsests -> ELSE ifsts .)
    BOOL            reduce using rule 20 (elsests -> ELSE ifsts .)
    RETURN          reduce using rule 20 (elsests -> ELSE ifsts .)
    EXIT            reduce using rule 20 (elsests -> ELSE ifsts .)
    PRINT           reduce using rule 20 (elsests -> ELSE ifsts .)
    FOR             reduce using rule 20 (elsests -> ELSE ifsts .)
    WHILE           reduce using rule 20 (elsests -> ELSE ifsts .)
    INT             reduce using rule 20 (elsests -> ELSE ifsts .)
    FLT             reduce using rule 20 (elsests -> ELSE ifsts .)
    CHR             reduce using rule 20 (elsests -> ELSE ifsts .)
    IF              reduce using rule 20 (elsests -> ELSE ifsts .)
    IDVAR           reduce using rule 20 (elsests -> ELSE ifsts .)
    $end            reduce using rule 20 (elsests -> ELSE ifsts .)
    RCB             reduce using rule 20 (elsests -> ELSE ifsts .)


state 141

    (14) nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .

    STR             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    BOOL            reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    RETURN          reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    EXIT            reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    PRINT           reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    FOR             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    WHILE           reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    INT             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    FLT             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    CHR             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    IF              reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    IDVAR           reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    $end            reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    RCB             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)


state 142

    (19) elsests -> ELSE lcb line . rcb
    (17) rcb -> . RCB

    RCB             shift and go to state 127

    rcb                            shift and go to state 143

state 143

    (19) elsests -> ELSE lcb line rcb .

    STR             reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    BOOL            reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    RETURN          reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    EXIT            reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    PRINT           reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    FOR             reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    WHILE           reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    INT             reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    FLT             reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    CHR             reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    IF              reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    IDVAR           reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    $end            reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    RCB             reduce using rule 19 (elsests -> ELSE lcb line rcb .)

