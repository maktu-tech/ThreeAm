Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    VOID
    WITH

Grammar

Rule 0     S' -> line
Rule 1     line -> nline line
Rule 2     line -> nline
Rule 3     nline -> dtype var SCOLON
Rule 4     nline -> STR var SCOLON
Rule 5     nline -> fline
Rule 6     nline -> STR IDVAR EQUAL strvar SCOLON
Rule 7     nline -> BOOL MAIN LPAREN RPAREN LCB line RCB
Rule 8     nline -> RETURN LPAREN bval RPAREN SCOLON
Rule 9     nline -> ifsts
Rule 10    nline -> EXIT LPAREN RPAREN SCOLON
Rule 11    nline -> PRINT LPAREN pline RPAREN SCOLON
Rule 12    pline -> exp
Rule 13    pline -> STRING
Rule 14    nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB
Rule 15    nline -> WHILE LPAREN bexp RPAREN LCB line RCB
Rule 16    ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests
Rule 17    elsests -> ELSE LCB line RCB
Rule 18    elsests -> ELSE ifsts
Rule 19    elsests -> empty
Rule 20    numexp -> assign SCOLON
Rule 21    exp -> exp PLUS term
Rule 22    exp -> exp MINUS term
Rule 23    exp -> term
Rule 24    term -> term MUL fact
Rule 25    term -> term DIV fact
Rule 26    term -> term MOD fact
Rule 27    term -> fact
Rule 28    fact -> INTEGER
Rule 29    fact -> FLOAT
Rule 30    fact -> varval
Rule 31    fact -> bval
Rule 32    fact -> CHAR
Rule 33    varval -> var
Rule 34    bval -> TRUE
Rule 35    bval -> FALSE
Rule 36    var -> IDVAR
Rule 37    var -> IDVAR LBB INTEGER RBB
Rule 38    var -> IDVAR LBB IDVAR RBB
Rule 39    dtype -> INT
Rule 40    dtype -> FLT
Rule 41    dtype -> CHR
Rule 42    dtype -> BOOL
Rule 43    strvar -> STRING
Rule 44    strvar -> varval
Rule 45    bexp -> bexp andor bexp2
Rule 46    bexp -> bexp2
Rule 47    bexp2 -> bexp2 rln exp
Rule 48    bexp2 -> exp
Rule 49    rln -> DEQUAL
Rule 50    rln -> GTHEN
Rule 51    rln -> LTHEN
Rule 52    rln -> NOT
Rule 53    andor -> AND
Rule 54    andor -> OR
Rule 55    empty -> <empty>
Rule 56    assign -> var EQUAL exp
Rule 57    assign -> var EQUAL STRING
Rule 58    fline -> dtype numexp
Rule 59    fline -> numexp
Rule 60    nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON
Rule 61    nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON
Rule 62    arrt -> var
Rule 63    arrt -> LCB dws RCB
Rule 64    dws -> factarr COM dws
Rule 65    dws -> factarr
Rule 66    factarr -> fact
Rule 67    factarr -> STRING

Terminals, with rules where they appear

AND                  : 53
BOOL                 : 7 42
CHAR                 : 32
CHR                  : 41
COM                  : 64
COMMENT              : 
DEQUAL               : 49
DIV                  : 25
ELSE                 : 17 18
EQUAL                : 6 56 57 60 61
EXIT                 : 10
FALSE                : 35
FLOAT                : 29
FLT                  : 40
FOR                  : 14
GTHEN                : 50
IDVAR                : 6 36 37 38 38 60 61
IF                   : 16
INT                  : 39
INTEGER              : 28 37
LBB                  : 37 38 60 61
LCB                  : 7 14 15 16 17 63
LPAREN               : 7 8 10 11 14 15 16
LTHEN                : 51
MAIN                 : 7
MINUS                : 22
MOD                  : 26
MUL                  : 24
NOT                  : 52
OR                   : 54
PLUS                 : 21
PRINT                : 11
RBB                  : 37 38 60 61
RCB                  : 7 14 15 16 17 63
RETURN               : 8
RPAREN               : 7 8 10 11 14 15 16
SCOLON               : 3 4 6 8 10 11 14 20 60 61
STR                  : 4 6 61
STRING               : 13 43 57 67
TRUE                 : 34
VOID                 : 
WHILE                : 15
WITH                 : 
error                : 

Nonterminals, with rules where they appear

andor                : 45
arrt                 : 60 61
assign               : 14 20
bexp                 : 14 15 16 45
bexp2                : 45 46 47
bval                 : 8 31
dtype                : 3 58 60
dws                  : 63 64
elsests              : 16
empty                : 19
exp                  : 12 21 22 47 48 56
fact                 : 24 25 26 27 66
factarr              : 64 65
fline                : 5 14
ifsts                : 9 18
line                 : 1 7 14 15 16 17 0
nline                : 1 2
numexp               : 58 59
pline                : 11
rln                  : 47
strvar               : 6
term                 : 21 22 23 24 25 26
var                  : 3 4 33 56 57 62
varval               : 30 44

Parsing method: LALR

state 0

    (0) S' -> . line
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN LCB line RCB
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB
    (15) nline -> . WHILE LPAREN bexp RPAREN LCB line RCB
    (60) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (61) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (39) dtype -> . INT
    (40) dtype -> . FLT
    (41) dtype -> . CHR
    (42) dtype -> . BOOL
    (58) fline -> . dtype numexp
    (59) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests
    (20) numexp -> . assign SCOLON
    (56) assign -> . var EQUAL exp
    (57) assign -> . var EQUAL STRING
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 1
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19

state 1

    (0) S' -> line .



state 2

    (1) line -> nline . line
    (2) line -> nline .
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN LCB line RCB
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB
    (15) nline -> . WHILE LPAREN bexp RPAREN LCB line RCB
    (60) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (61) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (39) dtype -> . INT
    (40) dtype -> . FLT
    (41) dtype -> . CHR
    (42) dtype -> . BOOL
    (58) fline -> . dtype numexp
    (59) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests
    (20) numexp -> . assign SCOLON
    (56) assign -> . var EQUAL exp
    (57) assign -> . var EQUAL STRING
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    $end            reduce using rule 2 (line -> nline .)
    RCB             reduce using rule 2 (line -> nline .)
    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    nline                          shift and go to state 2
    line                           shift and go to state 21
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19

state 3

    (3) nline -> dtype . var SCOLON
    (60) nline -> dtype . LBB RBB IDVAR EQUAL arrt SCOLON
    (58) fline -> dtype . numexp
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB
    (20) numexp -> . assign SCOLON
    (56) assign -> . var EQUAL exp
    (57) assign -> . var EQUAL STRING

    LBB             shift and go to state 23
    IDVAR           shift and go to state 7

    var                            shift and go to state 22
    numexp                         shift and go to state 24
    assign                         shift and go to state 14

state 4

    (56) assign -> var . EQUAL exp
    (57) assign -> var . EQUAL STRING

    EQUAL           shift and go to state 25


state 5

    (4) nline -> STR . var SCOLON
    (6) nline -> STR . IDVAR EQUAL strvar SCOLON
    (61) nline -> STR . LBB RBB IDVAR EQUAL arrt SCOLON
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    IDVAR           shift and go to state 27
    LBB             shift and go to state 28

    var                            shift and go to state 26

state 6

    (5) nline -> fline .

    STR             reduce using rule 5 (nline -> fline .)
    BOOL            reduce using rule 5 (nline -> fline .)
    RETURN          reduce using rule 5 (nline -> fline .)
    EXIT            reduce using rule 5 (nline -> fline .)
    PRINT           reduce using rule 5 (nline -> fline .)
    FOR             reduce using rule 5 (nline -> fline .)
    WHILE           reduce using rule 5 (nline -> fline .)
    INT             reduce using rule 5 (nline -> fline .)
    FLT             reduce using rule 5 (nline -> fline .)
    CHR             reduce using rule 5 (nline -> fline .)
    IF              reduce using rule 5 (nline -> fline .)
    IDVAR           reduce using rule 5 (nline -> fline .)
    $end            reduce using rule 5 (nline -> fline .)
    RCB             reduce using rule 5 (nline -> fline .)


state 7

    (36) var -> IDVAR .
    (37) var -> IDVAR . LBB INTEGER RBB
    (38) var -> IDVAR . LBB IDVAR RBB

    EQUAL           reduce using rule 36 (var -> IDVAR .)
    SCOLON          reduce using rule 36 (var -> IDVAR .)
    MUL             reduce using rule 36 (var -> IDVAR .)
    DIV             reduce using rule 36 (var -> IDVAR .)
    MOD             reduce using rule 36 (var -> IDVAR .)
    PLUS            reduce using rule 36 (var -> IDVAR .)
    MINUS           reduce using rule 36 (var -> IDVAR .)
    RPAREN          reduce using rule 36 (var -> IDVAR .)
    DEQUAL          reduce using rule 36 (var -> IDVAR .)
    GTHEN           reduce using rule 36 (var -> IDVAR .)
    LTHEN           reduce using rule 36 (var -> IDVAR .)
    NOT             reduce using rule 36 (var -> IDVAR .)
    AND             reduce using rule 36 (var -> IDVAR .)
    OR              reduce using rule 36 (var -> IDVAR .)
    COM             reduce using rule 36 (var -> IDVAR .)
    RCB             reduce using rule 36 (var -> IDVAR .)
    LBB             shift and go to state 29


state 8

    (7) nline -> BOOL . MAIN LPAREN RPAREN LCB line RCB
    (42) dtype -> BOOL .

    MAIN            shift and go to state 30
    LBB             reduce using rule 42 (dtype -> BOOL .)
    IDVAR           reduce using rule 42 (dtype -> BOOL .)


state 9

    (8) nline -> RETURN . LPAREN bval RPAREN SCOLON

    LPAREN          shift and go to state 31


state 10

    (9) nline -> ifsts .

    STR             reduce using rule 9 (nline -> ifsts .)
    BOOL            reduce using rule 9 (nline -> ifsts .)
    RETURN          reduce using rule 9 (nline -> ifsts .)
    EXIT            reduce using rule 9 (nline -> ifsts .)
    PRINT           reduce using rule 9 (nline -> ifsts .)
    FOR             reduce using rule 9 (nline -> ifsts .)
    WHILE           reduce using rule 9 (nline -> ifsts .)
    INT             reduce using rule 9 (nline -> ifsts .)
    FLT             reduce using rule 9 (nline -> ifsts .)
    CHR             reduce using rule 9 (nline -> ifsts .)
    IF              reduce using rule 9 (nline -> ifsts .)
    IDVAR           reduce using rule 9 (nline -> ifsts .)
    $end            reduce using rule 9 (nline -> ifsts .)
    RCB             reduce using rule 9 (nline -> ifsts .)


state 11

    (10) nline -> EXIT . LPAREN RPAREN SCOLON

    LPAREN          shift and go to state 32


state 12

    (11) nline -> PRINT . LPAREN pline RPAREN SCOLON

    LPAREN          shift and go to state 33


state 13

    (14) nline -> FOR . LPAREN fline bexp SCOLON assign RPAREN LCB line RCB

    LPAREN          shift and go to state 34


state 14

    (20) numexp -> assign . SCOLON

    SCOLON          shift and go to state 35


state 15

    (15) nline -> WHILE . LPAREN bexp RPAREN LCB line RCB

    LPAREN          shift and go to state 36


state 16

    (39) dtype -> INT .

    LBB             reduce using rule 39 (dtype -> INT .)
    IDVAR           reduce using rule 39 (dtype -> INT .)


state 17

    (40) dtype -> FLT .

    LBB             reduce using rule 40 (dtype -> FLT .)
    IDVAR           reduce using rule 40 (dtype -> FLT .)


state 18

    (41) dtype -> CHR .

    LBB             reduce using rule 41 (dtype -> CHR .)
    IDVAR           reduce using rule 41 (dtype -> CHR .)


state 19

    (59) fline -> numexp .

    STR             reduce using rule 59 (fline -> numexp .)
    BOOL            reduce using rule 59 (fline -> numexp .)
    RETURN          reduce using rule 59 (fline -> numexp .)
    EXIT            reduce using rule 59 (fline -> numexp .)
    PRINT           reduce using rule 59 (fline -> numexp .)
    FOR             reduce using rule 59 (fline -> numexp .)
    WHILE           reduce using rule 59 (fline -> numexp .)
    INT             reduce using rule 59 (fline -> numexp .)
    FLT             reduce using rule 59 (fline -> numexp .)
    CHR             reduce using rule 59 (fline -> numexp .)
    IF              reduce using rule 59 (fline -> numexp .)
    IDVAR           reduce using rule 59 (fline -> numexp .)
    $end            reduce using rule 59 (fline -> numexp .)
    RCB             reduce using rule 59 (fline -> numexp .)
    INTEGER         reduce using rule 59 (fline -> numexp .)
    FLOAT           reduce using rule 59 (fline -> numexp .)
    CHAR            reduce using rule 59 (fline -> numexp .)
    TRUE            reduce using rule 59 (fline -> numexp .)
    FALSE           reduce using rule 59 (fline -> numexp .)


state 20

    (16) ifsts -> IF . LPAREN bexp RPAREN LCB line RCB elsests

    LPAREN          shift and go to state 37


state 21

    (1) line -> nline line .

    $end            reduce using rule 1 (line -> nline line .)
    RCB             reduce using rule 1 (line -> nline line .)


state 22

    (3) nline -> dtype var . SCOLON
    (56) assign -> var . EQUAL exp
    (57) assign -> var . EQUAL STRING

    SCOLON          shift and go to state 38
    EQUAL           shift and go to state 25


state 23

    (60) nline -> dtype LBB . RBB IDVAR EQUAL arrt SCOLON

    RBB             shift and go to state 39


state 24

    (58) fline -> dtype numexp .

    STR             reduce using rule 58 (fline -> dtype numexp .)
    BOOL            reduce using rule 58 (fline -> dtype numexp .)
    RETURN          reduce using rule 58 (fline -> dtype numexp .)
    EXIT            reduce using rule 58 (fline -> dtype numexp .)
    PRINT           reduce using rule 58 (fline -> dtype numexp .)
    FOR             reduce using rule 58 (fline -> dtype numexp .)
    WHILE           reduce using rule 58 (fline -> dtype numexp .)
    INT             reduce using rule 58 (fline -> dtype numexp .)
    FLT             reduce using rule 58 (fline -> dtype numexp .)
    CHR             reduce using rule 58 (fline -> dtype numexp .)
    IF              reduce using rule 58 (fline -> dtype numexp .)
    IDVAR           reduce using rule 58 (fline -> dtype numexp .)
    $end            reduce using rule 58 (fline -> dtype numexp .)
    RCB             reduce using rule 58 (fline -> dtype numexp .)
    INTEGER         reduce using rule 58 (fline -> dtype numexp .)
    FLOAT           reduce using rule 58 (fline -> dtype numexp .)
    CHAR            reduce using rule 58 (fline -> dtype numexp .)
    TRUE            reduce using rule 58 (fline -> dtype numexp .)
    FALSE           reduce using rule 58 (fline -> dtype numexp .)


state 25

    (56) assign -> var EQUAL . exp
    (57) assign -> var EQUAL . STRING
    (21) exp -> . exp PLUS term
    (22) exp -> . exp MINUS term
    (23) exp -> . term
    (24) term -> . term MUL fact
    (25) term -> . term DIV fact
    (26) term -> . term MOD fact
    (27) term -> . fact
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . varval
    (31) fact -> . bval
    (32) fact -> . CHAR
    (33) varval -> . var
    (34) bval -> . TRUE
    (35) bval -> . FALSE
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    STRING          shift and go to state 42
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    var                            shift and go to state 40
    exp                            shift and go to state 41
    term                           shift and go to state 43
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48

state 26

    (4) nline -> STR var . SCOLON

    SCOLON          shift and go to state 52


state 27

    (6) nline -> STR IDVAR . EQUAL strvar SCOLON
    (36) var -> IDVAR .
    (37) var -> IDVAR . LBB INTEGER RBB
    (38) var -> IDVAR . LBB IDVAR RBB

    EQUAL           shift and go to state 53
    SCOLON          reduce using rule 36 (var -> IDVAR .)
    LBB             shift and go to state 29


state 28

    (61) nline -> STR LBB . RBB IDVAR EQUAL arrt SCOLON

    RBB             shift and go to state 54


state 29

    (37) var -> IDVAR LBB . INTEGER RBB
    (38) var -> IDVAR LBB . IDVAR RBB

    INTEGER         shift and go to state 56
    IDVAR           shift and go to state 55


state 30

    (7) nline -> BOOL MAIN . LPAREN RPAREN LCB line RCB

    LPAREN          shift and go to state 57


state 31

    (8) nline -> RETURN LPAREN . bval RPAREN SCOLON
    (34) bval -> . TRUE
    (35) bval -> . FALSE

    TRUE            shift and go to state 50
    FALSE           shift and go to state 51

    bval                           shift and go to state 58

state 32

    (10) nline -> EXIT LPAREN . RPAREN SCOLON

    RPAREN          shift and go to state 59


state 33

    (11) nline -> PRINT LPAREN . pline RPAREN SCOLON
    (12) pline -> . exp
    (13) pline -> . STRING
    (21) exp -> . exp PLUS term
    (22) exp -> . exp MINUS term
    (23) exp -> . term
    (24) term -> . term MUL fact
    (25) term -> . term DIV fact
    (26) term -> . term MOD fact
    (27) term -> . fact
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . varval
    (31) fact -> . bval
    (32) fact -> . CHAR
    (33) varval -> . var
    (34) bval -> . TRUE
    (35) bval -> . FALSE
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    STRING          shift and go to state 62
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    pline                          shift and go to state 60
    exp                            shift and go to state 61
    term                           shift and go to state 43
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 34

    (14) nline -> FOR LPAREN . fline bexp SCOLON assign RPAREN LCB line RCB
    (58) fline -> . dtype numexp
    (59) fline -> . numexp
    (39) dtype -> . INT
    (40) dtype -> . FLT
    (41) dtype -> . CHR
    (42) dtype -> . BOOL
    (20) numexp -> . assign SCOLON
    (56) assign -> . var EQUAL exp
    (57) assign -> . var EQUAL STRING
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    BOOL            shift and go to state 65
    IDVAR           shift and go to state 7

    fline                          shift and go to state 63
    assign                         shift and go to state 14
    dtype                          shift and go to state 64
    numexp                         shift and go to state 19
    var                            shift and go to state 4

state 35

    (20) numexp -> assign SCOLON .

    STR             reduce using rule 20 (numexp -> assign SCOLON .)
    BOOL            reduce using rule 20 (numexp -> assign SCOLON .)
    RETURN          reduce using rule 20 (numexp -> assign SCOLON .)
    EXIT            reduce using rule 20 (numexp -> assign SCOLON .)
    PRINT           reduce using rule 20 (numexp -> assign SCOLON .)
    FOR             reduce using rule 20 (numexp -> assign SCOLON .)
    WHILE           reduce using rule 20 (numexp -> assign SCOLON .)
    INT             reduce using rule 20 (numexp -> assign SCOLON .)
    FLT             reduce using rule 20 (numexp -> assign SCOLON .)
    CHR             reduce using rule 20 (numexp -> assign SCOLON .)
    IF              reduce using rule 20 (numexp -> assign SCOLON .)
    IDVAR           reduce using rule 20 (numexp -> assign SCOLON .)
    $end            reduce using rule 20 (numexp -> assign SCOLON .)
    RCB             reduce using rule 20 (numexp -> assign SCOLON .)
    INTEGER         reduce using rule 20 (numexp -> assign SCOLON .)
    FLOAT           reduce using rule 20 (numexp -> assign SCOLON .)
    CHAR            reduce using rule 20 (numexp -> assign SCOLON .)
    TRUE            reduce using rule 20 (numexp -> assign SCOLON .)
    FALSE           reduce using rule 20 (numexp -> assign SCOLON .)


state 36

    (15) nline -> WHILE LPAREN . bexp RPAREN LCB line RCB
    (45) bexp -> . bexp andor bexp2
    (46) bexp -> . bexp2
    (47) bexp2 -> . bexp2 rln exp
    (48) bexp2 -> . exp
    (21) exp -> . exp PLUS term
    (22) exp -> . exp MINUS term
    (23) exp -> . term
    (24) term -> . term MUL fact
    (25) term -> . term DIV fact
    (26) term -> . term MOD fact
    (27) term -> . fact
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . varval
    (31) fact -> . bval
    (32) fact -> . CHAR
    (33) varval -> . var
    (34) bval -> . TRUE
    (35) bval -> . FALSE
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    bexp                           shift and go to state 66
    bexp2                          shift and go to state 67
    exp                            shift and go to state 68
    term                           shift and go to state 43
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 37

    (16) ifsts -> IF LPAREN . bexp RPAREN LCB line RCB elsests
    (45) bexp -> . bexp andor bexp2
    (46) bexp -> . bexp2
    (47) bexp2 -> . bexp2 rln exp
    (48) bexp2 -> . exp
    (21) exp -> . exp PLUS term
    (22) exp -> . exp MINUS term
    (23) exp -> . term
    (24) term -> . term MUL fact
    (25) term -> . term DIV fact
    (26) term -> . term MOD fact
    (27) term -> . fact
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . varval
    (31) fact -> . bval
    (32) fact -> . CHAR
    (33) varval -> . var
    (34) bval -> . TRUE
    (35) bval -> . FALSE
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    bexp                           shift and go to state 69
    bexp2                          shift and go to state 67
    exp                            shift and go to state 68
    term                           shift and go to state 43
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 38

    (3) nline -> dtype var SCOLON .

    STR             reduce using rule 3 (nline -> dtype var SCOLON .)
    BOOL            reduce using rule 3 (nline -> dtype var SCOLON .)
    RETURN          reduce using rule 3 (nline -> dtype var SCOLON .)
    EXIT            reduce using rule 3 (nline -> dtype var SCOLON .)
    PRINT           reduce using rule 3 (nline -> dtype var SCOLON .)
    FOR             reduce using rule 3 (nline -> dtype var SCOLON .)
    WHILE           reduce using rule 3 (nline -> dtype var SCOLON .)
    INT             reduce using rule 3 (nline -> dtype var SCOLON .)
    FLT             reduce using rule 3 (nline -> dtype var SCOLON .)
    CHR             reduce using rule 3 (nline -> dtype var SCOLON .)
    IF              reduce using rule 3 (nline -> dtype var SCOLON .)
    IDVAR           reduce using rule 3 (nline -> dtype var SCOLON .)
    $end            reduce using rule 3 (nline -> dtype var SCOLON .)
    RCB             reduce using rule 3 (nline -> dtype var SCOLON .)


state 39

    (60) nline -> dtype LBB RBB . IDVAR EQUAL arrt SCOLON

    IDVAR           shift and go to state 70


state 40

    (33) varval -> var .

    MUL             reduce using rule 33 (varval -> var .)
    DIV             reduce using rule 33 (varval -> var .)
    MOD             reduce using rule 33 (varval -> var .)
    PLUS            reduce using rule 33 (varval -> var .)
    MINUS           reduce using rule 33 (varval -> var .)
    SCOLON          reduce using rule 33 (varval -> var .)
    RPAREN          reduce using rule 33 (varval -> var .)
    DEQUAL          reduce using rule 33 (varval -> var .)
    GTHEN           reduce using rule 33 (varval -> var .)
    LTHEN           reduce using rule 33 (varval -> var .)
    NOT             reduce using rule 33 (varval -> var .)
    AND             reduce using rule 33 (varval -> var .)
    OR              reduce using rule 33 (varval -> var .)
    COM             reduce using rule 33 (varval -> var .)
    RCB             reduce using rule 33 (varval -> var .)


state 41

    (56) assign -> var EQUAL exp .
    (21) exp -> exp . PLUS term
    (22) exp -> exp . MINUS term

    SCOLON          reduce using rule 56 (assign -> var EQUAL exp .)
    RPAREN          reduce using rule 56 (assign -> var EQUAL exp .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72


state 42

    (57) assign -> var EQUAL STRING .

    SCOLON          reduce using rule 57 (assign -> var EQUAL STRING .)
    RPAREN          reduce using rule 57 (assign -> var EQUAL STRING .)


state 43

    (23) exp -> term .
    (24) term -> term . MUL fact
    (25) term -> term . DIV fact
    (26) term -> term . MOD fact

    PLUS            reduce using rule 23 (exp -> term .)
    MINUS           reduce using rule 23 (exp -> term .)
    SCOLON          reduce using rule 23 (exp -> term .)
    RPAREN          reduce using rule 23 (exp -> term .)
    DEQUAL          reduce using rule 23 (exp -> term .)
    GTHEN           reduce using rule 23 (exp -> term .)
    LTHEN           reduce using rule 23 (exp -> term .)
    NOT             reduce using rule 23 (exp -> term .)
    AND             reduce using rule 23 (exp -> term .)
    OR              reduce using rule 23 (exp -> term .)
    MUL             shift and go to state 73
    DIV             shift and go to state 74
    MOD             shift and go to state 75


state 44

    (27) term -> fact .

    MUL             reduce using rule 27 (term -> fact .)
    DIV             reduce using rule 27 (term -> fact .)
    MOD             reduce using rule 27 (term -> fact .)
    PLUS            reduce using rule 27 (term -> fact .)
    MINUS           reduce using rule 27 (term -> fact .)
    SCOLON          reduce using rule 27 (term -> fact .)
    RPAREN          reduce using rule 27 (term -> fact .)
    DEQUAL          reduce using rule 27 (term -> fact .)
    GTHEN           reduce using rule 27 (term -> fact .)
    LTHEN           reduce using rule 27 (term -> fact .)
    NOT             reduce using rule 27 (term -> fact .)
    AND             reduce using rule 27 (term -> fact .)
    OR              reduce using rule 27 (term -> fact .)


state 45

    (28) fact -> INTEGER .

    MUL             reduce using rule 28 (fact -> INTEGER .)
    DIV             reduce using rule 28 (fact -> INTEGER .)
    MOD             reduce using rule 28 (fact -> INTEGER .)
    PLUS            reduce using rule 28 (fact -> INTEGER .)
    MINUS           reduce using rule 28 (fact -> INTEGER .)
    SCOLON          reduce using rule 28 (fact -> INTEGER .)
    RPAREN          reduce using rule 28 (fact -> INTEGER .)
    DEQUAL          reduce using rule 28 (fact -> INTEGER .)
    GTHEN           reduce using rule 28 (fact -> INTEGER .)
    LTHEN           reduce using rule 28 (fact -> INTEGER .)
    NOT             reduce using rule 28 (fact -> INTEGER .)
    AND             reduce using rule 28 (fact -> INTEGER .)
    OR              reduce using rule 28 (fact -> INTEGER .)
    COM             reduce using rule 28 (fact -> INTEGER .)
    RCB             reduce using rule 28 (fact -> INTEGER .)


state 46

    (29) fact -> FLOAT .

    MUL             reduce using rule 29 (fact -> FLOAT .)
    DIV             reduce using rule 29 (fact -> FLOAT .)
    MOD             reduce using rule 29 (fact -> FLOAT .)
    PLUS            reduce using rule 29 (fact -> FLOAT .)
    MINUS           reduce using rule 29 (fact -> FLOAT .)
    SCOLON          reduce using rule 29 (fact -> FLOAT .)
    RPAREN          reduce using rule 29 (fact -> FLOAT .)
    DEQUAL          reduce using rule 29 (fact -> FLOAT .)
    GTHEN           reduce using rule 29 (fact -> FLOAT .)
    LTHEN           reduce using rule 29 (fact -> FLOAT .)
    NOT             reduce using rule 29 (fact -> FLOAT .)
    AND             reduce using rule 29 (fact -> FLOAT .)
    OR              reduce using rule 29 (fact -> FLOAT .)
    COM             reduce using rule 29 (fact -> FLOAT .)
    RCB             reduce using rule 29 (fact -> FLOAT .)


state 47

    (30) fact -> varval .

    MUL             reduce using rule 30 (fact -> varval .)
    DIV             reduce using rule 30 (fact -> varval .)
    MOD             reduce using rule 30 (fact -> varval .)
    PLUS            reduce using rule 30 (fact -> varval .)
    MINUS           reduce using rule 30 (fact -> varval .)
    SCOLON          reduce using rule 30 (fact -> varval .)
    RPAREN          reduce using rule 30 (fact -> varval .)
    DEQUAL          reduce using rule 30 (fact -> varval .)
    GTHEN           reduce using rule 30 (fact -> varval .)
    LTHEN           reduce using rule 30 (fact -> varval .)
    NOT             reduce using rule 30 (fact -> varval .)
    AND             reduce using rule 30 (fact -> varval .)
    OR              reduce using rule 30 (fact -> varval .)
    COM             reduce using rule 30 (fact -> varval .)
    RCB             reduce using rule 30 (fact -> varval .)


state 48

    (31) fact -> bval .

    MUL             reduce using rule 31 (fact -> bval .)
    DIV             reduce using rule 31 (fact -> bval .)
    MOD             reduce using rule 31 (fact -> bval .)
    PLUS            reduce using rule 31 (fact -> bval .)
    MINUS           reduce using rule 31 (fact -> bval .)
    SCOLON          reduce using rule 31 (fact -> bval .)
    RPAREN          reduce using rule 31 (fact -> bval .)
    DEQUAL          reduce using rule 31 (fact -> bval .)
    GTHEN           reduce using rule 31 (fact -> bval .)
    LTHEN           reduce using rule 31 (fact -> bval .)
    NOT             reduce using rule 31 (fact -> bval .)
    AND             reduce using rule 31 (fact -> bval .)
    OR              reduce using rule 31 (fact -> bval .)
    COM             reduce using rule 31 (fact -> bval .)
    RCB             reduce using rule 31 (fact -> bval .)


state 49

    (32) fact -> CHAR .

    MUL             reduce using rule 32 (fact -> CHAR .)
    DIV             reduce using rule 32 (fact -> CHAR .)
    MOD             reduce using rule 32 (fact -> CHAR .)
    PLUS            reduce using rule 32 (fact -> CHAR .)
    MINUS           reduce using rule 32 (fact -> CHAR .)
    SCOLON          reduce using rule 32 (fact -> CHAR .)
    RPAREN          reduce using rule 32 (fact -> CHAR .)
    DEQUAL          reduce using rule 32 (fact -> CHAR .)
    GTHEN           reduce using rule 32 (fact -> CHAR .)
    LTHEN           reduce using rule 32 (fact -> CHAR .)
    NOT             reduce using rule 32 (fact -> CHAR .)
    AND             reduce using rule 32 (fact -> CHAR .)
    OR              reduce using rule 32 (fact -> CHAR .)
    COM             reduce using rule 32 (fact -> CHAR .)
    RCB             reduce using rule 32 (fact -> CHAR .)


state 50

    (34) bval -> TRUE .

    MUL             reduce using rule 34 (bval -> TRUE .)
    DIV             reduce using rule 34 (bval -> TRUE .)
    MOD             reduce using rule 34 (bval -> TRUE .)
    PLUS            reduce using rule 34 (bval -> TRUE .)
    MINUS           reduce using rule 34 (bval -> TRUE .)
    SCOLON          reduce using rule 34 (bval -> TRUE .)
    RPAREN          reduce using rule 34 (bval -> TRUE .)
    DEQUAL          reduce using rule 34 (bval -> TRUE .)
    GTHEN           reduce using rule 34 (bval -> TRUE .)
    LTHEN           reduce using rule 34 (bval -> TRUE .)
    NOT             reduce using rule 34 (bval -> TRUE .)
    AND             reduce using rule 34 (bval -> TRUE .)
    OR              reduce using rule 34 (bval -> TRUE .)
    COM             reduce using rule 34 (bval -> TRUE .)
    RCB             reduce using rule 34 (bval -> TRUE .)


state 51

    (35) bval -> FALSE .

    MUL             reduce using rule 35 (bval -> FALSE .)
    DIV             reduce using rule 35 (bval -> FALSE .)
    MOD             reduce using rule 35 (bval -> FALSE .)
    PLUS            reduce using rule 35 (bval -> FALSE .)
    MINUS           reduce using rule 35 (bval -> FALSE .)
    SCOLON          reduce using rule 35 (bval -> FALSE .)
    RPAREN          reduce using rule 35 (bval -> FALSE .)
    DEQUAL          reduce using rule 35 (bval -> FALSE .)
    GTHEN           reduce using rule 35 (bval -> FALSE .)
    LTHEN           reduce using rule 35 (bval -> FALSE .)
    NOT             reduce using rule 35 (bval -> FALSE .)
    AND             reduce using rule 35 (bval -> FALSE .)
    OR              reduce using rule 35 (bval -> FALSE .)
    COM             reduce using rule 35 (bval -> FALSE .)
    RCB             reduce using rule 35 (bval -> FALSE .)


state 52

    (4) nline -> STR var SCOLON .

    STR             reduce using rule 4 (nline -> STR var SCOLON .)
    BOOL            reduce using rule 4 (nline -> STR var SCOLON .)
    RETURN          reduce using rule 4 (nline -> STR var SCOLON .)
    EXIT            reduce using rule 4 (nline -> STR var SCOLON .)
    PRINT           reduce using rule 4 (nline -> STR var SCOLON .)
    FOR             reduce using rule 4 (nline -> STR var SCOLON .)
    WHILE           reduce using rule 4 (nline -> STR var SCOLON .)
    INT             reduce using rule 4 (nline -> STR var SCOLON .)
    FLT             reduce using rule 4 (nline -> STR var SCOLON .)
    CHR             reduce using rule 4 (nline -> STR var SCOLON .)
    IF              reduce using rule 4 (nline -> STR var SCOLON .)
    IDVAR           reduce using rule 4 (nline -> STR var SCOLON .)
    $end            reduce using rule 4 (nline -> STR var SCOLON .)
    RCB             reduce using rule 4 (nline -> STR var SCOLON .)


state 53

    (6) nline -> STR IDVAR EQUAL . strvar SCOLON
    (43) strvar -> . STRING
    (44) strvar -> . varval
    (33) varval -> . var
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    STRING          shift and go to state 77
    IDVAR           shift and go to state 7

    strvar                         shift and go to state 76
    varval                         shift and go to state 78
    var                            shift and go to state 40

state 54

    (61) nline -> STR LBB RBB . IDVAR EQUAL arrt SCOLON

    IDVAR           shift and go to state 79


state 55

    (38) var -> IDVAR LBB IDVAR . RBB

    RBB             shift and go to state 80


state 56

    (37) var -> IDVAR LBB INTEGER . RBB

    RBB             shift and go to state 81


state 57

    (7) nline -> BOOL MAIN LPAREN . RPAREN LCB line RCB

    RPAREN          shift and go to state 82


state 58

    (8) nline -> RETURN LPAREN bval . RPAREN SCOLON

    RPAREN          shift and go to state 83


state 59

    (10) nline -> EXIT LPAREN RPAREN . SCOLON

    SCOLON          shift and go to state 84


state 60

    (11) nline -> PRINT LPAREN pline . RPAREN SCOLON

    RPAREN          shift and go to state 85


state 61

    (12) pline -> exp .
    (21) exp -> exp . PLUS term
    (22) exp -> exp . MINUS term

    RPAREN          reduce using rule 12 (pline -> exp .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72


state 62

    (13) pline -> STRING .

    RPAREN          reduce using rule 13 (pline -> STRING .)


state 63

    (14) nline -> FOR LPAREN fline . bexp SCOLON assign RPAREN LCB line RCB
    (45) bexp -> . bexp andor bexp2
    (46) bexp -> . bexp2
    (47) bexp2 -> . bexp2 rln exp
    (48) bexp2 -> . exp
    (21) exp -> . exp PLUS term
    (22) exp -> . exp MINUS term
    (23) exp -> . term
    (24) term -> . term MUL fact
    (25) term -> . term DIV fact
    (26) term -> . term MOD fact
    (27) term -> . fact
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . varval
    (31) fact -> . bval
    (32) fact -> . CHAR
    (33) varval -> . var
    (34) bval -> . TRUE
    (35) bval -> . FALSE
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    bexp                           shift and go to state 86
    bexp2                          shift and go to state 67
    exp                            shift and go to state 68
    term                           shift and go to state 43
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 64

    (58) fline -> dtype . numexp
    (20) numexp -> . assign SCOLON
    (56) assign -> . var EQUAL exp
    (57) assign -> . var EQUAL STRING
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    IDVAR           shift and go to state 7

    numexp                         shift and go to state 24
    assign                         shift and go to state 14
    var                            shift and go to state 4

state 65

    (42) dtype -> BOOL .

    IDVAR           reduce using rule 42 (dtype -> BOOL .)


state 66

    (15) nline -> WHILE LPAREN bexp . RPAREN LCB line RCB
    (45) bexp -> bexp . andor bexp2
    (53) andor -> . AND
    (54) andor -> . OR

    RPAREN          shift and go to state 87
    AND             shift and go to state 89
    OR              shift and go to state 90

    andor                          shift and go to state 88

state 67

    (46) bexp -> bexp2 .
    (47) bexp2 -> bexp2 . rln exp
    (49) rln -> . DEQUAL
    (50) rln -> . GTHEN
    (51) rln -> . LTHEN
    (52) rln -> . NOT

    RPAREN          reduce using rule 46 (bexp -> bexp2 .)
    AND             reduce using rule 46 (bexp -> bexp2 .)
    OR              reduce using rule 46 (bexp -> bexp2 .)
    SCOLON          reduce using rule 46 (bexp -> bexp2 .)
    DEQUAL          shift and go to state 92
    GTHEN           shift and go to state 93
    LTHEN           shift and go to state 94
    NOT             shift and go to state 95

    rln                            shift and go to state 91

state 68

    (48) bexp2 -> exp .
    (21) exp -> exp . PLUS term
    (22) exp -> exp . MINUS term

    DEQUAL          reduce using rule 48 (bexp2 -> exp .)
    GTHEN           reduce using rule 48 (bexp2 -> exp .)
    LTHEN           reduce using rule 48 (bexp2 -> exp .)
    NOT             reduce using rule 48 (bexp2 -> exp .)
    RPAREN          reduce using rule 48 (bexp2 -> exp .)
    AND             reduce using rule 48 (bexp2 -> exp .)
    OR              reduce using rule 48 (bexp2 -> exp .)
    SCOLON          reduce using rule 48 (bexp2 -> exp .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72


state 69

    (16) ifsts -> IF LPAREN bexp . RPAREN LCB line RCB elsests
    (45) bexp -> bexp . andor bexp2
    (53) andor -> . AND
    (54) andor -> . OR

    RPAREN          shift and go to state 96
    AND             shift and go to state 89
    OR              shift and go to state 90

    andor                          shift and go to state 88

state 70

    (60) nline -> dtype LBB RBB IDVAR . EQUAL arrt SCOLON

    EQUAL           shift and go to state 97


state 71

    (21) exp -> exp PLUS . term
    (24) term -> . term MUL fact
    (25) term -> . term DIV fact
    (26) term -> . term MOD fact
    (27) term -> . fact
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . varval
    (31) fact -> . bval
    (32) fact -> . CHAR
    (33) varval -> . var
    (34) bval -> . TRUE
    (35) bval -> . FALSE
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    term                           shift and go to state 98
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 72

    (22) exp -> exp MINUS . term
    (24) term -> . term MUL fact
    (25) term -> . term DIV fact
    (26) term -> . term MOD fact
    (27) term -> . fact
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . varval
    (31) fact -> . bval
    (32) fact -> . CHAR
    (33) varval -> . var
    (34) bval -> . TRUE
    (35) bval -> . FALSE
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    term                           shift and go to state 99
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 73

    (24) term -> term MUL . fact
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . varval
    (31) fact -> . bval
    (32) fact -> . CHAR
    (33) varval -> . var
    (34) bval -> . TRUE
    (35) bval -> . FALSE
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    fact                           shift and go to state 100
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 74

    (25) term -> term DIV . fact
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . varval
    (31) fact -> . bval
    (32) fact -> . CHAR
    (33) varval -> . var
    (34) bval -> . TRUE
    (35) bval -> . FALSE
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    fact                           shift and go to state 101
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 75

    (26) term -> term MOD . fact
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . varval
    (31) fact -> . bval
    (32) fact -> . CHAR
    (33) varval -> . var
    (34) bval -> . TRUE
    (35) bval -> . FALSE
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    fact                           shift and go to state 102
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 76

    (6) nline -> STR IDVAR EQUAL strvar . SCOLON

    SCOLON          shift and go to state 103


state 77

    (43) strvar -> STRING .

    SCOLON          reduce using rule 43 (strvar -> STRING .)


state 78

    (44) strvar -> varval .

    SCOLON          reduce using rule 44 (strvar -> varval .)


state 79

    (61) nline -> STR LBB RBB IDVAR . EQUAL arrt SCOLON

    EQUAL           shift and go to state 104


state 80

    (38) var -> IDVAR LBB IDVAR RBB .

    EQUAL           reduce using rule 38 (var -> IDVAR LBB IDVAR RBB .)
    SCOLON          reduce using rule 38 (var -> IDVAR LBB IDVAR RBB .)
    MUL             reduce using rule 38 (var -> IDVAR LBB IDVAR RBB .)
    DIV             reduce using rule 38 (var -> IDVAR LBB IDVAR RBB .)
    MOD             reduce using rule 38 (var -> IDVAR LBB IDVAR RBB .)
    PLUS            reduce using rule 38 (var -> IDVAR LBB IDVAR RBB .)
    MINUS           reduce using rule 38 (var -> IDVAR LBB IDVAR RBB .)
    RPAREN          reduce using rule 38 (var -> IDVAR LBB IDVAR RBB .)
    DEQUAL          reduce using rule 38 (var -> IDVAR LBB IDVAR RBB .)
    GTHEN           reduce using rule 38 (var -> IDVAR LBB IDVAR RBB .)
    LTHEN           reduce using rule 38 (var -> IDVAR LBB IDVAR RBB .)
    NOT             reduce using rule 38 (var -> IDVAR LBB IDVAR RBB .)
    AND             reduce using rule 38 (var -> IDVAR LBB IDVAR RBB .)
    OR              reduce using rule 38 (var -> IDVAR LBB IDVAR RBB .)
    COM             reduce using rule 38 (var -> IDVAR LBB IDVAR RBB .)
    RCB             reduce using rule 38 (var -> IDVAR LBB IDVAR RBB .)


state 81

    (37) var -> IDVAR LBB INTEGER RBB .

    EQUAL           reduce using rule 37 (var -> IDVAR LBB INTEGER RBB .)
    SCOLON          reduce using rule 37 (var -> IDVAR LBB INTEGER RBB .)
    MUL             reduce using rule 37 (var -> IDVAR LBB INTEGER RBB .)
    DIV             reduce using rule 37 (var -> IDVAR LBB INTEGER RBB .)
    MOD             reduce using rule 37 (var -> IDVAR LBB INTEGER RBB .)
    PLUS            reduce using rule 37 (var -> IDVAR LBB INTEGER RBB .)
    MINUS           reduce using rule 37 (var -> IDVAR LBB INTEGER RBB .)
    RPAREN          reduce using rule 37 (var -> IDVAR LBB INTEGER RBB .)
    DEQUAL          reduce using rule 37 (var -> IDVAR LBB INTEGER RBB .)
    GTHEN           reduce using rule 37 (var -> IDVAR LBB INTEGER RBB .)
    LTHEN           reduce using rule 37 (var -> IDVAR LBB INTEGER RBB .)
    NOT             reduce using rule 37 (var -> IDVAR LBB INTEGER RBB .)
    AND             reduce using rule 37 (var -> IDVAR LBB INTEGER RBB .)
    OR              reduce using rule 37 (var -> IDVAR LBB INTEGER RBB .)
    COM             reduce using rule 37 (var -> IDVAR LBB INTEGER RBB .)
    RCB             reduce using rule 37 (var -> IDVAR LBB INTEGER RBB .)


state 82

    (7) nline -> BOOL MAIN LPAREN RPAREN . LCB line RCB

    LCB             shift and go to state 105


state 83

    (8) nline -> RETURN LPAREN bval RPAREN . SCOLON

    SCOLON          shift and go to state 106


state 84

    (10) nline -> EXIT LPAREN RPAREN SCOLON .

    STR             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    BOOL            reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    RETURN          reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    EXIT            reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    PRINT           reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    FOR             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    WHILE           reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    INT             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    FLT             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    CHR             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    IF              reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    IDVAR           reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    $end            reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    RCB             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)


state 85

    (11) nline -> PRINT LPAREN pline RPAREN . SCOLON

    SCOLON          shift and go to state 107


state 86

    (14) nline -> FOR LPAREN fline bexp . SCOLON assign RPAREN LCB line RCB
    (45) bexp -> bexp . andor bexp2
    (53) andor -> . AND
    (54) andor -> . OR

    SCOLON          shift and go to state 108
    AND             shift and go to state 89
    OR              shift and go to state 90

    andor                          shift and go to state 88

state 87

    (15) nline -> WHILE LPAREN bexp RPAREN . LCB line RCB

    LCB             shift and go to state 109


state 88

    (45) bexp -> bexp andor . bexp2
    (47) bexp2 -> . bexp2 rln exp
    (48) bexp2 -> . exp
    (21) exp -> . exp PLUS term
    (22) exp -> . exp MINUS term
    (23) exp -> . term
    (24) term -> . term MUL fact
    (25) term -> . term DIV fact
    (26) term -> . term MOD fact
    (27) term -> . fact
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . varval
    (31) fact -> . bval
    (32) fact -> . CHAR
    (33) varval -> . var
    (34) bval -> . TRUE
    (35) bval -> . FALSE
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    bexp2                          shift and go to state 110
    exp                            shift and go to state 68
    term                           shift and go to state 43
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 89

    (53) andor -> AND .

    INTEGER         reduce using rule 53 (andor -> AND .)
    FLOAT           reduce using rule 53 (andor -> AND .)
    CHAR            reduce using rule 53 (andor -> AND .)
    TRUE            reduce using rule 53 (andor -> AND .)
    FALSE           reduce using rule 53 (andor -> AND .)
    IDVAR           reduce using rule 53 (andor -> AND .)


state 90

    (54) andor -> OR .

    INTEGER         reduce using rule 54 (andor -> OR .)
    FLOAT           reduce using rule 54 (andor -> OR .)
    CHAR            reduce using rule 54 (andor -> OR .)
    TRUE            reduce using rule 54 (andor -> OR .)
    FALSE           reduce using rule 54 (andor -> OR .)
    IDVAR           reduce using rule 54 (andor -> OR .)


state 91

    (47) bexp2 -> bexp2 rln . exp
    (21) exp -> . exp PLUS term
    (22) exp -> . exp MINUS term
    (23) exp -> . term
    (24) term -> . term MUL fact
    (25) term -> . term DIV fact
    (26) term -> . term MOD fact
    (27) term -> . fact
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . varval
    (31) fact -> . bval
    (32) fact -> . CHAR
    (33) varval -> . var
    (34) bval -> . TRUE
    (35) bval -> . FALSE
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    exp                            shift and go to state 111
    term                           shift and go to state 43
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 92

    (49) rln -> DEQUAL .

    INTEGER         reduce using rule 49 (rln -> DEQUAL .)
    FLOAT           reduce using rule 49 (rln -> DEQUAL .)
    CHAR            reduce using rule 49 (rln -> DEQUAL .)
    TRUE            reduce using rule 49 (rln -> DEQUAL .)
    FALSE           reduce using rule 49 (rln -> DEQUAL .)
    IDVAR           reduce using rule 49 (rln -> DEQUAL .)


state 93

    (50) rln -> GTHEN .

    INTEGER         reduce using rule 50 (rln -> GTHEN .)
    FLOAT           reduce using rule 50 (rln -> GTHEN .)
    CHAR            reduce using rule 50 (rln -> GTHEN .)
    TRUE            reduce using rule 50 (rln -> GTHEN .)
    FALSE           reduce using rule 50 (rln -> GTHEN .)
    IDVAR           reduce using rule 50 (rln -> GTHEN .)


state 94

    (51) rln -> LTHEN .

    INTEGER         reduce using rule 51 (rln -> LTHEN .)
    FLOAT           reduce using rule 51 (rln -> LTHEN .)
    CHAR            reduce using rule 51 (rln -> LTHEN .)
    TRUE            reduce using rule 51 (rln -> LTHEN .)
    FALSE           reduce using rule 51 (rln -> LTHEN .)
    IDVAR           reduce using rule 51 (rln -> LTHEN .)


state 95

    (52) rln -> NOT .

    INTEGER         reduce using rule 52 (rln -> NOT .)
    FLOAT           reduce using rule 52 (rln -> NOT .)
    CHAR            reduce using rule 52 (rln -> NOT .)
    TRUE            reduce using rule 52 (rln -> NOT .)
    FALSE           reduce using rule 52 (rln -> NOT .)
    IDVAR           reduce using rule 52 (rln -> NOT .)


state 96

    (16) ifsts -> IF LPAREN bexp RPAREN . LCB line RCB elsests

    LCB             shift and go to state 112


state 97

    (60) nline -> dtype LBB RBB IDVAR EQUAL . arrt SCOLON
    (62) arrt -> . var
    (63) arrt -> . LCB dws RCB
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    LCB             shift and go to state 115
    IDVAR           shift and go to state 7

    arrt                           shift and go to state 113
    var                            shift and go to state 114

state 98

    (21) exp -> exp PLUS term .
    (24) term -> term . MUL fact
    (25) term -> term . DIV fact
    (26) term -> term . MOD fact

    PLUS            reduce using rule 21 (exp -> exp PLUS term .)
    MINUS           reduce using rule 21 (exp -> exp PLUS term .)
    SCOLON          reduce using rule 21 (exp -> exp PLUS term .)
    RPAREN          reduce using rule 21 (exp -> exp PLUS term .)
    DEQUAL          reduce using rule 21 (exp -> exp PLUS term .)
    GTHEN           reduce using rule 21 (exp -> exp PLUS term .)
    LTHEN           reduce using rule 21 (exp -> exp PLUS term .)
    NOT             reduce using rule 21 (exp -> exp PLUS term .)
    AND             reduce using rule 21 (exp -> exp PLUS term .)
    OR              reduce using rule 21 (exp -> exp PLUS term .)
    MUL             shift and go to state 73
    DIV             shift and go to state 74
    MOD             shift and go to state 75


state 99

    (22) exp -> exp MINUS term .
    (24) term -> term . MUL fact
    (25) term -> term . DIV fact
    (26) term -> term . MOD fact

    PLUS            reduce using rule 22 (exp -> exp MINUS term .)
    MINUS           reduce using rule 22 (exp -> exp MINUS term .)
    SCOLON          reduce using rule 22 (exp -> exp MINUS term .)
    RPAREN          reduce using rule 22 (exp -> exp MINUS term .)
    DEQUAL          reduce using rule 22 (exp -> exp MINUS term .)
    GTHEN           reduce using rule 22 (exp -> exp MINUS term .)
    LTHEN           reduce using rule 22 (exp -> exp MINUS term .)
    NOT             reduce using rule 22 (exp -> exp MINUS term .)
    AND             reduce using rule 22 (exp -> exp MINUS term .)
    OR              reduce using rule 22 (exp -> exp MINUS term .)
    MUL             shift and go to state 73
    DIV             shift and go to state 74
    MOD             shift and go to state 75


state 100

    (24) term -> term MUL fact .

    MUL             reduce using rule 24 (term -> term MUL fact .)
    DIV             reduce using rule 24 (term -> term MUL fact .)
    MOD             reduce using rule 24 (term -> term MUL fact .)
    PLUS            reduce using rule 24 (term -> term MUL fact .)
    MINUS           reduce using rule 24 (term -> term MUL fact .)
    SCOLON          reduce using rule 24 (term -> term MUL fact .)
    RPAREN          reduce using rule 24 (term -> term MUL fact .)
    DEQUAL          reduce using rule 24 (term -> term MUL fact .)
    GTHEN           reduce using rule 24 (term -> term MUL fact .)
    LTHEN           reduce using rule 24 (term -> term MUL fact .)
    NOT             reduce using rule 24 (term -> term MUL fact .)
    AND             reduce using rule 24 (term -> term MUL fact .)
    OR              reduce using rule 24 (term -> term MUL fact .)


state 101

    (25) term -> term DIV fact .

    MUL             reduce using rule 25 (term -> term DIV fact .)
    DIV             reduce using rule 25 (term -> term DIV fact .)
    MOD             reduce using rule 25 (term -> term DIV fact .)
    PLUS            reduce using rule 25 (term -> term DIV fact .)
    MINUS           reduce using rule 25 (term -> term DIV fact .)
    SCOLON          reduce using rule 25 (term -> term DIV fact .)
    RPAREN          reduce using rule 25 (term -> term DIV fact .)
    DEQUAL          reduce using rule 25 (term -> term DIV fact .)
    GTHEN           reduce using rule 25 (term -> term DIV fact .)
    LTHEN           reduce using rule 25 (term -> term DIV fact .)
    NOT             reduce using rule 25 (term -> term DIV fact .)
    AND             reduce using rule 25 (term -> term DIV fact .)
    OR              reduce using rule 25 (term -> term DIV fact .)


state 102

    (26) term -> term MOD fact .

    MUL             reduce using rule 26 (term -> term MOD fact .)
    DIV             reduce using rule 26 (term -> term MOD fact .)
    MOD             reduce using rule 26 (term -> term MOD fact .)
    PLUS            reduce using rule 26 (term -> term MOD fact .)
    MINUS           reduce using rule 26 (term -> term MOD fact .)
    SCOLON          reduce using rule 26 (term -> term MOD fact .)
    RPAREN          reduce using rule 26 (term -> term MOD fact .)
    DEQUAL          reduce using rule 26 (term -> term MOD fact .)
    GTHEN           reduce using rule 26 (term -> term MOD fact .)
    LTHEN           reduce using rule 26 (term -> term MOD fact .)
    NOT             reduce using rule 26 (term -> term MOD fact .)
    AND             reduce using rule 26 (term -> term MOD fact .)
    OR              reduce using rule 26 (term -> term MOD fact .)


state 103

    (6) nline -> STR IDVAR EQUAL strvar SCOLON .

    STR             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    BOOL            reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    RETURN          reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    EXIT            reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    PRINT           reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    FOR             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    WHILE           reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    INT             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    FLT             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    CHR             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    IF              reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    IDVAR           reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    $end            reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    RCB             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)


state 104

    (61) nline -> STR LBB RBB IDVAR EQUAL . arrt SCOLON
    (62) arrt -> . var
    (63) arrt -> . LCB dws RCB
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    LCB             shift and go to state 115
    IDVAR           shift and go to state 7

    arrt                           shift and go to state 116
    var                            shift and go to state 114

state 105

    (7) nline -> BOOL MAIN LPAREN RPAREN LCB . line RCB
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN LCB line RCB
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB
    (15) nline -> . WHILE LPAREN bexp RPAREN LCB line RCB
    (60) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (61) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (39) dtype -> . INT
    (40) dtype -> . FLT
    (41) dtype -> . CHR
    (42) dtype -> . BOOL
    (58) fline -> . dtype numexp
    (59) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests
    (20) numexp -> . assign SCOLON
    (56) assign -> . var EQUAL exp
    (57) assign -> . var EQUAL STRING
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 117
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19

state 106

    (8) nline -> RETURN LPAREN bval RPAREN SCOLON .

    STR             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    BOOL            reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    RETURN          reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    EXIT            reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    PRINT           reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    FOR             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    WHILE           reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    INT             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    FLT             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    CHR             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    IF              reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    IDVAR           reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    $end            reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    RCB             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)


state 107

    (11) nline -> PRINT LPAREN pline RPAREN SCOLON .

    STR             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    BOOL            reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    RETURN          reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    EXIT            reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    PRINT           reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    FOR             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    WHILE           reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    INT             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    FLT             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    CHR             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    IF              reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    IDVAR           reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    $end            reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    RCB             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)


state 108

    (14) nline -> FOR LPAREN fline bexp SCOLON . assign RPAREN LCB line RCB
    (56) assign -> . var EQUAL exp
    (57) assign -> . var EQUAL STRING
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    IDVAR           shift and go to state 7

    assign                         shift and go to state 118
    var                            shift and go to state 4

state 109

    (15) nline -> WHILE LPAREN bexp RPAREN LCB . line RCB
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN LCB line RCB
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB
    (15) nline -> . WHILE LPAREN bexp RPAREN LCB line RCB
    (60) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (61) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (39) dtype -> . INT
    (40) dtype -> . FLT
    (41) dtype -> . CHR
    (42) dtype -> . BOOL
    (58) fline -> . dtype numexp
    (59) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests
    (20) numexp -> . assign SCOLON
    (56) assign -> . var EQUAL exp
    (57) assign -> . var EQUAL STRING
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 119
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19

state 110

    (45) bexp -> bexp andor bexp2 .
    (47) bexp2 -> bexp2 . rln exp
    (49) rln -> . DEQUAL
    (50) rln -> . GTHEN
    (51) rln -> . LTHEN
    (52) rln -> . NOT

    RPAREN          reduce using rule 45 (bexp -> bexp andor bexp2 .)
    AND             reduce using rule 45 (bexp -> bexp andor bexp2 .)
    OR              reduce using rule 45 (bexp -> bexp andor bexp2 .)
    SCOLON          reduce using rule 45 (bexp -> bexp andor bexp2 .)
    DEQUAL          shift and go to state 92
    GTHEN           shift and go to state 93
    LTHEN           shift and go to state 94
    NOT             shift and go to state 95

    rln                            shift and go to state 91

state 111

    (47) bexp2 -> bexp2 rln exp .
    (21) exp -> exp . PLUS term
    (22) exp -> exp . MINUS term

    DEQUAL          reduce using rule 47 (bexp2 -> bexp2 rln exp .)
    GTHEN           reduce using rule 47 (bexp2 -> bexp2 rln exp .)
    LTHEN           reduce using rule 47 (bexp2 -> bexp2 rln exp .)
    NOT             reduce using rule 47 (bexp2 -> bexp2 rln exp .)
    RPAREN          reduce using rule 47 (bexp2 -> bexp2 rln exp .)
    AND             reduce using rule 47 (bexp2 -> bexp2 rln exp .)
    OR              reduce using rule 47 (bexp2 -> bexp2 rln exp .)
    SCOLON          reduce using rule 47 (bexp2 -> bexp2 rln exp .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72


state 112

    (16) ifsts -> IF LPAREN bexp RPAREN LCB . line RCB elsests
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN LCB line RCB
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB
    (15) nline -> . WHILE LPAREN bexp RPAREN LCB line RCB
    (60) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (61) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (39) dtype -> . INT
    (40) dtype -> . FLT
    (41) dtype -> . CHR
    (42) dtype -> . BOOL
    (58) fline -> . dtype numexp
    (59) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests
    (20) numexp -> . assign SCOLON
    (56) assign -> . var EQUAL exp
    (57) assign -> . var EQUAL STRING
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 120
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19

state 113

    (60) nline -> dtype LBB RBB IDVAR EQUAL arrt . SCOLON

    SCOLON          shift and go to state 121


state 114

    (62) arrt -> var .

    SCOLON          reduce using rule 62 (arrt -> var .)


state 115

    (63) arrt -> LCB . dws RCB
    (64) dws -> . factarr COM dws
    (65) dws -> . factarr
    (66) factarr -> . fact
    (67) factarr -> . STRING
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . varval
    (31) fact -> . bval
    (32) fact -> . CHAR
    (33) varval -> . var
    (34) bval -> . TRUE
    (35) bval -> . FALSE
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    STRING          shift and go to state 125
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    dws                            shift and go to state 122
    factarr                        shift and go to state 123
    fact                           shift and go to state 124
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 116

    (61) nline -> STR LBB RBB IDVAR EQUAL arrt . SCOLON

    SCOLON          shift and go to state 126


state 117

    (7) nline -> BOOL MAIN LPAREN RPAREN LCB line . RCB

    RCB             shift and go to state 127


state 118

    (14) nline -> FOR LPAREN fline bexp SCOLON assign . RPAREN LCB line RCB

    RPAREN          shift and go to state 128


state 119

    (15) nline -> WHILE LPAREN bexp RPAREN LCB line . RCB

    RCB             shift and go to state 129


state 120

    (16) ifsts -> IF LPAREN bexp RPAREN LCB line . RCB elsests

    RCB             shift and go to state 130


state 121

    (60) nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .

    STR             reduce using rule 60 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    BOOL            reduce using rule 60 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    RETURN          reduce using rule 60 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    EXIT            reduce using rule 60 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    PRINT           reduce using rule 60 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    FOR             reduce using rule 60 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    WHILE           reduce using rule 60 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    INT             reduce using rule 60 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    FLT             reduce using rule 60 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    CHR             reduce using rule 60 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    IF              reduce using rule 60 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    IDVAR           reduce using rule 60 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    $end            reduce using rule 60 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    RCB             reduce using rule 60 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)


state 122

    (63) arrt -> LCB dws . RCB

    RCB             shift and go to state 131


state 123

    (64) dws -> factarr . COM dws
    (65) dws -> factarr .

    COM             shift and go to state 132
    RCB             reduce using rule 65 (dws -> factarr .)


state 124

    (66) factarr -> fact .

    COM             reduce using rule 66 (factarr -> fact .)
    RCB             reduce using rule 66 (factarr -> fact .)


state 125

    (67) factarr -> STRING .

    COM             reduce using rule 67 (factarr -> STRING .)
    RCB             reduce using rule 67 (factarr -> STRING .)


state 126

    (61) nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .

    STR             reduce using rule 61 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    BOOL            reduce using rule 61 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    RETURN          reduce using rule 61 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    EXIT            reduce using rule 61 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    PRINT           reduce using rule 61 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    FOR             reduce using rule 61 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    WHILE           reduce using rule 61 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    INT             reduce using rule 61 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    FLT             reduce using rule 61 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    CHR             reduce using rule 61 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    IF              reduce using rule 61 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    IDVAR           reduce using rule 61 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    $end            reduce using rule 61 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    RCB             reduce using rule 61 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)


state 127

    (7) nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .

    STR             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    BOOL            reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    RETURN          reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    EXIT            reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    PRINT           reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    FOR             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    WHILE           reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    INT             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    FLT             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    CHR             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    IF              reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    IDVAR           reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    $end            reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    RCB             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)


state 128

    (14) nline -> FOR LPAREN fline bexp SCOLON assign RPAREN . LCB line RCB

    LCB             shift and go to state 133


state 129

    (15) nline -> WHILE LPAREN bexp RPAREN LCB line RCB .

    STR             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    BOOL            reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    RETURN          reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    EXIT            reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    PRINT           reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    FOR             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    WHILE           reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    INT             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    FLT             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    CHR             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    IF              reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    IDVAR           reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    $end            reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    RCB             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)


state 130

    (16) ifsts -> IF LPAREN bexp RPAREN LCB line RCB . elsests
    (17) elsests -> . ELSE LCB line RCB
    (18) elsests -> . ELSE ifsts
    (19) elsests -> . empty
    (55) empty -> .

    ELSE            shift and go to state 135
    STR             reduce using rule 55 (empty -> .)
    BOOL            reduce using rule 55 (empty -> .)
    RETURN          reduce using rule 55 (empty -> .)
    EXIT            reduce using rule 55 (empty -> .)
    PRINT           reduce using rule 55 (empty -> .)
    FOR             reduce using rule 55 (empty -> .)
    WHILE           reduce using rule 55 (empty -> .)
    INT             reduce using rule 55 (empty -> .)
    FLT             reduce using rule 55 (empty -> .)
    CHR             reduce using rule 55 (empty -> .)
    IF              reduce using rule 55 (empty -> .)
    IDVAR           reduce using rule 55 (empty -> .)
    $end            reduce using rule 55 (empty -> .)
    RCB             reduce using rule 55 (empty -> .)

    elsests                        shift and go to state 134
    empty                          shift and go to state 136

state 131

    (63) arrt -> LCB dws RCB .

    SCOLON          reduce using rule 63 (arrt -> LCB dws RCB .)


state 132

    (64) dws -> factarr COM . dws
    (64) dws -> . factarr COM dws
    (65) dws -> . factarr
    (66) factarr -> . fact
    (67) factarr -> . STRING
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . varval
    (31) fact -> . bval
    (32) fact -> . CHAR
    (33) varval -> . var
    (34) bval -> . TRUE
    (35) bval -> . FALSE
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    STRING          shift and go to state 125
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    factarr                        shift and go to state 123
    dws                            shift and go to state 137
    fact                           shift and go to state 124
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 133

    (14) nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB . line RCB
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN LCB line RCB
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB
    (15) nline -> . WHILE LPAREN bexp RPAREN LCB line RCB
    (60) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (61) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (39) dtype -> . INT
    (40) dtype -> . FLT
    (41) dtype -> . CHR
    (42) dtype -> . BOOL
    (58) fline -> . dtype numexp
    (59) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests
    (20) numexp -> . assign SCOLON
    (56) assign -> . var EQUAL exp
    (57) assign -> . var EQUAL STRING
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    fline                          shift and go to state 6
    assign                         shift and go to state 14
    line                           shift and go to state 138
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    ifsts                          shift and go to state 10
    numexp                         shift and go to state 19

state 134

    (16) ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .

    STR             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    BOOL            reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    RETURN          reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    EXIT            reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    PRINT           reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    FOR             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    WHILE           reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    INT             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    FLT             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    CHR             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    IF              reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    IDVAR           reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    $end            reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    RCB             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)


state 135

    (17) elsests -> ELSE . LCB line RCB
    (18) elsests -> ELSE . ifsts
    (16) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests

    LCB             shift and go to state 139
    IF              shift and go to state 20

    ifsts                          shift and go to state 140

state 136

    (19) elsests -> empty .

    STR             reduce using rule 19 (elsests -> empty .)
    BOOL            reduce using rule 19 (elsests -> empty .)
    RETURN          reduce using rule 19 (elsests -> empty .)
    EXIT            reduce using rule 19 (elsests -> empty .)
    PRINT           reduce using rule 19 (elsests -> empty .)
    FOR             reduce using rule 19 (elsests -> empty .)
    WHILE           reduce using rule 19 (elsests -> empty .)
    INT             reduce using rule 19 (elsests -> empty .)
    FLT             reduce using rule 19 (elsests -> empty .)
    CHR             reduce using rule 19 (elsests -> empty .)
    IF              reduce using rule 19 (elsests -> empty .)
    IDVAR           reduce using rule 19 (elsests -> empty .)
    $end            reduce using rule 19 (elsests -> empty .)
    RCB             reduce using rule 19 (elsests -> empty .)


state 137

    (64) dws -> factarr COM dws .

    RCB             reduce using rule 64 (dws -> factarr COM dws .)


state 138

    (14) nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line . RCB

    RCB             shift and go to state 141


state 139

    (17) elsests -> ELSE LCB . line RCB
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN LCB line RCB
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB
    (15) nline -> . WHILE LPAREN bexp RPAREN LCB line RCB
    (60) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (61) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (39) dtype -> . INT
    (40) dtype -> . FLT
    (41) dtype -> . CHR
    (42) dtype -> . BOOL
    (58) fline -> . dtype numexp
    (59) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests
    (20) numexp -> . assign SCOLON
    (56) assign -> . var EQUAL exp
    (57) assign -> . var EQUAL STRING
    (36) var -> . IDVAR
    (37) var -> . IDVAR LBB INTEGER RBB
    (38) var -> . IDVAR LBB IDVAR RBB

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 142
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19

state 140

    (18) elsests -> ELSE ifsts .

    STR             reduce using rule 18 (elsests -> ELSE ifsts .)
    BOOL            reduce using rule 18 (elsests -> ELSE ifsts .)
    RETURN          reduce using rule 18 (elsests -> ELSE ifsts .)
    EXIT            reduce using rule 18 (elsests -> ELSE ifsts .)
    PRINT           reduce using rule 18 (elsests -> ELSE ifsts .)
    FOR             reduce using rule 18 (elsests -> ELSE ifsts .)
    WHILE           reduce using rule 18 (elsests -> ELSE ifsts .)
    INT             reduce using rule 18 (elsests -> ELSE ifsts .)
    FLT             reduce using rule 18 (elsests -> ELSE ifsts .)
    CHR             reduce using rule 18 (elsests -> ELSE ifsts .)
    IF              reduce using rule 18 (elsests -> ELSE ifsts .)
    IDVAR           reduce using rule 18 (elsests -> ELSE ifsts .)
    $end            reduce using rule 18 (elsests -> ELSE ifsts .)
    RCB             reduce using rule 18 (elsests -> ELSE ifsts .)


state 141

    (14) nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .

    STR             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    BOOL            reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    RETURN          reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    EXIT            reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    PRINT           reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    FOR             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    WHILE           reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    INT             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    FLT             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    CHR             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    IF              reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    IDVAR           reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    $end            reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    RCB             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)


state 142

    (17) elsests -> ELSE LCB line . RCB

    RCB             shift and go to state 143


state 143

    (17) elsests -> ELSE LCB line RCB .

    STR             reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    BOOL            reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    RETURN          reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    EXIT            reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    PRINT           reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    FOR             reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    WHILE           reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    INT             reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    FLT             reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    CHR             reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    IF              reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    IDVAR           reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    $end            reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    RCB             reduce using rule 17 (elsests -> ELSE LCB line RCB .)

