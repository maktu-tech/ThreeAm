Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    VOID
    WITH

Grammar

Rule 0     S' -> line
Rule 1     line -> nline line
Rule 2     line -> nline
Rule 3     nline -> dtype var SCOLON
Rule 4     nline -> STR var SCOLON
Rule 5     nline -> fline
Rule 6     nline -> STR IDVAR EQUAL strvar SCOLON
Rule 7     nline -> BOOL MAIN LPAREN RPAREN lcb line rcb
Rule 8     nline -> RETURN LPAREN bval RPAREN SCOLON
Rule 9     nline -> ifsts
Rule 10    nline -> EXIT LPAREN RPAREN SCOLON
Rule 11    nline -> PRINT LPAREN pline RPAREN SCOLON
Rule 12    pline -> exp
Rule 13    pline -> STRING
Rule 14    nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb
Rule 15    nline -> WHILE LPAREN bexp RPAREN lcb line rcb
Rule 16    ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests
Rule 17    rcb -> RCB
Rule 18    lcb -> LCB
Rule 19    elsests -> ELSE lcb line rcb
Rule 20    elsests -> ELSE ifsts
Rule 21    elsests -> empty
Rule 22    numexp -> assign SCOLON
Rule 23    exp -> exp PLUS term
Rule 24    exp -> exp MINUS term
Rule 25    exp -> term
Rule 26    term -> term MUL fact
Rule 27    term -> term DIV fact
Rule 28    term -> term MOD fact
Rule 29    term -> fact
Rule 30    fact -> INTEGER
Rule 31    fact -> FLOAT
Rule 32    fact -> varval
Rule 33    fact -> bval
Rule 34    fact -> CHAR
Rule 35    varval -> var
Rule 36    varval -> var LBB exp RBB
Rule 37    assvar -> var
Rule 38    assvar -> var LBB exp RBB
Rule 39    bval -> TRUE
Rule 40    bval -> FALSE
Rule 41    var -> IDVAR
Rule 42    dtype -> INT
Rule 43    dtype -> FLT
Rule 44    dtype -> CHR
Rule 45    dtype -> BOOL
Rule 46    strvar -> STRING
Rule 47    strvar -> varval
Rule 48    bexp -> bexp andor bexp2
Rule 49    bexp -> bexp2
Rule 50    bexp2 -> bexp2 rln exp
Rule 51    bexp2 -> exp
Rule 52    rln -> DEQUAL
Rule 53    rln -> GTHEN
Rule 54    rln -> LTHEN
Rule 55    rln -> NOT
Rule 56    andor -> AND
Rule 57    andor -> OR
Rule 58    empty -> <empty>
Rule 59    assign -> assvar EQUAL exp
Rule 60    assign -> assvar EQUAL STRING
Rule 61    fline -> dtype numexp
Rule 62    fline -> numexp
Rule 63    nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON
Rule 64    nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON
Rule 65    arrt -> var
Rule 66    arrt -> LCB dws RCB
Rule 67    dws -> factarr COM dws
Rule 68    dws -> factarr
Rule 69    factarr -> fact
Rule 70    factarr -> STRING

Terminals, with rules where they appear

AND                  : 56
BOOL                 : 7 45
CHAR                 : 34
CHR                  : 44
COM                  : 67
COMMENT              : 
DEQUAL               : 52
DIV                  : 27
ELSE                 : 19 20
EQUAL                : 6 59 60 63 64
EXIT                 : 10
FALSE                : 40
FLOAT                : 31
FLT                  : 43
FOR                  : 14
GTHEN                : 53
IDVAR                : 6 41 63 64
IF                   : 16
INT                  : 42
INTEGER              : 30
LBB                  : 36 38 63 64
LCB                  : 18 66
LPAREN               : 7 8 10 11 14 15 16
LTHEN                : 54
MAIN                 : 7
MINUS                : 24
MOD                  : 28
MUL                  : 26
NOT                  : 55
OR                   : 57
PLUS                 : 23
PRINT                : 11
RBB                  : 36 38 63 64
RCB                  : 17 66
RETURN               : 8
RPAREN               : 7 8 10 11 14 15 16
SCOLON               : 3 4 6 8 10 11 14 22 63 64
STR                  : 4 6 64
STRING               : 13 46 60 70
TRUE                 : 39
VOID                 : 
WHILE                : 15
WITH                 : 
error                : 

Nonterminals, with rules where they appear

andor                : 48
arrt                 : 63 64
assign               : 14 22
assvar               : 59 60
bexp                 : 14 15 16 48
bexp2                : 48 49 50
bval                 : 8 33
dtype                : 3 61 63
dws                  : 66 67
elsests              : 16
empty                : 21
exp                  : 12 23 24 36 38 50 51 59
fact                 : 26 27 28 29 69
factarr              : 67 68
fline                : 5 14
ifsts                : 9 20
lcb                  : 7 14 15 16 19
line                 : 1 7 14 15 16 19 0
nline                : 1 2
numexp               : 61 62
pline                : 11
rcb                  : 7 14 15 16 19
rln                  : 50
strvar               : 6
term                 : 23 24 25 26 27 28
var                  : 3 4 35 36 37 38 65
varval               : 32 47

Parsing method: LALR

state 0

    (0) S' -> . line
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN lcb line rcb
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb
    (15) nline -> . WHILE LPAREN bexp RPAREN lcb line rcb
    (63) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (64) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (42) dtype -> . INT
    (43) dtype -> . FLT
    (44) dtype -> . CHR
    (45) dtype -> . BOOL
    (61) fline -> . dtype numexp
    (62) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN lcb line rcb elsests
    (22) numexp -> . assign SCOLON
    (59) assign -> . assvar EQUAL exp
    (60) assign -> . assvar EQUAL STRING
    (37) assvar -> . var
    (38) assvar -> . var LBB exp RBB
    (41) var -> . IDVAR

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 1
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19
    assvar                         shift and go to state 21

state 1

    (0) S' -> line .



state 2

    (1) line -> nline . line
    (2) line -> nline .
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN lcb line rcb
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb
    (15) nline -> . WHILE LPAREN bexp RPAREN lcb line rcb
    (63) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (64) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (42) dtype -> . INT
    (43) dtype -> . FLT
    (44) dtype -> . CHR
    (45) dtype -> . BOOL
    (61) fline -> . dtype numexp
    (62) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN lcb line rcb elsests
    (22) numexp -> . assign SCOLON
    (59) assign -> . assvar EQUAL exp
    (60) assign -> . assvar EQUAL STRING
    (37) assvar -> . var
    (38) assvar -> . var LBB exp RBB
    (41) var -> . IDVAR

    $end            reduce using rule 2 (line -> nline .)
    RCB             reduce using rule 2 (line -> nline .)
    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    nline                          shift and go to state 2
    line                           shift and go to state 22
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19
    assvar                         shift and go to state 21

state 3

    (3) nline -> dtype . var SCOLON
    (63) nline -> dtype . LBB RBB IDVAR EQUAL arrt SCOLON
    (61) fline -> dtype . numexp
    (41) var -> . IDVAR
    (22) numexp -> . assign SCOLON
    (59) assign -> . assvar EQUAL exp
    (60) assign -> . assvar EQUAL STRING
    (37) assvar -> . var
    (38) assvar -> . var LBB exp RBB

    LBB             shift and go to state 24
    IDVAR           shift and go to state 7

    var                            shift and go to state 23
    numexp                         shift and go to state 25
    assign                         shift and go to state 14
    assvar                         shift and go to state 21

state 4

    (37) assvar -> var .
    (38) assvar -> var . LBB exp RBB

    EQUAL           reduce using rule 37 (assvar -> var .)
    LBB             shift and go to state 26


state 5

    (4) nline -> STR . var SCOLON
    (6) nline -> STR . IDVAR EQUAL strvar SCOLON
    (64) nline -> STR . LBB RBB IDVAR EQUAL arrt SCOLON
    (41) var -> . IDVAR

    IDVAR           shift and go to state 28
    LBB             shift and go to state 29

    var                            shift and go to state 27

state 6

    (5) nline -> fline .

    STR             reduce using rule 5 (nline -> fline .)
    BOOL            reduce using rule 5 (nline -> fline .)
    RETURN          reduce using rule 5 (nline -> fline .)
    EXIT            reduce using rule 5 (nline -> fline .)
    PRINT           reduce using rule 5 (nline -> fline .)
    FOR             reduce using rule 5 (nline -> fline .)
    WHILE           reduce using rule 5 (nline -> fline .)
    INT             reduce using rule 5 (nline -> fline .)
    FLT             reduce using rule 5 (nline -> fline .)
    CHR             reduce using rule 5 (nline -> fline .)
    IF              reduce using rule 5 (nline -> fline .)
    IDVAR           reduce using rule 5 (nline -> fline .)
    $end            reduce using rule 5 (nline -> fline .)
    RCB             reduce using rule 5 (nline -> fline .)


state 7

    (41) var -> IDVAR .

    LBB             reduce using rule 41 (var -> IDVAR .)
    EQUAL           reduce using rule 41 (var -> IDVAR .)
    SCOLON          reduce using rule 41 (var -> IDVAR .)
    MUL             reduce using rule 41 (var -> IDVAR .)
    DIV             reduce using rule 41 (var -> IDVAR .)
    MOD             reduce using rule 41 (var -> IDVAR .)
    RBB             reduce using rule 41 (var -> IDVAR .)
    PLUS            reduce using rule 41 (var -> IDVAR .)
    MINUS           reduce using rule 41 (var -> IDVAR .)
    RPAREN          reduce using rule 41 (var -> IDVAR .)
    DEQUAL          reduce using rule 41 (var -> IDVAR .)
    GTHEN           reduce using rule 41 (var -> IDVAR .)
    LTHEN           reduce using rule 41 (var -> IDVAR .)
    NOT             reduce using rule 41 (var -> IDVAR .)
    AND             reduce using rule 41 (var -> IDVAR .)
    OR              reduce using rule 41 (var -> IDVAR .)
    COM             reduce using rule 41 (var -> IDVAR .)
    RCB             reduce using rule 41 (var -> IDVAR .)


state 8

    (7) nline -> BOOL . MAIN LPAREN RPAREN lcb line rcb
    (45) dtype -> BOOL .

    MAIN            shift and go to state 30
    LBB             reduce using rule 45 (dtype -> BOOL .)
    IDVAR           reduce using rule 45 (dtype -> BOOL .)


state 9

    (8) nline -> RETURN . LPAREN bval RPAREN SCOLON

    LPAREN          shift and go to state 31


state 10

    (9) nline -> ifsts .

    STR             reduce using rule 9 (nline -> ifsts .)
    BOOL            reduce using rule 9 (nline -> ifsts .)
    RETURN          reduce using rule 9 (nline -> ifsts .)
    EXIT            reduce using rule 9 (nline -> ifsts .)
    PRINT           reduce using rule 9 (nline -> ifsts .)
    FOR             reduce using rule 9 (nline -> ifsts .)
    WHILE           reduce using rule 9 (nline -> ifsts .)
    INT             reduce using rule 9 (nline -> ifsts .)
    FLT             reduce using rule 9 (nline -> ifsts .)
    CHR             reduce using rule 9 (nline -> ifsts .)
    IF              reduce using rule 9 (nline -> ifsts .)
    IDVAR           reduce using rule 9 (nline -> ifsts .)
    $end            reduce using rule 9 (nline -> ifsts .)
    RCB             reduce using rule 9 (nline -> ifsts .)


state 11

    (10) nline -> EXIT . LPAREN RPAREN SCOLON

    LPAREN          shift and go to state 32


state 12

    (11) nline -> PRINT . LPAREN pline RPAREN SCOLON

    LPAREN          shift and go to state 33


state 13

    (14) nline -> FOR . LPAREN fline bexp SCOLON assign RPAREN lcb line rcb

    LPAREN          shift and go to state 34


state 14

    (22) numexp -> assign . SCOLON

    SCOLON          shift and go to state 35


state 15

    (15) nline -> WHILE . LPAREN bexp RPAREN lcb line rcb

    LPAREN          shift and go to state 36


state 16

    (42) dtype -> INT .

    LBB             reduce using rule 42 (dtype -> INT .)
    IDVAR           reduce using rule 42 (dtype -> INT .)


state 17

    (43) dtype -> FLT .

    LBB             reduce using rule 43 (dtype -> FLT .)
    IDVAR           reduce using rule 43 (dtype -> FLT .)


state 18

    (44) dtype -> CHR .

    LBB             reduce using rule 44 (dtype -> CHR .)
    IDVAR           reduce using rule 44 (dtype -> CHR .)


state 19

    (62) fline -> numexp .

    STR             reduce using rule 62 (fline -> numexp .)
    BOOL            reduce using rule 62 (fline -> numexp .)
    RETURN          reduce using rule 62 (fline -> numexp .)
    EXIT            reduce using rule 62 (fline -> numexp .)
    PRINT           reduce using rule 62 (fline -> numexp .)
    FOR             reduce using rule 62 (fline -> numexp .)
    WHILE           reduce using rule 62 (fline -> numexp .)
    INT             reduce using rule 62 (fline -> numexp .)
    FLT             reduce using rule 62 (fline -> numexp .)
    CHR             reduce using rule 62 (fline -> numexp .)
    IF              reduce using rule 62 (fline -> numexp .)
    IDVAR           reduce using rule 62 (fline -> numexp .)
    $end            reduce using rule 62 (fline -> numexp .)
    RCB             reduce using rule 62 (fline -> numexp .)
    INTEGER         reduce using rule 62 (fline -> numexp .)
    FLOAT           reduce using rule 62 (fline -> numexp .)
    CHAR            reduce using rule 62 (fline -> numexp .)
    TRUE            reduce using rule 62 (fline -> numexp .)
    FALSE           reduce using rule 62 (fline -> numexp .)


state 20

    (16) ifsts -> IF . LPAREN bexp RPAREN lcb line rcb elsests

    LPAREN          shift and go to state 37


state 21

    (59) assign -> assvar . EQUAL exp
    (60) assign -> assvar . EQUAL STRING

    EQUAL           shift and go to state 38


state 22

    (1) line -> nline line .

    $end            reduce using rule 1 (line -> nline line .)
    RCB             reduce using rule 1 (line -> nline line .)


state 23

    (3) nline -> dtype var . SCOLON
    (37) assvar -> var .
    (38) assvar -> var . LBB exp RBB

    SCOLON          shift and go to state 39
    EQUAL           reduce using rule 37 (assvar -> var .)
    LBB             shift and go to state 26


state 24

    (63) nline -> dtype LBB . RBB IDVAR EQUAL arrt SCOLON

    RBB             shift and go to state 40


state 25

    (61) fline -> dtype numexp .

    STR             reduce using rule 61 (fline -> dtype numexp .)
    BOOL            reduce using rule 61 (fline -> dtype numexp .)
    RETURN          reduce using rule 61 (fline -> dtype numexp .)
    EXIT            reduce using rule 61 (fline -> dtype numexp .)
    PRINT           reduce using rule 61 (fline -> dtype numexp .)
    FOR             reduce using rule 61 (fline -> dtype numexp .)
    WHILE           reduce using rule 61 (fline -> dtype numexp .)
    INT             reduce using rule 61 (fline -> dtype numexp .)
    FLT             reduce using rule 61 (fline -> dtype numexp .)
    CHR             reduce using rule 61 (fline -> dtype numexp .)
    IF              reduce using rule 61 (fline -> dtype numexp .)
    IDVAR           reduce using rule 61 (fline -> dtype numexp .)
    $end            reduce using rule 61 (fline -> dtype numexp .)
    RCB             reduce using rule 61 (fline -> dtype numexp .)
    INTEGER         reduce using rule 61 (fline -> dtype numexp .)
    FLOAT           reduce using rule 61 (fline -> dtype numexp .)
    CHAR            reduce using rule 61 (fline -> dtype numexp .)
    TRUE            reduce using rule 61 (fline -> dtype numexp .)
    FALSE           reduce using rule 61 (fline -> dtype numexp .)


state 26

    (38) assvar -> var LBB . exp RBB
    (23) exp -> . exp PLUS term
    (24) exp -> . exp MINUS term
    (25) exp -> . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) bval -> . TRUE
    (40) bval -> . FALSE
    (41) var -> . IDVAR

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    var                            shift and go to state 41
    exp                            shift and go to state 42
    term                           shift and go to state 43
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48

state 27

    (4) nline -> STR var . SCOLON

    SCOLON          shift and go to state 52


state 28

    (6) nline -> STR IDVAR . EQUAL strvar SCOLON
    (41) var -> IDVAR .

    EQUAL           shift and go to state 53
    SCOLON          reduce using rule 41 (var -> IDVAR .)


state 29

    (64) nline -> STR LBB . RBB IDVAR EQUAL arrt SCOLON

    RBB             shift and go to state 54


state 30

    (7) nline -> BOOL MAIN . LPAREN RPAREN lcb line rcb

    LPAREN          shift and go to state 55


state 31

    (8) nline -> RETURN LPAREN . bval RPAREN SCOLON
    (39) bval -> . TRUE
    (40) bval -> . FALSE

    TRUE            shift and go to state 50
    FALSE           shift and go to state 51

    bval                           shift and go to state 56

state 32

    (10) nline -> EXIT LPAREN . RPAREN SCOLON

    RPAREN          shift and go to state 57


state 33

    (11) nline -> PRINT LPAREN . pline RPAREN SCOLON
    (12) pline -> . exp
    (13) pline -> . STRING
    (23) exp -> . exp PLUS term
    (24) exp -> . exp MINUS term
    (25) exp -> . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) bval -> . TRUE
    (40) bval -> . FALSE
    (41) var -> . IDVAR

    STRING          shift and go to state 60
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    pline                          shift and go to state 58
    exp                            shift and go to state 59
    term                           shift and go to state 43
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 41

state 34

    (14) nline -> FOR LPAREN . fline bexp SCOLON assign RPAREN lcb line rcb
    (61) fline -> . dtype numexp
    (62) fline -> . numexp
    (42) dtype -> . INT
    (43) dtype -> . FLT
    (44) dtype -> . CHR
    (45) dtype -> . BOOL
    (22) numexp -> . assign SCOLON
    (59) assign -> . assvar EQUAL exp
    (60) assign -> . assvar EQUAL STRING
    (37) assvar -> . var
    (38) assvar -> . var LBB exp RBB
    (41) var -> . IDVAR

    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    BOOL            shift and go to state 63
    IDVAR           shift and go to state 7

    fline                          shift and go to state 61
    assign                         shift and go to state 14
    dtype                          shift and go to state 62
    numexp                         shift and go to state 19
    assvar                         shift and go to state 21
    var                            shift and go to state 4

state 35

    (22) numexp -> assign SCOLON .

    STR             reduce using rule 22 (numexp -> assign SCOLON .)
    BOOL            reduce using rule 22 (numexp -> assign SCOLON .)
    RETURN          reduce using rule 22 (numexp -> assign SCOLON .)
    EXIT            reduce using rule 22 (numexp -> assign SCOLON .)
    PRINT           reduce using rule 22 (numexp -> assign SCOLON .)
    FOR             reduce using rule 22 (numexp -> assign SCOLON .)
    WHILE           reduce using rule 22 (numexp -> assign SCOLON .)
    INT             reduce using rule 22 (numexp -> assign SCOLON .)
    FLT             reduce using rule 22 (numexp -> assign SCOLON .)
    CHR             reduce using rule 22 (numexp -> assign SCOLON .)
    IF              reduce using rule 22 (numexp -> assign SCOLON .)
    IDVAR           reduce using rule 22 (numexp -> assign SCOLON .)
    $end            reduce using rule 22 (numexp -> assign SCOLON .)
    RCB             reduce using rule 22 (numexp -> assign SCOLON .)
    INTEGER         reduce using rule 22 (numexp -> assign SCOLON .)
    FLOAT           reduce using rule 22 (numexp -> assign SCOLON .)
    CHAR            reduce using rule 22 (numexp -> assign SCOLON .)
    TRUE            reduce using rule 22 (numexp -> assign SCOLON .)
    FALSE           reduce using rule 22 (numexp -> assign SCOLON .)


state 36

    (15) nline -> WHILE LPAREN . bexp RPAREN lcb line rcb
    (48) bexp -> . bexp andor bexp2
    (49) bexp -> . bexp2
    (50) bexp2 -> . bexp2 rln exp
    (51) bexp2 -> . exp
    (23) exp -> . exp PLUS term
    (24) exp -> . exp MINUS term
    (25) exp -> . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) bval -> . TRUE
    (40) bval -> . FALSE
    (41) var -> . IDVAR

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    bexp                           shift and go to state 64
    bexp2                          shift and go to state 65
    exp                            shift and go to state 66
    term                           shift and go to state 43
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 41

state 37

    (16) ifsts -> IF LPAREN . bexp RPAREN lcb line rcb elsests
    (48) bexp -> . bexp andor bexp2
    (49) bexp -> . bexp2
    (50) bexp2 -> . bexp2 rln exp
    (51) bexp2 -> . exp
    (23) exp -> . exp PLUS term
    (24) exp -> . exp MINUS term
    (25) exp -> . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) bval -> . TRUE
    (40) bval -> . FALSE
    (41) var -> . IDVAR

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    bexp                           shift and go to state 67
    bexp2                          shift and go to state 65
    exp                            shift and go to state 66
    term                           shift and go to state 43
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 41

state 38

    (59) assign -> assvar EQUAL . exp
    (60) assign -> assvar EQUAL . STRING
    (23) exp -> . exp PLUS term
    (24) exp -> . exp MINUS term
    (25) exp -> . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) bval -> . TRUE
    (40) bval -> . FALSE
    (41) var -> . IDVAR

    STRING          shift and go to state 69
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    exp                            shift and go to state 68
    term                           shift and go to state 43
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 41

state 39

    (3) nline -> dtype var SCOLON .

    STR             reduce using rule 3 (nline -> dtype var SCOLON .)
    BOOL            reduce using rule 3 (nline -> dtype var SCOLON .)
    RETURN          reduce using rule 3 (nline -> dtype var SCOLON .)
    EXIT            reduce using rule 3 (nline -> dtype var SCOLON .)
    PRINT           reduce using rule 3 (nline -> dtype var SCOLON .)
    FOR             reduce using rule 3 (nline -> dtype var SCOLON .)
    WHILE           reduce using rule 3 (nline -> dtype var SCOLON .)
    INT             reduce using rule 3 (nline -> dtype var SCOLON .)
    FLT             reduce using rule 3 (nline -> dtype var SCOLON .)
    CHR             reduce using rule 3 (nline -> dtype var SCOLON .)
    IF              reduce using rule 3 (nline -> dtype var SCOLON .)
    IDVAR           reduce using rule 3 (nline -> dtype var SCOLON .)
    $end            reduce using rule 3 (nline -> dtype var SCOLON .)
    RCB             reduce using rule 3 (nline -> dtype var SCOLON .)


state 40

    (63) nline -> dtype LBB RBB . IDVAR EQUAL arrt SCOLON

    IDVAR           shift and go to state 70


state 41

    (35) varval -> var .
    (36) varval -> var . LBB exp RBB

    MUL             reduce using rule 35 (varval -> var .)
    DIV             reduce using rule 35 (varval -> var .)
    MOD             reduce using rule 35 (varval -> var .)
    RBB             reduce using rule 35 (varval -> var .)
    PLUS            reduce using rule 35 (varval -> var .)
    MINUS           reduce using rule 35 (varval -> var .)
    RPAREN          reduce using rule 35 (varval -> var .)
    DEQUAL          reduce using rule 35 (varval -> var .)
    GTHEN           reduce using rule 35 (varval -> var .)
    LTHEN           reduce using rule 35 (varval -> var .)
    NOT             reduce using rule 35 (varval -> var .)
    AND             reduce using rule 35 (varval -> var .)
    OR              reduce using rule 35 (varval -> var .)
    SCOLON          reduce using rule 35 (varval -> var .)
    COM             reduce using rule 35 (varval -> var .)
    RCB             reduce using rule 35 (varval -> var .)
    LBB             shift and go to state 71


state 42

    (38) assvar -> var LBB exp . RBB
    (23) exp -> exp . PLUS term
    (24) exp -> exp . MINUS term

    RBB             shift and go to state 72
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74


state 43

    (25) exp -> term .
    (26) term -> term . MUL fact
    (27) term -> term . DIV fact
    (28) term -> term . MOD fact

    RBB             reduce using rule 25 (exp -> term .)
    PLUS            reduce using rule 25 (exp -> term .)
    MINUS           reduce using rule 25 (exp -> term .)
    RPAREN          reduce using rule 25 (exp -> term .)
    DEQUAL          reduce using rule 25 (exp -> term .)
    GTHEN           reduce using rule 25 (exp -> term .)
    LTHEN           reduce using rule 25 (exp -> term .)
    NOT             reduce using rule 25 (exp -> term .)
    AND             reduce using rule 25 (exp -> term .)
    OR              reduce using rule 25 (exp -> term .)
    SCOLON          reduce using rule 25 (exp -> term .)
    MUL             shift and go to state 75
    DIV             shift and go to state 76
    MOD             shift and go to state 77


state 44

    (29) term -> fact .

    MUL             reduce using rule 29 (term -> fact .)
    DIV             reduce using rule 29 (term -> fact .)
    MOD             reduce using rule 29 (term -> fact .)
    RBB             reduce using rule 29 (term -> fact .)
    PLUS            reduce using rule 29 (term -> fact .)
    MINUS           reduce using rule 29 (term -> fact .)
    RPAREN          reduce using rule 29 (term -> fact .)
    DEQUAL          reduce using rule 29 (term -> fact .)
    GTHEN           reduce using rule 29 (term -> fact .)
    LTHEN           reduce using rule 29 (term -> fact .)
    NOT             reduce using rule 29 (term -> fact .)
    AND             reduce using rule 29 (term -> fact .)
    OR              reduce using rule 29 (term -> fact .)
    SCOLON          reduce using rule 29 (term -> fact .)


state 45

    (30) fact -> INTEGER .

    MUL             reduce using rule 30 (fact -> INTEGER .)
    DIV             reduce using rule 30 (fact -> INTEGER .)
    MOD             reduce using rule 30 (fact -> INTEGER .)
    RBB             reduce using rule 30 (fact -> INTEGER .)
    PLUS            reduce using rule 30 (fact -> INTEGER .)
    MINUS           reduce using rule 30 (fact -> INTEGER .)
    RPAREN          reduce using rule 30 (fact -> INTEGER .)
    DEQUAL          reduce using rule 30 (fact -> INTEGER .)
    GTHEN           reduce using rule 30 (fact -> INTEGER .)
    LTHEN           reduce using rule 30 (fact -> INTEGER .)
    NOT             reduce using rule 30 (fact -> INTEGER .)
    AND             reduce using rule 30 (fact -> INTEGER .)
    OR              reduce using rule 30 (fact -> INTEGER .)
    SCOLON          reduce using rule 30 (fact -> INTEGER .)
    COM             reduce using rule 30 (fact -> INTEGER .)
    RCB             reduce using rule 30 (fact -> INTEGER .)


state 46

    (31) fact -> FLOAT .

    MUL             reduce using rule 31 (fact -> FLOAT .)
    DIV             reduce using rule 31 (fact -> FLOAT .)
    MOD             reduce using rule 31 (fact -> FLOAT .)
    RBB             reduce using rule 31 (fact -> FLOAT .)
    PLUS            reduce using rule 31 (fact -> FLOAT .)
    MINUS           reduce using rule 31 (fact -> FLOAT .)
    RPAREN          reduce using rule 31 (fact -> FLOAT .)
    DEQUAL          reduce using rule 31 (fact -> FLOAT .)
    GTHEN           reduce using rule 31 (fact -> FLOAT .)
    LTHEN           reduce using rule 31 (fact -> FLOAT .)
    NOT             reduce using rule 31 (fact -> FLOAT .)
    AND             reduce using rule 31 (fact -> FLOAT .)
    OR              reduce using rule 31 (fact -> FLOAT .)
    SCOLON          reduce using rule 31 (fact -> FLOAT .)
    COM             reduce using rule 31 (fact -> FLOAT .)
    RCB             reduce using rule 31 (fact -> FLOAT .)


state 47

    (32) fact -> varval .

    MUL             reduce using rule 32 (fact -> varval .)
    DIV             reduce using rule 32 (fact -> varval .)
    MOD             reduce using rule 32 (fact -> varval .)
    RBB             reduce using rule 32 (fact -> varval .)
    PLUS            reduce using rule 32 (fact -> varval .)
    MINUS           reduce using rule 32 (fact -> varval .)
    RPAREN          reduce using rule 32 (fact -> varval .)
    DEQUAL          reduce using rule 32 (fact -> varval .)
    GTHEN           reduce using rule 32 (fact -> varval .)
    LTHEN           reduce using rule 32 (fact -> varval .)
    NOT             reduce using rule 32 (fact -> varval .)
    AND             reduce using rule 32 (fact -> varval .)
    OR              reduce using rule 32 (fact -> varval .)
    SCOLON          reduce using rule 32 (fact -> varval .)
    COM             reduce using rule 32 (fact -> varval .)
    RCB             reduce using rule 32 (fact -> varval .)


state 48

    (33) fact -> bval .

    MUL             reduce using rule 33 (fact -> bval .)
    DIV             reduce using rule 33 (fact -> bval .)
    MOD             reduce using rule 33 (fact -> bval .)
    RBB             reduce using rule 33 (fact -> bval .)
    PLUS            reduce using rule 33 (fact -> bval .)
    MINUS           reduce using rule 33 (fact -> bval .)
    RPAREN          reduce using rule 33 (fact -> bval .)
    DEQUAL          reduce using rule 33 (fact -> bval .)
    GTHEN           reduce using rule 33 (fact -> bval .)
    LTHEN           reduce using rule 33 (fact -> bval .)
    NOT             reduce using rule 33 (fact -> bval .)
    AND             reduce using rule 33 (fact -> bval .)
    OR              reduce using rule 33 (fact -> bval .)
    SCOLON          reduce using rule 33 (fact -> bval .)
    COM             reduce using rule 33 (fact -> bval .)
    RCB             reduce using rule 33 (fact -> bval .)


state 49

    (34) fact -> CHAR .

    MUL             reduce using rule 34 (fact -> CHAR .)
    DIV             reduce using rule 34 (fact -> CHAR .)
    MOD             reduce using rule 34 (fact -> CHAR .)
    RBB             reduce using rule 34 (fact -> CHAR .)
    PLUS            reduce using rule 34 (fact -> CHAR .)
    MINUS           reduce using rule 34 (fact -> CHAR .)
    RPAREN          reduce using rule 34 (fact -> CHAR .)
    DEQUAL          reduce using rule 34 (fact -> CHAR .)
    GTHEN           reduce using rule 34 (fact -> CHAR .)
    LTHEN           reduce using rule 34 (fact -> CHAR .)
    NOT             reduce using rule 34 (fact -> CHAR .)
    AND             reduce using rule 34 (fact -> CHAR .)
    OR              reduce using rule 34 (fact -> CHAR .)
    SCOLON          reduce using rule 34 (fact -> CHAR .)
    COM             reduce using rule 34 (fact -> CHAR .)
    RCB             reduce using rule 34 (fact -> CHAR .)


state 50

    (39) bval -> TRUE .

    MUL             reduce using rule 39 (bval -> TRUE .)
    DIV             reduce using rule 39 (bval -> TRUE .)
    MOD             reduce using rule 39 (bval -> TRUE .)
    RBB             reduce using rule 39 (bval -> TRUE .)
    PLUS            reduce using rule 39 (bval -> TRUE .)
    MINUS           reduce using rule 39 (bval -> TRUE .)
    RPAREN          reduce using rule 39 (bval -> TRUE .)
    DEQUAL          reduce using rule 39 (bval -> TRUE .)
    GTHEN           reduce using rule 39 (bval -> TRUE .)
    LTHEN           reduce using rule 39 (bval -> TRUE .)
    NOT             reduce using rule 39 (bval -> TRUE .)
    AND             reduce using rule 39 (bval -> TRUE .)
    OR              reduce using rule 39 (bval -> TRUE .)
    SCOLON          reduce using rule 39 (bval -> TRUE .)
    COM             reduce using rule 39 (bval -> TRUE .)
    RCB             reduce using rule 39 (bval -> TRUE .)


state 51

    (40) bval -> FALSE .

    MUL             reduce using rule 40 (bval -> FALSE .)
    DIV             reduce using rule 40 (bval -> FALSE .)
    MOD             reduce using rule 40 (bval -> FALSE .)
    RBB             reduce using rule 40 (bval -> FALSE .)
    PLUS            reduce using rule 40 (bval -> FALSE .)
    MINUS           reduce using rule 40 (bval -> FALSE .)
    RPAREN          reduce using rule 40 (bval -> FALSE .)
    DEQUAL          reduce using rule 40 (bval -> FALSE .)
    GTHEN           reduce using rule 40 (bval -> FALSE .)
    LTHEN           reduce using rule 40 (bval -> FALSE .)
    NOT             reduce using rule 40 (bval -> FALSE .)
    AND             reduce using rule 40 (bval -> FALSE .)
    OR              reduce using rule 40 (bval -> FALSE .)
    SCOLON          reduce using rule 40 (bval -> FALSE .)
    COM             reduce using rule 40 (bval -> FALSE .)
    RCB             reduce using rule 40 (bval -> FALSE .)


state 52

    (4) nline -> STR var SCOLON .

    STR             reduce using rule 4 (nline -> STR var SCOLON .)
    BOOL            reduce using rule 4 (nline -> STR var SCOLON .)
    RETURN          reduce using rule 4 (nline -> STR var SCOLON .)
    EXIT            reduce using rule 4 (nline -> STR var SCOLON .)
    PRINT           reduce using rule 4 (nline -> STR var SCOLON .)
    FOR             reduce using rule 4 (nline -> STR var SCOLON .)
    WHILE           reduce using rule 4 (nline -> STR var SCOLON .)
    INT             reduce using rule 4 (nline -> STR var SCOLON .)
    FLT             reduce using rule 4 (nline -> STR var SCOLON .)
    CHR             reduce using rule 4 (nline -> STR var SCOLON .)
    IF              reduce using rule 4 (nline -> STR var SCOLON .)
    IDVAR           reduce using rule 4 (nline -> STR var SCOLON .)
    $end            reduce using rule 4 (nline -> STR var SCOLON .)
    RCB             reduce using rule 4 (nline -> STR var SCOLON .)


state 53

    (6) nline -> STR IDVAR EQUAL . strvar SCOLON
    (46) strvar -> . STRING
    (47) strvar -> . varval
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (41) var -> . IDVAR

    STRING          shift and go to state 79
    IDVAR           shift and go to state 7

    strvar                         shift and go to state 78
    varval                         shift and go to state 80
    var                            shift and go to state 41

state 54

    (64) nline -> STR LBB RBB . IDVAR EQUAL arrt SCOLON

    IDVAR           shift and go to state 81


state 55

    (7) nline -> BOOL MAIN LPAREN . RPAREN lcb line rcb

    RPAREN          shift and go to state 82


state 56

    (8) nline -> RETURN LPAREN bval . RPAREN SCOLON

    RPAREN          shift and go to state 83


state 57

    (10) nline -> EXIT LPAREN RPAREN . SCOLON

    SCOLON          shift and go to state 84


state 58

    (11) nline -> PRINT LPAREN pline . RPAREN SCOLON

    RPAREN          shift and go to state 85


state 59

    (12) pline -> exp .
    (23) exp -> exp . PLUS term
    (24) exp -> exp . MINUS term

    RPAREN          reduce using rule 12 (pline -> exp .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74


state 60

    (13) pline -> STRING .

    RPAREN          reduce using rule 13 (pline -> STRING .)


state 61

    (14) nline -> FOR LPAREN fline . bexp SCOLON assign RPAREN lcb line rcb
    (48) bexp -> . bexp andor bexp2
    (49) bexp -> . bexp2
    (50) bexp2 -> . bexp2 rln exp
    (51) bexp2 -> . exp
    (23) exp -> . exp PLUS term
    (24) exp -> . exp MINUS term
    (25) exp -> . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) bval -> . TRUE
    (40) bval -> . FALSE
    (41) var -> . IDVAR

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    bexp                           shift and go to state 86
    bexp2                          shift and go to state 65
    exp                            shift and go to state 66
    term                           shift and go to state 43
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 41

state 62

    (61) fline -> dtype . numexp
    (22) numexp -> . assign SCOLON
    (59) assign -> . assvar EQUAL exp
    (60) assign -> . assvar EQUAL STRING
    (37) assvar -> . var
    (38) assvar -> . var LBB exp RBB
    (41) var -> . IDVAR

    IDVAR           shift and go to state 7

    numexp                         shift and go to state 25
    assign                         shift and go to state 14
    assvar                         shift and go to state 21
    var                            shift and go to state 4

state 63

    (45) dtype -> BOOL .

    IDVAR           reduce using rule 45 (dtype -> BOOL .)


state 64

    (15) nline -> WHILE LPAREN bexp . RPAREN lcb line rcb
    (48) bexp -> bexp . andor bexp2
    (56) andor -> . AND
    (57) andor -> . OR

    RPAREN          shift and go to state 87
    AND             shift and go to state 89
    OR              shift and go to state 90

    andor                          shift and go to state 88

state 65

    (49) bexp -> bexp2 .
    (50) bexp2 -> bexp2 . rln exp
    (52) rln -> . DEQUAL
    (53) rln -> . GTHEN
    (54) rln -> . LTHEN
    (55) rln -> . NOT

    RPAREN          reduce using rule 49 (bexp -> bexp2 .)
    AND             reduce using rule 49 (bexp -> bexp2 .)
    OR              reduce using rule 49 (bexp -> bexp2 .)
    SCOLON          reduce using rule 49 (bexp -> bexp2 .)
    DEQUAL          shift and go to state 92
    GTHEN           shift and go to state 93
    LTHEN           shift and go to state 94
    NOT             shift and go to state 95

    rln                            shift and go to state 91

state 66

    (51) bexp2 -> exp .
    (23) exp -> exp . PLUS term
    (24) exp -> exp . MINUS term

    DEQUAL          reduce using rule 51 (bexp2 -> exp .)
    GTHEN           reduce using rule 51 (bexp2 -> exp .)
    LTHEN           reduce using rule 51 (bexp2 -> exp .)
    NOT             reduce using rule 51 (bexp2 -> exp .)
    RPAREN          reduce using rule 51 (bexp2 -> exp .)
    AND             reduce using rule 51 (bexp2 -> exp .)
    OR              reduce using rule 51 (bexp2 -> exp .)
    SCOLON          reduce using rule 51 (bexp2 -> exp .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74


state 67

    (16) ifsts -> IF LPAREN bexp . RPAREN lcb line rcb elsests
    (48) bexp -> bexp . andor bexp2
    (56) andor -> . AND
    (57) andor -> . OR

    RPAREN          shift and go to state 96
    AND             shift and go to state 89
    OR              shift and go to state 90

    andor                          shift and go to state 88

state 68

    (59) assign -> assvar EQUAL exp .
    (23) exp -> exp . PLUS term
    (24) exp -> exp . MINUS term

    SCOLON          reduce using rule 59 (assign -> assvar EQUAL exp .)
    RPAREN          reduce using rule 59 (assign -> assvar EQUAL exp .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74


state 69

    (60) assign -> assvar EQUAL STRING .

    SCOLON          reduce using rule 60 (assign -> assvar EQUAL STRING .)
    RPAREN          reduce using rule 60 (assign -> assvar EQUAL STRING .)


state 70

    (63) nline -> dtype LBB RBB IDVAR . EQUAL arrt SCOLON

    EQUAL           shift and go to state 97


state 71

    (36) varval -> var LBB . exp RBB
    (23) exp -> . exp PLUS term
    (24) exp -> . exp MINUS term
    (25) exp -> . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) bval -> . TRUE
    (40) bval -> . FALSE
    (41) var -> . IDVAR

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    var                            shift and go to state 41
    exp                            shift and go to state 98
    term                           shift and go to state 43
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48

state 72

    (38) assvar -> var LBB exp RBB .

    EQUAL           reduce using rule 38 (assvar -> var LBB exp RBB .)


state 73

    (23) exp -> exp PLUS . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) bval -> . TRUE
    (40) bval -> . FALSE
    (41) var -> . IDVAR

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    term                           shift and go to state 99
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 41

state 74

    (24) exp -> exp MINUS . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) bval -> . TRUE
    (40) bval -> . FALSE
    (41) var -> . IDVAR

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    term                           shift and go to state 100
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 41

state 75

    (26) term -> term MUL . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) bval -> . TRUE
    (40) bval -> . FALSE
    (41) var -> . IDVAR

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    fact                           shift and go to state 101
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 41

state 76

    (27) term -> term DIV . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) bval -> . TRUE
    (40) bval -> . FALSE
    (41) var -> . IDVAR

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    fact                           shift and go to state 102
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 41

state 77

    (28) term -> term MOD . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) bval -> . TRUE
    (40) bval -> . FALSE
    (41) var -> . IDVAR

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    fact                           shift and go to state 103
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 41

state 78

    (6) nline -> STR IDVAR EQUAL strvar . SCOLON

    SCOLON          shift and go to state 104


state 79

    (46) strvar -> STRING .

    SCOLON          reduce using rule 46 (strvar -> STRING .)


state 80

    (47) strvar -> varval .

    SCOLON          reduce using rule 47 (strvar -> varval .)


state 81

    (64) nline -> STR LBB RBB IDVAR . EQUAL arrt SCOLON

    EQUAL           shift and go to state 105


state 82

    (7) nline -> BOOL MAIN LPAREN RPAREN . lcb line rcb
    (18) lcb -> . LCB

    LCB             shift and go to state 107

    lcb                            shift and go to state 106

state 83

    (8) nline -> RETURN LPAREN bval RPAREN . SCOLON

    SCOLON          shift and go to state 108


state 84

    (10) nline -> EXIT LPAREN RPAREN SCOLON .

    STR             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    BOOL            reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    RETURN          reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    EXIT            reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    PRINT           reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    FOR             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    WHILE           reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    INT             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    FLT             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    CHR             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    IF              reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    IDVAR           reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    $end            reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    RCB             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)


state 85

    (11) nline -> PRINT LPAREN pline RPAREN . SCOLON

    SCOLON          shift and go to state 109


state 86

    (14) nline -> FOR LPAREN fline bexp . SCOLON assign RPAREN lcb line rcb
    (48) bexp -> bexp . andor bexp2
    (56) andor -> . AND
    (57) andor -> . OR

    SCOLON          shift and go to state 110
    AND             shift and go to state 89
    OR              shift and go to state 90

    andor                          shift and go to state 88

state 87

    (15) nline -> WHILE LPAREN bexp RPAREN . lcb line rcb
    (18) lcb -> . LCB

    LCB             shift and go to state 107

    lcb                            shift and go to state 111

state 88

    (48) bexp -> bexp andor . bexp2
    (50) bexp2 -> . bexp2 rln exp
    (51) bexp2 -> . exp
    (23) exp -> . exp PLUS term
    (24) exp -> . exp MINUS term
    (25) exp -> . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) bval -> . TRUE
    (40) bval -> . FALSE
    (41) var -> . IDVAR

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    bexp2                          shift and go to state 112
    exp                            shift and go to state 66
    term                           shift and go to state 43
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 41

state 89

    (56) andor -> AND .

    INTEGER         reduce using rule 56 (andor -> AND .)
    FLOAT           reduce using rule 56 (andor -> AND .)
    CHAR            reduce using rule 56 (andor -> AND .)
    TRUE            reduce using rule 56 (andor -> AND .)
    FALSE           reduce using rule 56 (andor -> AND .)
    IDVAR           reduce using rule 56 (andor -> AND .)


state 90

    (57) andor -> OR .

    INTEGER         reduce using rule 57 (andor -> OR .)
    FLOAT           reduce using rule 57 (andor -> OR .)
    CHAR            reduce using rule 57 (andor -> OR .)
    TRUE            reduce using rule 57 (andor -> OR .)
    FALSE           reduce using rule 57 (andor -> OR .)
    IDVAR           reduce using rule 57 (andor -> OR .)


state 91

    (50) bexp2 -> bexp2 rln . exp
    (23) exp -> . exp PLUS term
    (24) exp -> . exp MINUS term
    (25) exp -> . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) bval -> . TRUE
    (40) bval -> . FALSE
    (41) var -> . IDVAR

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    exp                            shift and go to state 113
    term                           shift and go to state 43
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 41

state 92

    (52) rln -> DEQUAL .

    INTEGER         reduce using rule 52 (rln -> DEQUAL .)
    FLOAT           reduce using rule 52 (rln -> DEQUAL .)
    CHAR            reduce using rule 52 (rln -> DEQUAL .)
    TRUE            reduce using rule 52 (rln -> DEQUAL .)
    FALSE           reduce using rule 52 (rln -> DEQUAL .)
    IDVAR           reduce using rule 52 (rln -> DEQUAL .)


state 93

    (53) rln -> GTHEN .

    INTEGER         reduce using rule 53 (rln -> GTHEN .)
    FLOAT           reduce using rule 53 (rln -> GTHEN .)
    CHAR            reduce using rule 53 (rln -> GTHEN .)
    TRUE            reduce using rule 53 (rln -> GTHEN .)
    FALSE           reduce using rule 53 (rln -> GTHEN .)
    IDVAR           reduce using rule 53 (rln -> GTHEN .)


state 94

    (54) rln -> LTHEN .

    INTEGER         reduce using rule 54 (rln -> LTHEN .)
    FLOAT           reduce using rule 54 (rln -> LTHEN .)
    CHAR            reduce using rule 54 (rln -> LTHEN .)
    TRUE            reduce using rule 54 (rln -> LTHEN .)
    FALSE           reduce using rule 54 (rln -> LTHEN .)
    IDVAR           reduce using rule 54 (rln -> LTHEN .)


state 95

    (55) rln -> NOT .

    INTEGER         reduce using rule 55 (rln -> NOT .)
    FLOAT           reduce using rule 55 (rln -> NOT .)
    CHAR            reduce using rule 55 (rln -> NOT .)
    TRUE            reduce using rule 55 (rln -> NOT .)
    FALSE           reduce using rule 55 (rln -> NOT .)
    IDVAR           reduce using rule 55 (rln -> NOT .)


state 96

    (16) ifsts -> IF LPAREN bexp RPAREN . lcb line rcb elsests
    (18) lcb -> . LCB

    LCB             shift and go to state 107

    lcb                            shift and go to state 114

state 97

    (63) nline -> dtype LBB RBB IDVAR EQUAL . arrt SCOLON
    (65) arrt -> . var
    (66) arrt -> . LCB dws RCB
    (41) var -> . IDVAR

    LCB             shift and go to state 117
    IDVAR           shift and go to state 7

    arrt                           shift and go to state 115
    var                            shift and go to state 116

state 98

    (36) varval -> var LBB exp . RBB
    (23) exp -> exp . PLUS term
    (24) exp -> exp . MINUS term

    RBB             shift and go to state 118
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74


state 99

    (23) exp -> exp PLUS term .
    (26) term -> term . MUL fact
    (27) term -> term . DIV fact
    (28) term -> term . MOD fact

    RBB             reduce using rule 23 (exp -> exp PLUS term .)
    PLUS            reduce using rule 23 (exp -> exp PLUS term .)
    MINUS           reduce using rule 23 (exp -> exp PLUS term .)
    RPAREN          reduce using rule 23 (exp -> exp PLUS term .)
    DEQUAL          reduce using rule 23 (exp -> exp PLUS term .)
    GTHEN           reduce using rule 23 (exp -> exp PLUS term .)
    LTHEN           reduce using rule 23 (exp -> exp PLUS term .)
    NOT             reduce using rule 23 (exp -> exp PLUS term .)
    AND             reduce using rule 23 (exp -> exp PLUS term .)
    OR              reduce using rule 23 (exp -> exp PLUS term .)
    SCOLON          reduce using rule 23 (exp -> exp PLUS term .)
    MUL             shift and go to state 75
    DIV             shift and go to state 76
    MOD             shift and go to state 77


state 100

    (24) exp -> exp MINUS term .
    (26) term -> term . MUL fact
    (27) term -> term . DIV fact
    (28) term -> term . MOD fact

    RBB             reduce using rule 24 (exp -> exp MINUS term .)
    PLUS            reduce using rule 24 (exp -> exp MINUS term .)
    MINUS           reduce using rule 24 (exp -> exp MINUS term .)
    RPAREN          reduce using rule 24 (exp -> exp MINUS term .)
    DEQUAL          reduce using rule 24 (exp -> exp MINUS term .)
    GTHEN           reduce using rule 24 (exp -> exp MINUS term .)
    LTHEN           reduce using rule 24 (exp -> exp MINUS term .)
    NOT             reduce using rule 24 (exp -> exp MINUS term .)
    AND             reduce using rule 24 (exp -> exp MINUS term .)
    OR              reduce using rule 24 (exp -> exp MINUS term .)
    SCOLON          reduce using rule 24 (exp -> exp MINUS term .)
    MUL             shift and go to state 75
    DIV             shift and go to state 76
    MOD             shift and go to state 77


state 101

    (26) term -> term MUL fact .

    MUL             reduce using rule 26 (term -> term MUL fact .)
    DIV             reduce using rule 26 (term -> term MUL fact .)
    MOD             reduce using rule 26 (term -> term MUL fact .)
    RBB             reduce using rule 26 (term -> term MUL fact .)
    PLUS            reduce using rule 26 (term -> term MUL fact .)
    MINUS           reduce using rule 26 (term -> term MUL fact .)
    RPAREN          reduce using rule 26 (term -> term MUL fact .)
    DEQUAL          reduce using rule 26 (term -> term MUL fact .)
    GTHEN           reduce using rule 26 (term -> term MUL fact .)
    LTHEN           reduce using rule 26 (term -> term MUL fact .)
    NOT             reduce using rule 26 (term -> term MUL fact .)
    AND             reduce using rule 26 (term -> term MUL fact .)
    OR              reduce using rule 26 (term -> term MUL fact .)
    SCOLON          reduce using rule 26 (term -> term MUL fact .)


state 102

    (27) term -> term DIV fact .

    MUL             reduce using rule 27 (term -> term DIV fact .)
    DIV             reduce using rule 27 (term -> term DIV fact .)
    MOD             reduce using rule 27 (term -> term DIV fact .)
    RBB             reduce using rule 27 (term -> term DIV fact .)
    PLUS            reduce using rule 27 (term -> term DIV fact .)
    MINUS           reduce using rule 27 (term -> term DIV fact .)
    RPAREN          reduce using rule 27 (term -> term DIV fact .)
    DEQUAL          reduce using rule 27 (term -> term DIV fact .)
    GTHEN           reduce using rule 27 (term -> term DIV fact .)
    LTHEN           reduce using rule 27 (term -> term DIV fact .)
    NOT             reduce using rule 27 (term -> term DIV fact .)
    AND             reduce using rule 27 (term -> term DIV fact .)
    OR              reduce using rule 27 (term -> term DIV fact .)
    SCOLON          reduce using rule 27 (term -> term DIV fact .)


state 103

    (28) term -> term MOD fact .

    MUL             reduce using rule 28 (term -> term MOD fact .)
    DIV             reduce using rule 28 (term -> term MOD fact .)
    MOD             reduce using rule 28 (term -> term MOD fact .)
    RBB             reduce using rule 28 (term -> term MOD fact .)
    PLUS            reduce using rule 28 (term -> term MOD fact .)
    MINUS           reduce using rule 28 (term -> term MOD fact .)
    RPAREN          reduce using rule 28 (term -> term MOD fact .)
    DEQUAL          reduce using rule 28 (term -> term MOD fact .)
    GTHEN           reduce using rule 28 (term -> term MOD fact .)
    LTHEN           reduce using rule 28 (term -> term MOD fact .)
    NOT             reduce using rule 28 (term -> term MOD fact .)
    AND             reduce using rule 28 (term -> term MOD fact .)
    OR              reduce using rule 28 (term -> term MOD fact .)
    SCOLON          reduce using rule 28 (term -> term MOD fact .)


state 104

    (6) nline -> STR IDVAR EQUAL strvar SCOLON .

    STR             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    BOOL            reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    RETURN          reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    EXIT            reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    PRINT           reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    FOR             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    WHILE           reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    INT             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    FLT             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    CHR             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    IF              reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    IDVAR           reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    $end            reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    RCB             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)


state 105

    (64) nline -> STR LBB RBB IDVAR EQUAL . arrt SCOLON
    (65) arrt -> . var
    (66) arrt -> . LCB dws RCB
    (41) var -> . IDVAR

    LCB             shift and go to state 117
    IDVAR           shift and go to state 7

    arrt                           shift and go to state 119
    var                            shift and go to state 116

state 106

    (7) nline -> BOOL MAIN LPAREN RPAREN lcb . line rcb
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN lcb line rcb
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb
    (15) nline -> . WHILE LPAREN bexp RPAREN lcb line rcb
    (63) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (64) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (42) dtype -> . INT
    (43) dtype -> . FLT
    (44) dtype -> . CHR
    (45) dtype -> . BOOL
    (61) fline -> . dtype numexp
    (62) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN lcb line rcb elsests
    (22) numexp -> . assign SCOLON
    (59) assign -> . assvar EQUAL exp
    (60) assign -> . assvar EQUAL STRING
    (37) assvar -> . var
    (38) assvar -> . var LBB exp RBB
    (41) var -> . IDVAR

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 120
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19
    assvar                         shift and go to state 21

state 107

    (18) lcb -> LCB .

    STR             reduce using rule 18 (lcb -> LCB .)
    BOOL            reduce using rule 18 (lcb -> LCB .)
    RETURN          reduce using rule 18 (lcb -> LCB .)
    EXIT            reduce using rule 18 (lcb -> LCB .)
    PRINT           reduce using rule 18 (lcb -> LCB .)
    FOR             reduce using rule 18 (lcb -> LCB .)
    WHILE           reduce using rule 18 (lcb -> LCB .)
    INT             reduce using rule 18 (lcb -> LCB .)
    FLT             reduce using rule 18 (lcb -> LCB .)
    CHR             reduce using rule 18 (lcb -> LCB .)
    IF              reduce using rule 18 (lcb -> LCB .)
    IDVAR           reduce using rule 18 (lcb -> LCB .)


state 108

    (8) nline -> RETURN LPAREN bval RPAREN SCOLON .

    STR             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    BOOL            reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    RETURN          reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    EXIT            reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    PRINT           reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    FOR             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    WHILE           reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    INT             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    FLT             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    CHR             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    IF              reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    IDVAR           reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    $end            reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    RCB             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)


state 109

    (11) nline -> PRINT LPAREN pline RPAREN SCOLON .

    STR             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    BOOL            reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    RETURN          reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    EXIT            reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    PRINT           reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    FOR             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    WHILE           reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    INT             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    FLT             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    CHR             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    IF              reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    IDVAR           reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    $end            reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    RCB             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)


state 110

    (14) nline -> FOR LPAREN fline bexp SCOLON . assign RPAREN lcb line rcb
    (59) assign -> . assvar EQUAL exp
    (60) assign -> . assvar EQUAL STRING
    (37) assvar -> . var
    (38) assvar -> . var LBB exp RBB
    (41) var -> . IDVAR

    IDVAR           shift and go to state 7

    assign                         shift and go to state 121
    assvar                         shift and go to state 21
    var                            shift and go to state 4

state 111

    (15) nline -> WHILE LPAREN bexp RPAREN lcb . line rcb
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN lcb line rcb
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb
    (15) nline -> . WHILE LPAREN bexp RPAREN lcb line rcb
    (63) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (64) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (42) dtype -> . INT
    (43) dtype -> . FLT
    (44) dtype -> . CHR
    (45) dtype -> . BOOL
    (61) fline -> . dtype numexp
    (62) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN lcb line rcb elsests
    (22) numexp -> . assign SCOLON
    (59) assign -> . assvar EQUAL exp
    (60) assign -> . assvar EQUAL STRING
    (37) assvar -> . var
    (38) assvar -> . var LBB exp RBB
    (41) var -> . IDVAR

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 122
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19
    assvar                         shift and go to state 21

state 112

    (48) bexp -> bexp andor bexp2 .
    (50) bexp2 -> bexp2 . rln exp
    (52) rln -> . DEQUAL
    (53) rln -> . GTHEN
    (54) rln -> . LTHEN
    (55) rln -> . NOT

    RPAREN          reduce using rule 48 (bexp -> bexp andor bexp2 .)
    AND             reduce using rule 48 (bexp -> bexp andor bexp2 .)
    OR              reduce using rule 48 (bexp -> bexp andor bexp2 .)
    SCOLON          reduce using rule 48 (bexp -> bexp andor bexp2 .)
    DEQUAL          shift and go to state 92
    GTHEN           shift and go to state 93
    LTHEN           shift and go to state 94
    NOT             shift and go to state 95

    rln                            shift and go to state 91

state 113

    (50) bexp2 -> bexp2 rln exp .
    (23) exp -> exp . PLUS term
    (24) exp -> exp . MINUS term

    DEQUAL          reduce using rule 50 (bexp2 -> bexp2 rln exp .)
    GTHEN           reduce using rule 50 (bexp2 -> bexp2 rln exp .)
    LTHEN           reduce using rule 50 (bexp2 -> bexp2 rln exp .)
    NOT             reduce using rule 50 (bexp2 -> bexp2 rln exp .)
    RPAREN          reduce using rule 50 (bexp2 -> bexp2 rln exp .)
    AND             reduce using rule 50 (bexp2 -> bexp2 rln exp .)
    OR              reduce using rule 50 (bexp2 -> bexp2 rln exp .)
    SCOLON          reduce using rule 50 (bexp2 -> bexp2 rln exp .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74


state 114

    (16) ifsts -> IF LPAREN bexp RPAREN lcb . line rcb elsests
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN lcb line rcb
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb
    (15) nline -> . WHILE LPAREN bexp RPAREN lcb line rcb
    (63) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (64) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (42) dtype -> . INT
    (43) dtype -> . FLT
    (44) dtype -> . CHR
    (45) dtype -> . BOOL
    (61) fline -> . dtype numexp
    (62) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN lcb line rcb elsests
    (22) numexp -> . assign SCOLON
    (59) assign -> . assvar EQUAL exp
    (60) assign -> . assvar EQUAL STRING
    (37) assvar -> . var
    (38) assvar -> . var LBB exp RBB
    (41) var -> . IDVAR

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 123
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19
    assvar                         shift and go to state 21

state 115

    (63) nline -> dtype LBB RBB IDVAR EQUAL arrt . SCOLON

    SCOLON          shift and go to state 124


state 116

    (65) arrt -> var .

    SCOLON          reduce using rule 65 (arrt -> var .)


state 117

    (66) arrt -> LCB . dws RCB
    (67) dws -> . factarr COM dws
    (68) dws -> . factarr
    (69) factarr -> . fact
    (70) factarr -> . STRING
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) bval -> . TRUE
    (40) bval -> . FALSE
    (41) var -> . IDVAR

    STRING          shift and go to state 128
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    dws                            shift and go to state 125
    factarr                        shift and go to state 126
    fact                           shift and go to state 127
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 41

state 118

    (36) varval -> var LBB exp RBB .

    MUL             reduce using rule 36 (varval -> var LBB exp RBB .)
    DIV             reduce using rule 36 (varval -> var LBB exp RBB .)
    MOD             reduce using rule 36 (varval -> var LBB exp RBB .)
    RBB             reduce using rule 36 (varval -> var LBB exp RBB .)
    PLUS            reduce using rule 36 (varval -> var LBB exp RBB .)
    MINUS           reduce using rule 36 (varval -> var LBB exp RBB .)
    RPAREN          reduce using rule 36 (varval -> var LBB exp RBB .)
    DEQUAL          reduce using rule 36 (varval -> var LBB exp RBB .)
    GTHEN           reduce using rule 36 (varval -> var LBB exp RBB .)
    LTHEN           reduce using rule 36 (varval -> var LBB exp RBB .)
    NOT             reduce using rule 36 (varval -> var LBB exp RBB .)
    AND             reduce using rule 36 (varval -> var LBB exp RBB .)
    OR              reduce using rule 36 (varval -> var LBB exp RBB .)
    SCOLON          reduce using rule 36 (varval -> var LBB exp RBB .)
    COM             reduce using rule 36 (varval -> var LBB exp RBB .)
    RCB             reduce using rule 36 (varval -> var LBB exp RBB .)


state 119

    (64) nline -> STR LBB RBB IDVAR EQUAL arrt . SCOLON

    SCOLON          shift and go to state 129


state 120

    (7) nline -> BOOL MAIN LPAREN RPAREN lcb line . rcb
    (17) rcb -> . RCB

    RCB             shift and go to state 131

    rcb                            shift and go to state 130

state 121

    (14) nline -> FOR LPAREN fline bexp SCOLON assign . RPAREN lcb line rcb

    RPAREN          shift and go to state 132


state 122

    (15) nline -> WHILE LPAREN bexp RPAREN lcb line . rcb
    (17) rcb -> . RCB

    RCB             shift and go to state 131

    rcb                            shift and go to state 133

state 123

    (16) ifsts -> IF LPAREN bexp RPAREN lcb line . rcb elsests
    (17) rcb -> . RCB

    RCB             shift and go to state 131

    rcb                            shift and go to state 134

state 124

    (63) nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .

    STR             reduce using rule 63 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    BOOL            reduce using rule 63 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    RETURN          reduce using rule 63 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    EXIT            reduce using rule 63 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    PRINT           reduce using rule 63 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    FOR             reduce using rule 63 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    WHILE           reduce using rule 63 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    INT             reduce using rule 63 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    FLT             reduce using rule 63 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    CHR             reduce using rule 63 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    IF              reduce using rule 63 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    IDVAR           reduce using rule 63 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    $end            reduce using rule 63 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    RCB             reduce using rule 63 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)


state 125

    (66) arrt -> LCB dws . RCB

    RCB             shift and go to state 135


state 126

    (67) dws -> factarr . COM dws
    (68) dws -> factarr .

    COM             shift and go to state 136
    RCB             reduce using rule 68 (dws -> factarr .)


state 127

    (69) factarr -> fact .

    COM             reduce using rule 69 (factarr -> fact .)
    RCB             reduce using rule 69 (factarr -> fact .)


state 128

    (70) factarr -> STRING .

    COM             reduce using rule 70 (factarr -> STRING .)
    RCB             reduce using rule 70 (factarr -> STRING .)


state 129

    (64) nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .

    STR             reduce using rule 64 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    BOOL            reduce using rule 64 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    RETURN          reduce using rule 64 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    EXIT            reduce using rule 64 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    PRINT           reduce using rule 64 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    FOR             reduce using rule 64 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    WHILE           reduce using rule 64 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    INT             reduce using rule 64 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    FLT             reduce using rule 64 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    CHR             reduce using rule 64 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    IF              reduce using rule 64 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    IDVAR           reduce using rule 64 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    $end            reduce using rule 64 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    RCB             reduce using rule 64 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)


state 130

    (7) nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .

    STR             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    BOOL            reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    RETURN          reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    EXIT            reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    PRINT           reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    FOR             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    WHILE           reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    INT             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    FLT             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    CHR             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    IF              reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    IDVAR           reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    $end            reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    RCB             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)


state 131

    (17) rcb -> RCB .

    STR             reduce using rule 17 (rcb -> RCB .)
    BOOL            reduce using rule 17 (rcb -> RCB .)
    RETURN          reduce using rule 17 (rcb -> RCB .)
    EXIT            reduce using rule 17 (rcb -> RCB .)
    PRINT           reduce using rule 17 (rcb -> RCB .)
    FOR             reduce using rule 17 (rcb -> RCB .)
    WHILE           reduce using rule 17 (rcb -> RCB .)
    INT             reduce using rule 17 (rcb -> RCB .)
    FLT             reduce using rule 17 (rcb -> RCB .)
    CHR             reduce using rule 17 (rcb -> RCB .)
    IF              reduce using rule 17 (rcb -> RCB .)
    IDVAR           reduce using rule 17 (rcb -> RCB .)
    $end            reduce using rule 17 (rcb -> RCB .)
    RCB             reduce using rule 17 (rcb -> RCB .)
    ELSE            reduce using rule 17 (rcb -> RCB .)


state 132

    (14) nline -> FOR LPAREN fline bexp SCOLON assign RPAREN . lcb line rcb
    (18) lcb -> . LCB

    LCB             shift and go to state 107

    lcb                            shift and go to state 137

state 133

    (15) nline -> WHILE LPAREN bexp RPAREN lcb line rcb .

    STR             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    BOOL            reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    RETURN          reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    EXIT            reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    PRINT           reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    FOR             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    WHILE           reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    INT             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    FLT             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    CHR             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    IF              reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    IDVAR           reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    $end            reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    RCB             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)


state 134

    (16) ifsts -> IF LPAREN bexp RPAREN lcb line rcb . elsests
    (19) elsests -> . ELSE lcb line rcb
    (20) elsests -> . ELSE ifsts
    (21) elsests -> . empty
    (58) empty -> .

    ELSE            shift and go to state 139
    STR             reduce using rule 58 (empty -> .)
    BOOL            reduce using rule 58 (empty -> .)
    RETURN          reduce using rule 58 (empty -> .)
    EXIT            reduce using rule 58 (empty -> .)
    PRINT           reduce using rule 58 (empty -> .)
    FOR             reduce using rule 58 (empty -> .)
    WHILE           reduce using rule 58 (empty -> .)
    INT             reduce using rule 58 (empty -> .)
    FLT             reduce using rule 58 (empty -> .)
    CHR             reduce using rule 58 (empty -> .)
    IF              reduce using rule 58 (empty -> .)
    IDVAR           reduce using rule 58 (empty -> .)
    $end            reduce using rule 58 (empty -> .)
    RCB             reduce using rule 58 (empty -> .)

    elsests                        shift and go to state 138
    empty                          shift and go to state 140

state 135

    (66) arrt -> LCB dws RCB .

    SCOLON          reduce using rule 66 (arrt -> LCB dws RCB .)


state 136

    (67) dws -> factarr COM . dws
    (67) dws -> . factarr COM dws
    (68) dws -> . factarr
    (69) factarr -> . fact
    (70) factarr -> . STRING
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) varval -> . var LBB exp RBB
    (39) bval -> . TRUE
    (40) bval -> . FALSE
    (41) var -> . IDVAR

    STRING          shift and go to state 128
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    factarr                        shift and go to state 126
    dws                            shift and go to state 141
    fact                           shift and go to state 127
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 41

state 137

    (14) nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb . line rcb
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN lcb line rcb
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb
    (15) nline -> . WHILE LPAREN bexp RPAREN lcb line rcb
    (63) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (64) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (42) dtype -> . INT
    (43) dtype -> . FLT
    (44) dtype -> . CHR
    (45) dtype -> . BOOL
    (61) fline -> . dtype numexp
    (62) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN lcb line rcb elsests
    (22) numexp -> . assign SCOLON
    (59) assign -> . assvar EQUAL exp
    (60) assign -> . assvar EQUAL STRING
    (37) assvar -> . var
    (38) assvar -> . var LBB exp RBB
    (41) var -> . IDVAR

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    fline                          shift and go to state 6
    assign                         shift and go to state 14
    line                           shift and go to state 142
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    ifsts                          shift and go to state 10
    numexp                         shift and go to state 19
    assvar                         shift and go to state 21

state 138

    (16) ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .

    STR             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    BOOL            reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    RETURN          reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    EXIT            reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    PRINT           reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    FOR             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    WHILE           reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    INT             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    FLT             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    CHR             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    IF              reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    IDVAR           reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    $end            reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    RCB             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)


state 139

    (19) elsests -> ELSE . lcb line rcb
    (20) elsests -> ELSE . ifsts
    (18) lcb -> . LCB
    (16) ifsts -> . IF LPAREN bexp RPAREN lcb line rcb elsests

    LCB             shift and go to state 107
    IF              shift and go to state 20

    lcb                            shift and go to state 143
    ifsts                          shift and go to state 144

state 140

    (21) elsests -> empty .

    STR             reduce using rule 21 (elsests -> empty .)
    BOOL            reduce using rule 21 (elsests -> empty .)
    RETURN          reduce using rule 21 (elsests -> empty .)
    EXIT            reduce using rule 21 (elsests -> empty .)
    PRINT           reduce using rule 21 (elsests -> empty .)
    FOR             reduce using rule 21 (elsests -> empty .)
    WHILE           reduce using rule 21 (elsests -> empty .)
    INT             reduce using rule 21 (elsests -> empty .)
    FLT             reduce using rule 21 (elsests -> empty .)
    CHR             reduce using rule 21 (elsests -> empty .)
    IF              reduce using rule 21 (elsests -> empty .)
    IDVAR           reduce using rule 21 (elsests -> empty .)
    $end            reduce using rule 21 (elsests -> empty .)
    RCB             reduce using rule 21 (elsests -> empty .)


state 141

    (67) dws -> factarr COM dws .

    RCB             reduce using rule 67 (dws -> factarr COM dws .)


state 142

    (14) nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line . rcb
    (17) rcb -> . RCB

    RCB             shift and go to state 131

    rcb                            shift and go to state 145

state 143

    (19) elsests -> ELSE lcb . line rcb
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN lcb line rcb
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb
    (15) nline -> . WHILE LPAREN bexp RPAREN lcb line rcb
    (63) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (64) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (42) dtype -> . INT
    (43) dtype -> . FLT
    (44) dtype -> . CHR
    (45) dtype -> . BOOL
    (61) fline -> . dtype numexp
    (62) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN lcb line rcb elsests
    (22) numexp -> . assign SCOLON
    (59) assign -> . assvar EQUAL exp
    (60) assign -> . assvar EQUAL STRING
    (37) assvar -> . var
    (38) assvar -> . var LBB exp RBB
    (41) var -> . IDVAR

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 146
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19
    assvar                         shift and go to state 21

state 144

    (20) elsests -> ELSE ifsts .

    STR             reduce using rule 20 (elsests -> ELSE ifsts .)
    BOOL            reduce using rule 20 (elsests -> ELSE ifsts .)
    RETURN          reduce using rule 20 (elsests -> ELSE ifsts .)
    EXIT            reduce using rule 20 (elsests -> ELSE ifsts .)
    PRINT           reduce using rule 20 (elsests -> ELSE ifsts .)
    FOR             reduce using rule 20 (elsests -> ELSE ifsts .)
    WHILE           reduce using rule 20 (elsests -> ELSE ifsts .)
    INT             reduce using rule 20 (elsests -> ELSE ifsts .)
    FLT             reduce using rule 20 (elsests -> ELSE ifsts .)
    CHR             reduce using rule 20 (elsests -> ELSE ifsts .)
    IF              reduce using rule 20 (elsests -> ELSE ifsts .)
    IDVAR           reduce using rule 20 (elsests -> ELSE ifsts .)
    $end            reduce using rule 20 (elsests -> ELSE ifsts .)
    RCB             reduce using rule 20 (elsests -> ELSE ifsts .)


state 145

    (14) nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .

    STR             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    BOOL            reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    RETURN          reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    EXIT            reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    PRINT           reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    FOR             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    WHILE           reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    INT             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    FLT             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    CHR             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    IF              reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    IDVAR           reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    $end            reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    RCB             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)


state 146

    (19) elsests -> ELSE lcb line . rcb
    (17) rcb -> . RCB

    RCB             shift and go to state 131

    rcb                            shift and go to state 147

state 147

    (19) elsests -> ELSE lcb line rcb .

    STR             reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    BOOL            reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    RETURN          reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    EXIT            reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    PRINT           reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    FOR             reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    WHILE           reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    INT             reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    FLT             reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    CHR             reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    IF              reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    IDVAR           reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    $end            reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    RCB             reduce using rule 19 (elsests -> ELSE lcb line rcb .)

