Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    VOID
    WITH

Grammar

Rule 0     S' -> line
Rule 1     line -> nline line
Rule 2     line -> nline
Rule 3     nline -> dtype var SCOLON
Rule 4     nline -> STR var SCOLON
Rule 5     nline -> fline
Rule 6     nline -> STR IDVAR EQUAL strvar SCOLON
Rule 7     nline -> BOOL MAIN LPAREN RPAREN lcb line rcb
Rule 8     nline -> RETURN LPAREN bval RPAREN SCOLON
Rule 9     nline -> ifsts
Rule 10    nline -> EXIT LPAREN RPAREN SCOLON
Rule 11    nline -> PRINT LPAREN pline RPAREN SCOLON
Rule 12    pline -> exp
Rule 13    pline -> STRING
Rule 14    nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb
Rule 15    nline -> WHILE LPAREN bexp RPAREN lcb line rcb
Rule 16    ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests
Rule 17    rcb -> RCB
Rule 18    lcb -> LCB
Rule 19    elsests -> ELSE lcb line rcb
Rule 20    elsests -> ELSE ifsts
Rule 21    elsests -> empty
Rule 22    numexp -> assign SCOLON
Rule 23    exp -> exp PLUS term
Rule 24    exp -> exp MINUS term
Rule 25    exp -> term
Rule 26    term -> term MUL fact
Rule 27    term -> term DIV fact
Rule 28    term -> term MOD fact
Rule 29    term -> fact
Rule 30    fact -> INTEGER
Rule 31    fact -> FLOAT
Rule 32    fact -> varval
Rule 33    fact -> bval
Rule 34    fact -> CHAR
Rule 35    varval -> var
Rule 36    bval -> TRUE
Rule 37    bval -> FALSE
Rule 38    var -> IDVAR
Rule 39    var -> IDVAR LBB INTEGER RBB
Rule 40    var -> IDVAR LBB IDVAR RBB
Rule 41    dtype -> INT
Rule 42    dtype -> FLT
Rule 43    dtype -> CHR
Rule 44    dtype -> BOOL
Rule 45    strvar -> STRING
Rule 46    strvar -> varval
Rule 47    bexp -> bexp andor bexp2
Rule 48    bexp -> bexp2
Rule 49    bexp2 -> bexp2 rln exp
Rule 50    bexp2 -> exp
Rule 51    rln -> DEQUAL
Rule 52    rln -> GTHEN
Rule 53    rln -> LTHEN
Rule 54    rln -> NOT
Rule 55    andor -> AND
Rule 56    andor -> OR
Rule 57    empty -> <empty>
Rule 58    assign -> var EQUAL exp
Rule 59    assign -> var EQUAL STRING
Rule 60    fline -> dtype numexp
Rule 61    fline -> numexp
Rule 62    nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON
Rule 63    nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON
Rule 64    arrt -> var
Rule 65    arrt -> LCB dws RCB
Rule 66    dws -> factarr COM dws
Rule 67    dws -> factarr
Rule 68    factarr -> fact
Rule 69    factarr -> STRING

Terminals, with rules where they appear

AND                  : 55
BOOL                 : 7 44
CHAR                 : 34
CHR                  : 43
COM                  : 66
COMMENT              : 
DEQUAL               : 51
DIV                  : 27
ELSE                 : 19 20
EQUAL                : 6 58 59 62 63
EXIT                 : 10
FALSE                : 37
FLOAT                : 31
FLT                  : 42
FOR                  : 14
GTHEN                : 52
IDVAR                : 6 38 39 40 40 62 63
IF                   : 16
INT                  : 41
INTEGER              : 30 39
LBB                  : 39 40 62 63
LCB                  : 18 65
LPAREN               : 7 8 10 11 14 15 16
LTHEN                : 53
MAIN                 : 7
MINUS                : 24
MOD                  : 28
MUL                  : 26
NOT                  : 54
OR                   : 56
PLUS                 : 23
PRINT                : 11
RBB                  : 39 40 62 63
RCB                  : 17 65
RETURN               : 8
RPAREN               : 7 8 10 11 14 15 16
SCOLON               : 3 4 6 8 10 11 14 22 62 63
STR                  : 4 6 63
STRING               : 13 45 59 69
TRUE                 : 36
VOID                 : 
WHILE                : 15
WITH                 : 
error                : 

Nonterminals, with rules where they appear

andor                : 47
arrt                 : 62 63
assign               : 14 22
bexp                 : 14 15 16 47
bexp2                : 47 48 49
bval                 : 8 33
dtype                : 3 60 62
dws                  : 65 66
elsests              : 16
empty                : 21
exp                  : 12 23 24 49 50 58
fact                 : 26 27 28 29 68
factarr              : 66 67
fline                : 5 14
ifsts                : 9 20
lcb                  : 7 14 15 16 19
line                 : 1 7 14 15 16 19 0
nline                : 1 2
numexp               : 60 61
pline                : 11
rcb                  : 7 14 15 16 19
rln                  : 49
strvar               : 6
term                 : 23 24 25 26 27 28
var                  : 3 4 35 58 59 64
varval               : 32 46

Parsing method: LALR

state 0

    (0) S' -> . line
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN lcb line rcb
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb
    (15) nline -> . WHILE LPAREN bexp RPAREN lcb line rcb
    (62) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (63) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (41) dtype -> . INT
    (42) dtype -> . FLT
    (43) dtype -> . CHR
    (44) dtype -> . BOOL
    (60) fline -> . dtype numexp
    (61) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN lcb line rcb elsests
    (22) numexp -> . assign SCOLON
    (58) assign -> . var EQUAL exp
    (59) assign -> . var EQUAL STRING
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 1
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19

state 1

    (0) S' -> line .



state 2

    (1) line -> nline . line
    (2) line -> nline .
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN lcb line rcb
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb
    (15) nline -> . WHILE LPAREN bexp RPAREN lcb line rcb
    (62) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (63) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (41) dtype -> . INT
    (42) dtype -> . FLT
    (43) dtype -> . CHR
    (44) dtype -> . BOOL
    (60) fline -> . dtype numexp
    (61) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN lcb line rcb elsests
    (22) numexp -> . assign SCOLON
    (58) assign -> . var EQUAL exp
    (59) assign -> . var EQUAL STRING
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    $end            reduce using rule 2 (line -> nline .)
    RCB             reduce using rule 2 (line -> nline .)
    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    nline                          shift and go to state 2
    line                           shift and go to state 21
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19

state 3

    (3) nline -> dtype . var SCOLON
    (62) nline -> dtype . LBB RBB IDVAR EQUAL arrt SCOLON
    (60) fline -> dtype . numexp
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB
    (22) numexp -> . assign SCOLON
    (58) assign -> . var EQUAL exp
    (59) assign -> . var EQUAL STRING

    LBB             shift and go to state 23
    IDVAR           shift and go to state 7

    var                            shift and go to state 22
    numexp                         shift and go to state 24
    assign                         shift and go to state 14

state 4

    (58) assign -> var . EQUAL exp
    (59) assign -> var . EQUAL STRING

    EQUAL           shift and go to state 25


state 5

    (4) nline -> STR . var SCOLON
    (6) nline -> STR . IDVAR EQUAL strvar SCOLON
    (63) nline -> STR . LBB RBB IDVAR EQUAL arrt SCOLON
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    IDVAR           shift and go to state 27
    LBB             shift and go to state 28

    var                            shift and go to state 26

state 6

    (5) nline -> fline .

    STR             reduce using rule 5 (nline -> fline .)
    BOOL            reduce using rule 5 (nline -> fline .)
    RETURN          reduce using rule 5 (nline -> fline .)
    EXIT            reduce using rule 5 (nline -> fline .)
    PRINT           reduce using rule 5 (nline -> fline .)
    FOR             reduce using rule 5 (nline -> fline .)
    WHILE           reduce using rule 5 (nline -> fline .)
    INT             reduce using rule 5 (nline -> fline .)
    FLT             reduce using rule 5 (nline -> fline .)
    CHR             reduce using rule 5 (nline -> fline .)
    IF              reduce using rule 5 (nline -> fline .)
    IDVAR           reduce using rule 5 (nline -> fline .)
    $end            reduce using rule 5 (nline -> fline .)
    RCB             reduce using rule 5 (nline -> fline .)


state 7

    (38) var -> IDVAR .
    (39) var -> IDVAR . LBB INTEGER RBB
    (40) var -> IDVAR . LBB IDVAR RBB

    EQUAL           reduce using rule 38 (var -> IDVAR .)
    SCOLON          reduce using rule 38 (var -> IDVAR .)
    MUL             reduce using rule 38 (var -> IDVAR .)
    DIV             reduce using rule 38 (var -> IDVAR .)
    MOD             reduce using rule 38 (var -> IDVAR .)
    PLUS            reduce using rule 38 (var -> IDVAR .)
    MINUS           reduce using rule 38 (var -> IDVAR .)
    RPAREN          reduce using rule 38 (var -> IDVAR .)
    DEQUAL          reduce using rule 38 (var -> IDVAR .)
    GTHEN           reduce using rule 38 (var -> IDVAR .)
    LTHEN           reduce using rule 38 (var -> IDVAR .)
    NOT             reduce using rule 38 (var -> IDVAR .)
    AND             reduce using rule 38 (var -> IDVAR .)
    OR              reduce using rule 38 (var -> IDVAR .)
    COM             reduce using rule 38 (var -> IDVAR .)
    RCB             reduce using rule 38 (var -> IDVAR .)
    LBB             shift and go to state 29


state 8

    (7) nline -> BOOL . MAIN LPAREN RPAREN lcb line rcb
    (44) dtype -> BOOL .

    MAIN            shift and go to state 30
    LBB             reduce using rule 44 (dtype -> BOOL .)
    IDVAR           reduce using rule 44 (dtype -> BOOL .)


state 9

    (8) nline -> RETURN . LPAREN bval RPAREN SCOLON

    LPAREN          shift and go to state 31


state 10

    (9) nline -> ifsts .

    STR             reduce using rule 9 (nline -> ifsts .)
    BOOL            reduce using rule 9 (nline -> ifsts .)
    RETURN          reduce using rule 9 (nline -> ifsts .)
    EXIT            reduce using rule 9 (nline -> ifsts .)
    PRINT           reduce using rule 9 (nline -> ifsts .)
    FOR             reduce using rule 9 (nline -> ifsts .)
    WHILE           reduce using rule 9 (nline -> ifsts .)
    INT             reduce using rule 9 (nline -> ifsts .)
    FLT             reduce using rule 9 (nline -> ifsts .)
    CHR             reduce using rule 9 (nline -> ifsts .)
    IF              reduce using rule 9 (nline -> ifsts .)
    IDVAR           reduce using rule 9 (nline -> ifsts .)
    $end            reduce using rule 9 (nline -> ifsts .)
    RCB             reduce using rule 9 (nline -> ifsts .)


state 11

    (10) nline -> EXIT . LPAREN RPAREN SCOLON

    LPAREN          shift and go to state 32


state 12

    (11) nline -> PRINT . LPAREN pline RPAREN SCOLON

    LPAREN          shift and go to state 33


state 13

    (14) nline -> FOR . LPAREN fline bexp SCOLON assign RPAREN lcb line rcb

    LPAREN          shift and go to state 34


state 14

    (22) numexp -> assign . SCOLON

    SCOLON          shift and go to state 35


state 15

    (15) nline -> WHILE . LPAREN bexp RPAREN lcb line rcb

    LPAREN          shift and go to state 36


state 16

    (41) dtype -> INT .

    LBB             reduce using rule 41 (dtype -> INT .)
    IDVAR           reduce using rule 41 (dtype -> INT .)


state 17

    (42) dtype -> FLT .

    LBB             reduce using rule 42 (dtype -> FLT .)
    IDVAR           reduce using rule 42 (dtype -> FLT .)


state 18

    (43) dtype -> CHR .

    LBB             reduce using rule 43 (dtype -> CHR .)
    IDVAR           reduce using rule 43 (dtype -> CHR .)


state 19

    (61) fline -> numexp .

    STR             reduce using rule 61 (fline -> numexp .)
    BOOL            reduce using rule 61 (fline -> numexp .)
    RETURN          reduce using rule 61 (fline -> numexp .)
    EXIT            reduce using rule 61 (fline -> numexp .)
    PRINT           reduce using rule 61 (fline -> numexp .)
    FOR             reduce using rule 61 (fline -> numexp .)
    WHILE           reduce using rule 61 (fline -> numexp .)
    INT             reduce using rule 61 (fline -> numexp .)
    FLT             reduce using rule 61 (fline -> numexp .)
    CHR             reduce using rule 61 (fline -> numexp .)
    IF              reduce using rule 61 (fline -> numexp .)
    IDVAR           reduce using rule 61 (fline -> numexp .)
    $end            reduce using rule 61 (fline -> numexp .)
    RCB             reduce using rule 61 (fline -> numexp .)
    INTEGER         reduce using rule 61 (fline -> numexp .)
    FLOAT           reduce using rule 61 (fline -> numexp .)
    CHAR            reduce using rule 61 (fline -> numexp .)
    TRUE            reduce using rule 61 (fline -> numexp .)
    FALSE           reduce using rule 61 (fline -> numexp .)


state 20

    (16) ifsts -> IF . LPAREN bexp RPAREN lcb line rcb elsests

    LPAREN          shift and go to state 37


state 21

    (1) line -> nline line .

    $end            reduce using rule 1 (line -> nline line .)
    RCB             reduce using rule 1 (line -> nline line .)


state 22

    (3) nline -> dtype var . SCOLON
    (58) assign -> var . EQUAL exp
    (59) assign -> var . EQUAL STRING

    SCOLON          shift and go to state 38
    EQUAL           shift and go to state 25


state 23

    (62) nline -> dtype LBB . RBB IDVAR EQUAL arrt SCOLON

    RBB             shift and go to state 39


state 24

    (60) fline -> dtype numexp .

    STR             reduce using rule 60 (fline -> dtype numexp .)
    BOOL            reduce using rule 60 (fline -> dtype numexp .)
    RETURN          reduce using rule 60 (fline -> dtype numexp .)
    EXIT            reduce using rule 60 (fline -> dtype numexp .)
    PRINT           reduce using rule 60 (fline -> dtype numexp .)
    FOR             reduce using rule 60 (fline -> dtype numexp .)
    WHILE           reduce using rule 60 (fline -> dtype numexp .)
    INT             reduce using rule 60 (fline -> dtype numexp .)
    FLT             reduce using rule 60 (fline -> dtype numexp .)
    CHR             reduce using rule 60 (fline -> dtype numexp .)
    IF              reduce using rule 60 (fline -> dtype numexp .)
    IDVAR           reduce using rule 60 (fline -> dtype numexp .)
    $end            reduce using rule 60 (fline -> dtype numexp .)
    RCB             reduce using rule 60 (fline -> dtype numexp .)
    INTEGER         reduce using rule 60 (fline -> dtype numexp .)
    FLOAT           reduce using rule 60 (fline -> dtype numexp .)
    CHAR            reduce using rule 60 (fline -> dtype numexp .)
    TRUE            reduce using rule 60 (fline -> dtype numexp .)
    FALSE           reduce using rule 60 (fline -> dtype numexp .)


state 25

    (58) assign -> var EQUAL . exp
    (59) assign -> var EQUAL . STRING
    (23) exp -> . exp PLUS term
    (24) exp -> . exp MINUS term
    (25) exp -> . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) bval -> . TRUE
    (37) bval -> . FALSE
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    STRING          shift and go to state 42
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    var                            shift and go to state 40
    exp                            shift and go to state 41
    term                           shift and go to state 43
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48

state 26

    (4) nline -> STR var . SCOLON

    SCOLON          shift and go to state 52


state 27

    (6) nline -> STR IDVAR . EQUAL strvar SCOLON
    (38) var -> IDVAR .
    (39) var -> IDVAR . LBB INTEGER RBB
    (40) var -> IDVAR . LBB IDVAR RBB

    EQUAL           shift and go to state 53
    SCOLON          reduce using rule 38 (var -> IDVAR .)
    LBB             shift and go to state 29


state 28

    (63) nline -> STR LBB . RBB IDVAR EQUAL arrt SCOLON

    RBB             shift and go to state 54


state 29

    (39) var -> IDVAR LBB . INTEGER RBB
    (40) var -> IDVAR LBB . IDVAR RBB

    INTEGER         shift and go to state 56
    IDVAR           shift and go to state 55


state 30

    (7) nline -> BOOL MAIN . LPAREN RPAREN lcb line rcb

    LPAREN          shift and go to state 57


state 31

    (8) nline -> RETURN LPAREN . bval RPAREN SCOLON
    (36) bval -> . TRUE
    (37) bval -> . FALSE

    TRUE            shift and go to state 50
    FALSE           shift and go to state 51

    bval                           shift and go to state 58

state 32

    (10) nline -> EXIT LPAREN . RPAREN SCOLON

    RPAREN          shift and go to state 59


state 33

    (11) nline -> PRINT LPAREN . pline RPAREN SCOLON
    (12) pline -> . exp
    (13) pline -> . STRING
    (23) exp -> . exp PLUS term
    (24) exp -> . exp MINUS term
    (25) exp -> . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) bval -> . TRUE
    (37) bval -> . FALSE
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    STRING          shift and go to state 62
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    pline                          shift and go to state 60
    exp                            shift and go to state 61
    term                           shift and go to state 43
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 34

    (14) nline -> FOR LPAREN . fline bexp SCOLON assign RPAREN lcb line rcb
    (60) fline -> . dtype numexp
    (61) fline -> . numexp
    (41) dtype -> . INT
    (42) dtype -> . FLT
    (43) dtype -> . CHR
    (44) dtype -> . BOOL
    (22) numexp -> . assign SCOLON
    (58) assign -> . var EQUAL exp
    (59) assign -> . var EQUAL STRING
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    BOOL            shift and go to state 65
    IDVAR           shift and go to state 7

    fline                          shift and go to state 63
    assign                         shift and go to state 14
    dtype                          shift and go to state 64
    numexp                         shift and go to state 19
    var                            shift and go to state 4

state 35

    (22) numexp -> assign SCOLON .

    STR             reduce using rule 22 (numexp -> assign SCOLON .)
    BOOL            reduce using rule 22 (numexp -> assign SCOLON .)
    RETURN          reduce using rule 22 (numexp -> assign SCOLON .)
    EXIT            reduce using rule 22 (numexp -> assign SCOLON .)
    PRINT           reduce using rule 22 (numexp -> assign SCOLON .)
    FOR             reduce using rule 22 (numexp -> assign SCOLON .)
    WHILE           reduce using rule 22 (numexp -> assign SCOLON .)
    INT             reduce using rule 22 (numexp -> assign SCOLON .)
    FLT             reduce using rule 22 (numexp -> assign SCOLON .)
    CHR             reduce using rule 22 (numexp -> assign SCOLON .)
    IF              reduce using rule 22 (numexp -> assign SCOLON .)
    IDVAR           reduce using rule 22 (numexp -> assign SCOLON .)
    $end            reduce using rule 22 (numexp -> assign SCOLON .)
    RCB             reduce using rule 22 (numexp -> assign SCOLON .)
    INTEGER         reduce using rule 22 (numexp -> assign SCOLON .)
    FLOAT           reduce using rule 22 (numexp -> assign SCOLON .)
    CHAR            reduce using rule 22 (numexp -> assign SCOLON .)
    TRUE            reduce using rule 22 (numexp -> assign SCOLON .)
    FALSE           reduce using rule 22 (numexp -> assign SCOLON .)


state 36

    (15) nline -> WHILE LPAREN . bexp RPAREN lcb line rcb
    (47) bexp -> . bexp andor bexp2
    (48) bexp -> . bexp2
    (49) bexp2 -> . bexp2 rln exp
    (50) bexp2 -> . exp
    (23) exp -> . exp PLUS term
    (24) exp -> . exp MINUS term
    (25) exp -> . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) bval -> . TRUE
    (37) bval -> . FALSE
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    bexp                           shift and go to state 66
    bexp2                          shift and go to state 67
    exp                            shift and go to state 68
    term                           shift and go to state 43
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 37

    (16) ifsts -> IF LPAREN . bexp RPAREN lcb line rcb elsests
    (47) bexp -> . bexp andor bexp2
    (48) bexp -> . bexp2
    (49) bexp2 -> . bexp2 rln exp
    (50) bexp2 -> . exp
    (23) exp -> . exp PLUS term
    (24) exp -> . exp MINUS term
    (25) exp -> . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) bval -> . TRUE
    (37) bval -> . FALSE
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    bexp                           shift and go to state 69
    bexp2                          shift and go to state 67
    exp                            shift and go to state 68
    term                           shift and go to state 43
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 38

    (3) nline -> dtype var SCOLON .

    STR             reduce using rule 3 (nline -> dtype var SCOLON .)
    BOOL            reduce using rule 3 (nline -> dtype var SCOLON .)
    RETURN          reduce using rule 3 (nline -> dtype var SCOLON .)
    EXIT            reduce using rule 3 (nline -> dtype var SCOLON .)
    PRINT           reduce using rule 3 (nline -> dtype var SCOLON .)
    FOR             reduce using rule 3 (nline -> dtype var SCOLON .)
    WHILE           reduce using rule 3 (nline -> dtype var SCOLON .)
    INT             reduce using rule 3 (nline -> dtype var SCOLON .)
    FLT             reduce using rule 3 (nline -> dtype var SCOLON .)
    CHR             reduce using rule 3 (nline -> dtype var SCOLON .)
    IF              reduce using rule 3 (nline -> dtype var SCOLON .)
    IDVAR           reduce using rule 3 (nline -> dtype var SCOLON .)
    $end            reduce using rule 3 (nline -> dtype var SCOLON .)
    RCB             reduce using rule 3 (nline -> dtype var SCOLON .)


state 39

    (62) nline -> dtype LBB RBB . IDVAR EQUAL arrt SCOLON

    IDVAR           shift and go to state 70


state 40

    (35) varval -> var .

    MUL             reduce using rule 35 (varval -> var .)
    DIV             reduce using rule 35 (varval -> var .)
    MOD             reduce using rule 35 (varval -> var .)
    PLUS            reduce using rule 35 (varval -> var .)
    MINUS           reduce using rule 35 (varval -> var .)
    SCOLON          reduce using rule 35 (varval -> var .)
    RPAREN          reduce using rule 35 (varval -> var .)
    DEQUAL          reduce using rule 35 (varval -> var .)
    GTHEN           reduce using rule 35 (varval -> var .)
    LTHEN           reduce using rule 35 (varval -> var .)
    NOT             reduce using rule 35 (varval -> var .)
    AND             reduce using rule 35 (varval -> var .)
    OR              reduce using rule 35 (varval -> var .)
    COM             reduce using rule 35 (varval -> var .)
    RCB             reduce using rule 35 (varval -> var .)


state 41

    (58) assign -> var EQUAL exp .
    (23) exp -> exp . PLUS term
    (24) exp -> exp . MINUS term

    SCOLON          reduce using rule 58 (assign -> var EQUAL exp .)
    RPAREN          reduce using rule 58 (assign -> var EQUAL exp .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72


state 42

    (59) assign -> var EQUAL STRING .

    SCOLON          reduce using rule 59 (assign -> var EQUAL STRING .)
    RPAREN          reduce using rule 59 (assign -> var EQUAL STRING .)


state 43

    (25) exp -> term .
    (26) term -> term . MUL fact
    (27) term -> term . DIV fact
    (28) term -> term . MOD fact

    PLUS            reduce using rule 25 (exp -> term .)
    MINUS           reduce using rule 25 (exp -> term .)
    SCOLON          reduce using rule 25 (exp -> term .)
    RPAREN          reduce using rule 25 (exp -> term .)
    DEQUAL          reduce using rule 25 (exp -> term .)
    GTHEN           reduce using rule 25 (exp -> term .)
    LTHEN           reduce using rule 25 (exp -> term .)
    NOT             reduce using rule 25 (exp -> term .)
    AND             reduce using rule 25 (exp -> term .)
    OR              reduce using rule 25 (exp -> term .)
    MUL             shift and go to state 73
    DIV             shift and go to state 74
    MOD             shift and go to state 75


state 44

    (29) term -> fact .

    MUL             reduce using rule 29 (term -> fact .)
    DIV             reduce using rule 29 (term -> fact .)
    MOD             reduce using rule 29 (term -> fact .)
    PLUS            reduce using rule 29 (term -> fact .)
    MINUS           reduce using rule 29 (term -> fact .)
    SCOLON          reduce using rule 29 (term -> fact .)
    RPAREN          reduce using rule 29 (term -> fact .)
    DEQUAL          reduce using rule 29 (term -> fact .)
    GTHEN           reduce using rule 29 (term -> fact .)
    LTHEN           reduce using rule 29 (term -> fact .)
    NOT             reduce using rule 29 (term -> fact .)
    AND             reduce using rule 29 (term -> fact .)
    OR              reduce using rule 29 (term -> fact .)


state 45

    (30) fact -> INTEGER .

    MUL             reduce using rule 30 (fact -> INTEGER .)
    DIV             reduce using rule 30 (fact -> INTEGER .)
    MOD             reduce using rule 30 (fact -> INTEGER .)
    PLUS            reduce using rule 30 (fact -> INTEGER .)
    MINUS           reduce using rule 30 (fact -> INTEGER .)
    SCOLON          reduce using rule 30 (fact -> INTEGER .)
    RPAREN          reduce using rule 30 (fact -> INTEGER .)
    DEQUAL          reduce using rule 30 (fact -> INTEGER .)
    GTHEN           reduce using rule 30 (fact -> INTEGER .)
    LTHEN           reduce using rule 30 (fact -> INTEGER .)
    NOT             reduce using rule 30 (fact -> INTEGER .)
    AND             reduce using rule 30 (fact -> INTEGER .)
    OR              reduce using rule 30 (fact -> INTEGER .)
    COM             reduce using rule 30 (fact -> INTEGER .)
    RCB             reduce using rule 30 (fact -> INTEGER .)


state 46

    (31) fact -> FLOAT .

    MUL             reduce using rule 31 (fact -> FLOAT .)
    DIV             reduce using rule 31 (fact -> FLOAT .)
    MOD             reduce using rule 31 (fact -> FLOAT .)
    PLUS            reduce using rule 31 (fact -> FLOAT .)
    MINUS           reduce using rule 31 (fact -> FLOAT .)
    SCOLON          reduce using rule 31 (fact -> FLOAT .)
    RPAREN          reduce using rule 31 (fact -> FLOAT .)
    DEQUAL          reduce using rule 31 (fact -> FLOAT .)
    GTHEN           reduce using rule 31 (fact -> FLOAT .)
    LTHEN           reduce using rule 31 (fact -> FLOAT .)
    NOT             reduce using rule 31 (fact -> FLOAT .)
    AND             reduce using rule 31 (fact -> FLOAT .)
    OR              reduce using rule 31 (fact -> FLOAT .)
    COM             reduce using rule 31 (fact -> FLOAT .)
    RCB             reduce using rule 31 (fact -> FLOAT .)


state 47

    (32) fact -> varval .

    MUL             reduce using rule 32 (fact -> varval .)
    DIV             reduce using rule 32 (fact -> varval .)
    MOD             reduce using rule 32 (fact -> varval .)
    PLUS            reduce using rule 32 (fact -> varval .)
    MINUS           reduce using rule 32 (fact -> varval .)
    SCOLON          reduce using rule 32 (fact -> varval .)
    RPAREN          reduce using rule 32 (fact -> varval .)
    DEQUAL          reduce using rule 32 (fact -> varval .)
    GTHEN           reduce using rule 32 (fact -> varval .)
    LTHEN           reduce using rule 32 (fact -> varval .)
    NOT             reduce using rule 32 (fact -> varval .)
    AND             reduce using rule 32 (fact -> varval .)
    OR              reduce using rule 32 (fact -> varval .)
    COM             reduce using rule 32 (fact -> varval .)
    RCB             reduce using rule 32 (fact -> varval .)


state 48

    (33) fact -> bval .

    MUL             reduce using rule 33 (fact -> bval .)
    DIV             reduce using rule 33 (fact -> bval .)
    MOD             reduce using rule 33 (fact -> bval .)
    PLUS            reduce using rule 33 (fact -> bval .)
    MINUS           reduce using rule 33 (fact -> bval .)
    SCOLON          reduce using rule 33 (fact -> bval .)
    RPAREN          reduce using rule 33 (fact -> bval .)
    DEQUAL          reduce using rule 33 (fact -> bval .)
    GTHEN           reduce using rule 33 (fact -> bval .)
    LTHEN           reduce using rule 33 (fact -> bval .)
    NOT             reduce using rule 33 (fact -> bval .)
    AND             reduce using rule 33 (fact -> bval .)
    OR              reduce using rule 33 (fact -> bval .)
    COM             reduce using rule 33 (fact -> bval .)
    RCB             reduce using rule 33 (fact -> bval .)


state 49

    (34) fact -> CHAR .

    MUL             reduce using rule 34 (fact -> CHAR .)
    DIV             reduce using rule 34 (fact -> CHAR .)
    MOD             reduce using rule 34 (fact -> CHAR .)
    PLUS            reduce using rule 34 (fact -> CHAR .)
    MINUS           reduce using rule 34 (fact -> CHAR .)
    SCOLON          reduce using rule 34 (fact -> CHAR .)
    RPAREN          reduce using rule 34 (fact -> CHAR .)
    DEQUAL          reduce using rule 34 (fact -> CHAR .)
    GTHEN           reduce using rule 34 (fact -> CHAR .)
    LTHEN           reduce using rule 34 (fact -> CHAR .)
    NOT             reduce using rule 34 (fact -> CHAR .)
    AND             reduce using rule 34 (fact -> CHAR .)
    OR              reduce using rule 34 (fact -> CHAR .)
    COM             reduce using rule 34 (fact -> CHAR .)
    RCB             reduce using rule 34 (fact -> CHAR .)


state 50

    (36) bval -> TRUE .

    MUL             reduce using rule 36 (bval -> TRUE .)
    DIV             reduce using rule 36 (bval -> TRUE .)
    MOD             reduce using rule 36 (bval -> TRUE .)
    PLUS            reduce using rule 36 (bval -> TRUE .)
    MINUS           reduce using rule 36 (bval -> TRUE .)
    SCOLON          reduce using rule 36 (bval -> TRUE .)
    RPAREN          reduce using rule 36 (bval -> TRUE .)
    DEQUAL          reduce using rule 36 (bval -> TRUE .)
    GTHEN           reduce using rule 36 (bval -> TRUE .)
    LTHEN           reduce using rule 36 (bval -> TRUE .)
    NOT             reduce using rule 36 (bval -> TRUE .)
    AND             reduce using rule 36 (bval -> TRUE .)
    OR              reduce using rule 36 (bval -> TRUE .)
    COM             reduce using rule 36 (bval -> TRUE .)
    RCB             reduce using rule 36 (bval -> TRUE .)


state 51

    (37) bval -> FALSE .

    MUL             reduce using rule 37 (bval -> FALSE .)
    DIV             reduce using rule 37 (bval -> FALSE .)
    MOD             reduce using rule 37 (bval -> FALSE .)
    PLUS            reduce using rule 37 (bval -> FALSE .)
    MINUS           reduce using rule 37 (bval -> FALSE .)
    SCOLON          reduce using rule 37 (bval -> FALSE .)
    RPAREN          reduce using rule 37 (bval -> FALSE .)
    DEQUAL          reduce using rule 37 (bval -> FALSE .)
    GTHEN           reduce using rule 37 (bval -> FALSE .)
    LTHEN           reduce using rule 37 (bval -> FALSE .)
    NOT             reduce using rule 37 (bval -> FALSE .)
    AND             reduce using rule 37 (bval -> FALSE .)
    OR              reduce using rule 37 (bval -> FALSE .)
    COM             reduce using rule 37 (bval -> FALSE .)
    RCB             reduce using rule 37 (bval -> FALSE .)


state 52

    (4) nline -> STR var SCOLON .

    STR             reduce using rule 4 (nline -> STR var SCOLON .)
    BOOL            reduce using rule 4 (nline -> STR var SCOLON .)
    RETURN          reduce using rule 4 (nline -> STR var SCOLON .)
    EXIT            reduce using rule 4 (nline -> STR var SCOLON .)
    PRINT           reduce using rule 4 (nline -> STR var SCOLON .)
    FOR             reduce using rule 4 (nline -> STR var SCOLON .)
    WHILE           reduce using rule 4 (nline -> STR var SCOLON .)
    INT             reduce using rule 4 (nline -> STR var SCOLON .)
    FLT             reduce using rule 4 (nline -> STR var SCOLON .)
    CHR             reduce using rule 4 (nline -> STR var SCOLON .)
    IF              reduce using rule 4 (nline -> STR var SCOLON .)
    IDVAR           reduce using rule 4 (nline -> STR var SCOLON .)
    $end            reduce using rule 4 (nline -> STR var SCOLON .)
    RCB             reduce using rule 4 (nline -> STR var SCOLON .)


state 53

    (6) nline -> STR IDVAR EQUAL . strvar SCOLON
    (45) strvar -> . STRING
    (46) strvar -> . varval
    (35) varval -> . var
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    STRING          shift and go to state 77
    IDVAR           shift and go to state 7

    strvar                         shift and go to state 76
    varval                         shift and go to state 78
    var                            shift and go to state 40

state 54

    (63) nline -> STR LBB RBB . IDVAR EQUAL arrt SCOLON

    IDVAR           shift and go to state 79


state 55

    (40) var -> IDVAR LBB IDVAR . RBB

    RBB             shift and go to state 80


state 56

    (39) var -> IDVAR LBB INTEGER . RBB

    RBB             shift and go to state 81


state 57

    (7) nline -> BOOL MAIN LPAREN . RPAREN lcb line rcb

    RPAREN          shift and go to state 82


state 58

    (8) nline -> RETURN LPAREN bval . RPAREN SCOLON

    RPAREN          shift and go to state 83


state 59

    (10) nline -> EXIT LPAREN RPAREN . SCOLON

    SCOLON          shift and go to state 84


state 60

    (11) nline -> PRINT LPAREN pline . RPAREN SCOLON

    RPAREN          shift and go to state 85


state 61

    (12) pline -> exp .
    (23) exp -> exp . PLUS term
    (24) exp -> exp . MINUS term

    RPAREN          reduce using rule 12 (pline -> exp .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72


state 62

    (13) pline -> STRING .

    RPAREN          reduce using rule 13 (pline -> STRING .)


state 63

    (14) nline -> FOR LPAREN fline . bexp SCOLON assign RPAREN lcb line rcb
    (47) bexp -> . bexp andor bexp2
    (48) bexp -> . bexp2
    (49) bexp2 -> . bexp2 rln exp
    (50) bexp2 -> . exp
    (23) exp -> . exp PLUS term
    (24) exp -> . exp MINUS term
    (25) exp -> . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) bval -> . TRUE
    (37) bval -> . FALSE
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    bexp                           shift and go to state 86
    bexp2                          shift and go to state 67
    exp                            shift and go to state 68
    term                           shift and go to state 43
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 64

    (60) fline -> dtype . numexp
    (22) numexp -> . assign SCOLON
    (58) assign -> . var EQUAL exp
    (59) assign -> . var EQUAL STRING
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    IDVAR           shift and go to state 7

    numexp                         shift and go to state 24
    assign                         shift and go to state 14
    var                            shift and go to state 4

state 65

    (44) dtype -> BOOL .

    IDVAR           reduce using rule 44 (dtype -> BOOL .)


state 66

    (15) nline -> WHILE LPAREN bexp . RPAREN lcb line rcb
    (47) bexp -> bexp . andor bexp2
    (55) andor -> . AND
    (56) andor -> . OR

    RPAREN          shift and go to state 87
    AND             shift and go to state 89
    OR              shift and go to state 90

    andor                          shift and go to state 88

state 67

    (48) bexp -> bexp2 .
    (49) bexp2 -> bexp2 . rln exp
    (51) rln -> . DEQUAL
    (52) rln -> . GTHEN
    (53) rln -> . LTHEN
    (54) rln -> . NOT

    RPAREN          reduce using rule 48 (bexp -> bexp2 .)
    AND             reduce using rule 48 (bexp -> bexp2 .)
    OR              reduce using rule 48 (bexp -> bexp2 .)
    SCOLON          reduce using rule 48 (bexp -> bexp2 .)
    DEQUAL          shift and go to state 92
    GTHEN           shift and go to state 93
    LTHEN           shift and go to state 94
    NOT             shift and go to state 95

    rln                            shift and go to state 91

state 68

    (50) bexp2 -> exp .
    (23) exp -> exp . PLUS term
    (24) exp -> exp . MINUS term

    DEQUAL          reduce using rule 50 (bexp2 -> exp .)
    GTHEN           reduce using rule 50 (bexp2 -> exp .)
    LTHEN           reduce using rule 50 (bexp2 -> exp .)
    NOT             reduce using rule 50 (bexp2 -> exp .)
    RPAREN          reduce using rule 50 (bexp2 -> exp .)
    AND             reduce using rule 50 (bexp2 -> exp .)
    OR              reduce using rule 50 (bexp2 -> exp .)
    SCOLON          reduce using rule 50 (bexp2 -> exp .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72


state 69

    (16) ifsts -> IF LPAREN bexp . RPAREN lcb line rcb elsests
    (47) bexp -> bexp . andor bexp2
    (55) andor -> . AND
    (56) andor -> . OR

    RPAREN          shift and go to state 96
    AND             shift and go to state 89
    OR              shift and go to state 90

    andor                          shift and go to state 88

state 70

    (62) nline -> dtype LBB RBB IDVAR . EQUAL arrt SCOLON

    EQUAL           shift and go to state 97


state 71

    (23) exp -> exp PLUS . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) bval -> . TRUE
    (37) bval -> . FALSE
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    term                           shift and go to state 98
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 72

    (24) exp -> exp MINUS . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) bval -> . TRUE
    (37) bval -> . FALSE
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    term                           shift and go to state 99
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 73

    (26) term -> term MUL . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) bval -> . TRUE
    (37) bval -> . FALSE
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    fact                           shift and go to state 100
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 74

    (27) term -> term DIV . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) bval -> . TRUE
    (37) bval -> . FALSE
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    fact                           shift and go to state 101
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 75

    (28) term -> term MOD . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) bval -> . TRUE
    (37) bval -> . FALSE
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    fact                           shift and go to state 102
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 76

    (6) nline -> STR IDVAR EQUAL strvar . SCOLON

    SCOLON          shift and go to state 103


state 77

    (45) strvar -> STRING .

    SCOLON          reduce using rule 45 (strvar -> STRING .)


state 78

    (46) strvar -> varval .

    SCOLON          reduce using rule 46 (strvar -> varval .)


state 79

    (63) nline -> STR LBB RBB IDVAR . EQUAL arrt SCOLON

    EQUAL           shift and go to state 104


state 80

    (40) var -> IDVAR LBB IDVAR RBB .

    EQUAL           reduce using rule 40 (var -> IDVAR LBB IDVAR RBB .)
    SCOLON          reduce using rule 40 (var -> IDVAR LBB IDVAR RBB .)
    MUL             reduce using rule 40 (var -> IDVAR LBB IDVAR RBB .)
    DIV             reduce using rule 40 (var -> IDVAR LBB IDVAR RBB .)
    MOD             reduce using rule 40 (var -> IDVAR LBB IDVAR RBB .)
    PLUS            reduce using rule 40 (var -> IDVAR LBB IDVAR RBB .)
    MINUS           reduce using rule 40 (var -> IDVAR LBB IDVAR RBB .)
    RPAREN          reduce using rule 40 (var -> IDVAR LBB IDVAR RBB .)
    DEQUAL          reduce using rule 40 (var -> IDVAR LBB IDVAR RBB .)
    GTHEN           reduce using rule 40 (var -> IDVAR LBB IDVAR RBB .)
    LTHEN           reduce using rule 40 (var -> IDVAR LBB IDVAR RBB .)
    NOT             reduce using rule 40 (var -> IDVAR LBB IDVAR RBB .)
    AND             reduce using rule 40 (var -> IDVAR LBB IDVAR RBB .)
    OR              reduce using rule 40 (var -> IDVAR LBB IDVAR RBB .)
    COM             reduce using rule 40 (var -> IDVAR LBB IDVAR RBB .)
    RCB             reduce using rule 40 (var -> IDVAR LBB IDVAR RBB .)


state 81

    (39) var -> IDVAR LBB INTEGER RBB .

    EQUAL           reduce using rule 39 (var -> IDVAR LBB INTEGER RBB .)
    SCOLON          reduce using rule 39 (var -> IDVAR LBB INTEGER RBB .)
    MUL             reduce using rule 39 (var -> IDVAR LBB INTEGER RBB .)
    DIV             reduce using rule 39 (var -> IDVAR LBB INTEGER RBB .)
    MOD             reduce using rule 39 (var -> IDVAR LBB INTEGER RBB .)
    PLUS            reduce using rule 39 (var -> IDVAR LBB INTEGER RBB .)
    MINUS           reduce using rule 39 (var -> IDVAR LBB INTEGER RBB .)
    RPAREN          reduce using rule 39 (var -> IDVAR LBB INTEGER RBB .)
    DEQUAL          reduce using rule 39 (var -> IDVAR LBB INTEGER RBB .)
    GTHEN           reduce using rule 39 (var -> IDVAR LBB INTEGER RBB .)
    LTHEN           reduce using rule 39 (var -> IDVAR LBB INTEGER RBB .)
    NOT             reduce using rule 39 (var -> IDVAR LBB INTEGER RBB .)
    AND             reduce using rule 39 (var -> IDVAR LBB INTEGER RBB .)
    OR              reduce using rule 39 (var -> IDVAR LBB INTEGER RBB .)
    COM             reduce using rule 39 (var -> IDVAR LBB INTEGER RBB .)
    RCB             reduce using rule 39 (var -> IDVAR LBB INTEGER RBB .)


state 82

    (7) nline -> BOOL MAIN LPAREN RPAREN . lcb line rcb
    (18) lcb -> . LCB

    LCB             shift and go to state 106

    lcb                            shift and go to state 105

state 83

    (8) nline -> RETURN LPAREN bval RPAREN . SCOLON

    SCOLON          shift and go to state 107


state 84

    (10) nline -> EXIT LPAREN RPAREN SCOLON .

    STR             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    BOOL            reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    RETURN          reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    EXIT            reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    PRINT           reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    FOR             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    WHILE           reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    INT             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    FLT             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    CHR             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    IF              reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    IDVAR           reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    $end            reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    RCB             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)


state 85

    (11) nline -> PRINT LPAREN pline RPAREN . SCOLON

    SCOLON          shift and go to state 108


state 86

    (14) nline -> FOR LPAREN fline bexp . SCOLON assign RPAREN lcb line rcb
    (47) bexp -> bexp . andor bexp2
    (55) andor -> . AND
    (56) andor -> . OR

    SCOLON          shift and go to state 109
    AND             shift and go to state 89
    OR              shift and go to state 90

    andor                          shift and go to state 88

state 87

    (15) nline -> WHILE LPAREN bexp RPAREN . lcb line rcb
    (18) lcb -> . LCB

    LCB             shift and go to state 106

    lcb                            shift and go to state 110

state 88

    (47) bexp -> bexp andor . bexp2
    (49) bexp2 -> . bexp2 rln exp
    (50) bexp2 -> . exp
    (23) exp -> . exp PLUS term
    (24) exp -> . exp MINUS term
    (25) exp -> . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) bval -> . TRUE
    (37) bval -> . FALSE
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    bexp2                          shift and go to state 111
    exp                            shift and go to state 68
    term                           shift and go to state 43
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 89

    (55) andor -> AND .

    INTEGER         reduce using rule 55 (andor -> AND .)
    FLOAT           reduce using rule 55 (andor -> AND .)
    CHAR            reduce using rule 55 (andor -> AND .)
    TRUE            reduce using rule 55 (andor -> AND .)
    FALSE           reduce using rule 55 (andor -> AND .)
    IDVAR           reduce using rule 55 (andor -> AND .)


state 90

    (56) andor -> OR .

    INTEGER         reduce using rule 56 (andor -> OR .)
    FLOAT           reduce using rule 56 (andor -> OR .)
    CHAR            reduce using rule 56 (andor -> OR .)
    TRUE            reduce using rule 56 (andor -> OR .)
    FALSE           reduce using rule 56 (andor -> OR .)
    IDVAR           reduce using rule 56 (andor -> OR .)


state 91

    (49) bexp2 -> bexp2 rln . exp
    (23) exp -> . exp PLUS term
    (24) exp -> . exp MINUS term
    (25) exp -> . term
    (26) term -> . term MUL fact
    (27) term -> . term DIV fact
    (28) term -> . term MOD fact
    (29) term -> . fact
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) bval -> . TRUE
    (37) bval -> . FALSE
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    exp                            shift and go to state 112
    term                           shift and go to state 43
    fact                           shift and go to state 44
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 92

    (51) rln -> DEQUAL .

    INTEGER         reduce using rule 51 (rln -> DEQUAL .)
    FLOAT           reduce using rule 51 (rln -> DEQUAL .)
    CHAR            reduce using rule 51 (rln -> DEQUAL .)
    TRUE            reduce using rule 51 (rln -> DEQUAL .)
    FALSE           reduce using rule 51 (rln -> DEQUAL .)
    IDVAR           reduce using rule 51 (rln -> DEQUAL .)


state 93

    (52) rln -> GTHEN .

    INTEGER         reduce using rule 52 (rln -> GTHEN .)
    FLOAT           reduce using rule 52 (rln -> GTHEN .)
    CHAR            reduce using rule 52 (rln -> GTHEN .)
    TRUE            reduce using rule 52 (rln -> GTHEN .)
    FALSE           reduce using rule 52 (rln -> GTHEN .)
    IDVAR           reduce using rule 52 (rln -> GTHEN .)


state 94

    (53) rln -> LTHEN .

    INTEGER         reduce using rule 53 (rln -> LTHEN .)
    FLOAT           reduce using rule 53 (rln -> LTHEN .)
    CHAR            reduce using rule 53 (rln -> LTHEN .)
    TRUE            reduce using rule 53 (rln -> LTHEN .)
    FALSE           reduce using rule 53 (rln -> LTHEN .)
    IDVAR           reduce using rule 53 (rln -> LTHEN .)


state 95

    (54) rln -> NOT .

    INTEGER         reduce using rule 54 (rln -> NOT .)
    FLOAT           reduce using rule 54 (rln -> NOT .)
    CHAR            reduce using rule 54 (rln -> NOT .)
    TRUE            reduce using rule 54 (rln -> NOT .)
    FALSE           reduce using rule 54 (rln -> NOT .)
    IDVAR           reduce using rule 54 (rln -> NOT .)


state 96

    (16) ifsts -> IF LPAREN bexp RPAREN . lcb line rcb elsests
    (18) lcb -> . LCB

    LCB             shift and go to state 106

    lcb                            shift and go to state 113

state 97

    (62) nline -> dtype LBB RBB IDVAR EQUAL . arrt SCOLON
    (64) arrt -> . var
    (65) arrt -> . LCB dws RCB
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    LCB             shift and go to state 116
    IDVAR           shift and go to state 7

    arrt                           shift and go to state 114
    var                            shift and go to state 115

state 98

    (23) exp -> exp PLUS term .
    (26) term -> term . MUL fact
    (27) term -> term . DIV fact
    (28) term -> term . MOD fact

    PLUS            reduce using rule 23 (exp -> exp PLUS term .)
    MINUS           reduce using rule 23 (exp -> exp PLUS term .)
    SCOLON          reduce using rule 23 (exp -> exp PLUS term .)
    RPAREN          reduce using rule 23 (exp -> exp PLUS term .)
    DEQUAL          reduce using rule 23 (exp -> exp PLUS term .)
    GTHEN           reduce using rule 23 (exp -> exp PLUS term .)
    LTHEN           reduce using rule 23 (exp -> exp PLUS term .)
    NOT             reduce using rule 23 (exp -> exp PLUS term .)
    AND             reduce using rule 23 (exp -> exp PLUS term .)
    OR              reduce using rule 23 (exp -> exp PLUS term .)
    MUL             shift and go to state 73
    DIV             shift and go to state 74
    MOD             shift and go to state 75


state 99

    (24) exp -> exp MINUS term .
    (26) term -> term . MUL fact
    (27) term -> term . DIV fact
    (28) term -> term . MOD fact

    PLUS            reduce using rule 24 (exp -> exp MINUS term .)
    MINUS           reduce using rule 24 (exp -> exp MINUS term .)
    SCOLON          reduce using rule 24 (exp -> exp MINUS term .)
    RPAREN          reduce using rule 24 (exp -> exp MINUS term .)
    DEQUAL          reduce using rule 24 (exp -> exp MINUS term .)
    GTHEN           reduce using rule 24 (exp -> exp MINUS term .)
    LTHEN           reduce using rule 24 (exp -> exp MINUS term .)
    NOT             reduce using rule 24 (exp -> exp MINUS term .)
    AND             reduce using rule 24 (exp -> exp MINUS term .)
    OR              reduce using rule 24 (exp -> exp MINUS term .)
    MUL             shift and go to state 73
    DIV             shift and go to state 74
    MOD             shift and go to state 75


state 100

    (26) term -> term MUL fact .

    MUL             reduce using rule 26 (term -> term MUL fact .)
    DIV             reduce using rule 26 (term -> term MUL fact .)
    MOD             reduce using rule 26 (term -> term MUL fact .)
    PLUS            reduce using rule 26 (term -> term MUL fact .)
    MINUS           reduce using rule 26 (term -> term MUL fact .)
    SCOLON          reduce using rule 26 (term -> term MUL fact .)
    RPAREN          reduce using rule 26 (term -> term MUL fact .)
    DEQUAL          reduce using rule 26 (term -> term MUL fact .)
    GTHEN           reduce using rule 26 (term -> term MUL fact .)
    LTHEN           reduce using rule 26 (term -> term MUL fact .)
    NOT             reduce using rule 26 (term -> term MUL fact .)
    AND             reduce using rule 26 (term -> term MUL fact .)
    OR              reduce using rule 26 (term -> term MUL fact .)


state 101

    (27) term -> term DIV fact .

    MUL             reduce using rule 27 (term -> term DIV fact .)
    DIV             reduce using rule 27 (term -> term DIV fact .)
    MOD             reduce using rule 27 (term -> term DIV fact .)
    PLUS            reduce using rule 27 (term -> term DIV fact .)
    MINUS           reduce using rule 27 (term -> term DIV fact .)
    SCOLON          reduce using rule 27 (term -> term DIV fact .)
    RPAREN          reduce using rule 27 (term -> term DIV fact .)
    DEQUAL          reduce using rule 27 (term -> term DIV fact .)
    GTHEN           reduce using rule 27 (term -> term DIV fact .)
    LTHEN           reduce using rule 27 (term -> term DIV fact .)
    NOT             reduce using rule 27 (term -> term DIV fact .)
    AND             reduce using rule 27 (term -> term DIV fact .)
    OR              reduce using rule 27 (term -> term DIV fact .)


state 102

    (28) term -> term MOD fact .

    MUL             reduce using rule 28 (term -> term MOD fact .)
    DIV             reduce using rule 28 (term -> term MOD fact .)
    MOD             reduce using rule 28 (term -> term MOD fact .)
    PLUS            reduce using rule 28 (term -> term MOD fact .)
    MINUS           reduce using rule 28 (term -> term MOD fact .)
    SCOLON          reduce using rule 28 (term -> term MOD fact .)
    RPAREN          reduce using rule 28 (term -> term MOD fact .)
    DEQUAL          reduce using rule 28 (term -> term MOD fact .)
    GTHEN           reduce using rule 28 (term -> term MOD fact .)
    LTHEN           reduce using rule 28 (term -> term MOD fact .)
    NOT             reduce using rule 28 (term -> term MOD fact .)
    AND             reduce using rule 28 (term -> term MOD fact .)
    OR              reduce using rule 28 (term -> term MOD fact .)


state 103

    (6) nline -> STR IDVAR EQUAL strvar SCOLON .

    STR             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    BOOL            reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    RETURN          reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    EXIT            reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    PRINT           reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    FOR             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    WHILE           reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    INT             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    FLT             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    CHR             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    IF              reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    IDVAR           reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    $end            reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    RCB             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)


state 104

    (63) nline -> STR LBB RBB IDVAR EQUAL . arrt SCOLON
    (64) arrt -> . var
    (65) arrt -> . LCB dws RCB
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    LCB             shift and go to state 116
    IDVAR           shift and go to state 7

    arrt                           shift and go to state 117
    var                            shift and go to state 115

state 105

    (7) nline -> BOOL MAIN LPAREN RPAREN lcb . line rcb
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN lcb line rcb
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb
    (15) nline -> . WHILE LPAREN bexp RPAREN lcb line rcb
    (62) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (63) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (41) dtype -> . INT
    (42) dtype -> . FLT
    (43) dtype -> . CHR
    (44) dtype -> . BOOL
    (60) fline -> . dtype numexp
    (61) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN lcb line rcb elsests
    (22) numexp -> . assign SCOLON
    (58) assign -> . var EQUAL exp
    (59) assign -> . var EQUAL STRING
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 118
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19

state 106

    (18) lcb -> LCB .

    STR             reduce using rule 18 (lcb -> LCB .)
    BOOL            reduce using rule 18 (lcb -> LCB .)
    RETURN          reduce using rule 18 (lcb -> LCB .)
    EXIT            reduce using rule 18 (lcb -> LCB .)
    PRINT           reduce using rule 18 (lcb -> LCB .)
    FOR             reduce using rule 18 (lcb -> LCB .)
    WHILE           reduce using rule 18 (lcb -> LCB .)
    INT             reduce using rule 18 (lcb -> LCB .)
    FLT             reduce using rule 18 (lcb -> LCB .)
    CHR             reduce using rule 18 (lcb -> LCB .)
    IF              reduce using rule 18 (lcb -> LCB .)
    IDVAR           reduce using rule 18 (lcb -> LCB .)


state 107

    (8) nline -> RETURN LPAREN bval RPAREN SCOLON .

    STR             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    BOOL            reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    RETURN          reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    EXIT            reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    PRINT           reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    FOR             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    WHILE           reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    INT             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    FLT             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    CHR             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    IF              reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    IDVAR           reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    $end            reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    RCB             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)


state 108

    (11) nline -> PRINT LPAREN pline RPAREN SCOLON .

    STR             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    BOOL            reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    RETURN          reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    EXIT            reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    PRINT           reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    FOR             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    WHILE           reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    INT             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    FLT             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    CHR             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    IF              reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    IDVAR           reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    $end            reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    RCB             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)


state 109

    (14) nline -> FOR LPAREN fline bexp SCOLON . assign RPAREN lcb line rcb
    (58) assign -> . var EQUAL exp
    (59) assign -> . var EQUAL STRING
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    IDVAR           shift and go to state 7

    assign                         shift and go to state 119
    var                            shift and go to state 4

state 110

    (15) nline -> WHILE LPAREN bexp RPAREN lcb . line rcb
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN lcb line rcb
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb
    (15) nline -> . WHILE LPAREN bexp RPAREN lcb line rcb
    (62) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (63) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (41) dtype -> . INT
    (42) dtype -> . FLT
    (43) dtype -> . CHR
    (44) dtype -> . BOOL
    (60) fline -> . dtype numexp
    (61) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN lcb line rcb elsests
    (22) numexp -> . assign SCOLON
    (58) assign -> . var EQUAL exp
    (59) assign -> . var EQUAL STRING
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 120
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19

state 111

    (47) bexp -> bexp andor bexp2 .
    (49) bexp2 -> bexp2 . rln exp
    (51) rln -> . DEQUAL
    (52) rln -> . GTHEN
    (53) rln -> . LTHEN
    (54) rln -> . NOT

    RPAREN          reduce using rule 47 (bexp -> bexp andor bexp2 .)
    AND             reduce using rule 47 (bexp -> bexp andor bexp2 .)
    OR              reduce using rule 47 (bexp -> bexp andor bexp2 .)
    SCOLON          reduce using rule 47 (bexp -> bexp andor bexp2 .)
    DEQUAL          shift and go to state 92
    GTHEN           shift and go to state 93
    LTHEN           shift and go to state 94
    NOT             shift and go to state 95

    rln                            shift and go to state 91

state 112

    (49) bexp2 -> bexp2 rln exp .
    (23) exp -> exp . PLUS term
    (24) exp -> exp . MINUS term

    DEQUAL          reduce using rule 49 (bexp2 -> bexp2 rln exp .)
    GTHEN           reduce using rule 49 (bexp2 -> bexp2 rln exp .)
    LTHEN           reduce using rule 49 (bexp2 -> bexp2 rln exp .)
    NOT             reduce using rule 49 (bexp2 -> bexp2 rln exp .)
    RPAREN          reduce using rule 49 (bexp2 -> bexp2 rln exp .)
    AND             reduce using rule 49 (bexp2 -> bexp2 rln exp .)
    OR              reduce using rule 49 (bexp2 -> bexp2 rln exp .)
    SCOLON          reduce using rule 49 (bexp2 -> bexp2 rln exp .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72


state 113

    (16) ifsts -> IF LPAREN bexp RPAREN lcb . line rcb elsests
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN lcb line rcb
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb
    (15) nline -> . WHILE LPAREN bexp RPAREN lcb line rcb
    (62) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (63) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (41) dtype -> . INT
    (42) dtype -> . FLT
    (43) dtype -> . CHR
    (44) dtype -> . BOOL
    (60) fline -> . dtype numexp
    (61) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN lcb line rcb elsests
    (22) numexp -> . assign SCOLON
    (58) assign -> . var EQUAL exp
    (59) assign -> . var EQUAL STRING
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 121
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19

state 114

    (62) nline -> dtype LBB RBB IDVAR EQUAL arrt . SCOLON

    SCOLON          shift and go to state 122


state 115

    (64) arrt -> var .

    SCOLON          reduce using rule 64 (arrt -> var .)


state 116

    (65) arrt -> LCB . dws RCB
    (66) dws -> . factarr COM dws
    (67) dws -> . factarr
    (68) factarr -> . fact
    (69) factarr -> . STRING
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) bval -> . TRUE
    (37) bval -> . FALSE
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    STRING          shift and go to state 126
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    dws                            shift and go to state 123
    factarr                        shift and go to state 124
    fact                           shift and go to state 125
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 117

    (63) nline -> STR LBB RBB IDVAR EQUAL arrt . SCOLON

    SCOLON          shift and go to state 127


state 118

    (7) nline -> BOOL MAIN LPAREN RPAREN lcb line . rcb
    (17) rcb -> . RCB

    RCB             shift and go to state 129

    rcb                            shift and go to state 128

state 119

    (14) nline -> FOR LPAREN fline bexp SCOLON assign . RPAREN lcb line rcb

    RPAREN          shift and go to state 130


state 120

    (15) nline -> WHILE LPAREN bexp RPAREN lcb line . rcb
    (17) rcb -> . RCB

    RCB             shift and go to state 129

    rcb                            shift and go to state 131

state 121

    (16) ifsts -> IF LPAREN bexp RPAREN lcb line . rcb elsests
    (17) rcb -> . RCB

    RCB             shift and go to state 129

    rcb                            shift and go to state 132

state 122

    (62) nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .

    STR             reduce using rule 62 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    BOOL            reduce using rule 62 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    RETURN          reduce using rule 62 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    EXIT            reduce using rule 62 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    PRINT           reduce using rule 62 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    FOR             reduce using rule 62 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    WHILE           reduce using rule 62 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    INT             reduce using rule 62 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    FLT             reduce using rule 62 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    CHR             reduce using rule 62 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    IF              reduce using rule 62 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    IDVAR           reduce using rule 62 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    $end            reduce using rule 62 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    RCB             reduce using rule 62 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)


state 123

    (65) arrt -> LCB dws . RCB

    RCB             shift and go to state 133


state 124

    (66) dws -> factarr . COM dws
    (67) dws -> factarr .

    COM             shift and go to state 134
    RCB             reduce using rule 67 (dws -> factarr .)


state 125

    (68) factarr -> fact .

    COM             reduce using rule 68 (factarr -> fact .)
    RCB             reduce using rule 68 (factarr -> fact .)


state 126

    (69) factarr -> STRING .

    COM             reduce using rule 69 (factarr -> STRING .)
    RCB             reduce using rule 69 (factarr -> STRING .)


state 127

    (63) nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .

    STR             reduce using rule 63 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    BOOL            reduce using rule 63 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    RETURN          reduce using rule 63 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    EXIT            reduce using rule 63 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    PRINT           reduce using rule 63 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    FOR             reduce using rule 63 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    WHILE           reduce using rule 63 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    INT             reduce using rule 63 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    FLT             reduce using rule 63 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    CHR             reduce using rule 63 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    IF              reduce using rule 63 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    IDVAR           reduce using rule 63 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    $end            reduce using rule 63 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    RCB             reduce using rule 63 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)


state 128

    (7) nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .

    STR             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    BOOL            reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    RETURN          reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    EXIT            reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    PRINT           reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    FOR             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    WHILE           reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    INT             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    FLT             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    CHR             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    IF              reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    IDVAR           reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    $end            reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)
    RCB             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN lcb line rcb .)


state 129

    (17) rcb -> RCB .

    STR             reduce using rule 17 (rcb -> RCB .)
    BOOL            reduce using rule 17 (rcb -> RCB .)
    RETURN          reduce using rule 17 (rcb -> RCB .)
    EXIT            reduce using rule 17 (rcb -> RCB .)
    PRINT           reduce using rule 17 (rcb -> RCB .)
    FOR             reduce using rule 17 (rcb -> RCB .)
    WHILE           reduce using rule 17 (rcb -> RCB .)
    INT             reduce using rule 17 (rcb -> RCB .)
    FLT             reduce using rule 17 (rcb -> RCB .)
    CHR             reduce using rule 17 (rcb -> RCB .)
    IF              reduce using rule 17 (rcb -> RCB .)
    IDVAR           reduce using rule 17 (rcb -> RCB .)
    $end            reduce using rule 17 (rcb -> RCB .)
    RCB             reduce using rule 17 (rcb -> RCB .)
    ELSE            reduce using rule 17 (rcb -> RCB .)


state 130

    (14) nline -> FOR LPAREN fline bexp SCOLON assign RPAREN . lcb line rcb
    (18) lcb -> . LCB

    LCB             shift and go to state 106

    lcb                            shift and go to state 135

state 131

    (15) nline -> WHILE LPAREN bexp RPAREN lcb line rcb .

    STR             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    BOOL            reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    RETURN          reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    EXIT            reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    PRINT           reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    FOR             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    WHILE           reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    INT             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    FLT             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    CHR             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    IF              reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    IDVAR           reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    $end            reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)
    RCB             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN lcb line rcb .)


state 132

    (16) ifsts -> IF LPAREN bexp RPAREN lcb line rcb . elsests
    (19) elsests -> . ELSE lcb line rcb
    (20) elsests -> . ELSE ifsts
    (21) elsests -> . empty
    (57) empty -> .

    ELSE            shift and go to state 137
    STR             reduce using rule 57 (empty -> .)
    BOOL            reduce using rule 57 (empty -> .)
    RETURN          reduce using rule 57 (empty -> .)
    EXIT            reduce using rule 57 (empty -> .)
    PRINT           reduce using rule 57 (empty -> .)
    FOR             reduce using rule 57 (empty -> .)
    WHILE           reduce using rule 57 (empty -> .)
    INT             reduce using rule 57 (empty -> .)
    FLT             reduce using rule 57 (empty -> .)
    CHR             reduce using rule 57 (empty -> .)
    IF              reduce using rule 57 (empty -> .)
    IDVAR           reduce using rule 57 (empty -> .)
    $end            reduce using rule 57 (empty -> .)
    RCB             reduce using rule 57 (empty -> .)

    elsests                        shift and go to state 136
    empty                          shift and go to state 138

state 133

    (65) arrt -> LCB dws RCB .

    SCOLON          reduce using rule 65 (arrt -> LCB dws RCB .)


state 134

    (66) dws -> factarr COM . dws
    (66) dws -> . factarr COM dws
    (67) dws -> . factarr
    (68) factarr -> . fact
    (69) factarr -> . STRING
    (30) fact -> . INTEGER
    (31) fact -> . FLOAT
    (32) fact -> . varval
    (33) fact -> . bval
    (34) fact -> . CHAR
    (35) varval -> . var
    (36) bval -> . TRUE
    (37) bval -> . FALSE
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    STRING          shift and go to state 126
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    CHAR            shift and go to state 49
    TRUE            shift and go to state 50
    FALSE           shift and go to state 51
    IDVAR           shift and go to state 7

    factarr                        shift and go to state 124
    dws                            shift and go to state 139
    fact                           shift and go to state 125
    varval                         shift and go to state 47
    bval                           shift and go to state 48
    var                            shift and go to state 40

state 135

    (14) nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb . line rcb
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN lcb line rcb
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb
    (15) nline -> . WHILE LPAREN bexp RPAREN lcb line rcb
    (62) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (63) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (41) dtype -> . INT
    (42) dtype -> . FLT
    (43) dtype -> . CHR
    (44) dtype -> . BOOL
    (60) fline -> . dtype numexp
    (61) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN lcb line rcb elsests
    (22) numexp -> . assign SCOLON
    (58) assign -> . var EQUAL exp
    (59) assign -> . var EQUAL STRING
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    fline                          shift and go to state 6
    assign                         shift and go to state 14
    line                           shift and go to state 140
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    ifsts                          shift and go to state 10
    numexp                         shift and go to state 19

state 136

    (16) ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .

    STR             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    BOOL            reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    RETURN          reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    EXIT            reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    PRINT           reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    FOR             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    WHILE           reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    INT             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    FLT             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    CHR             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    IF              reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    IDVAR           reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    $end            reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)
    RCB             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN lcb line rcb elsests .)


state 137

    (19) elsests -> ELSE . lcb line rcb
    (20) elsests -> ELSE . ifsts
    (18) lcb -> . LCB
    (16) ifsts -> . IF LPAREN bexp RPAREN lcb line rcb elsests

    LCB             shift and go to state 106
    IF              shift and go to state 20

    lcb                            shift and go to state 141
    ifsts                          shift and go to state 142

state 138

    (21) elsests -> empty .

    STR             reduce using rule 21 (elsests -> empty .)
    BOOL            reduce using rule 21 (elsests -> empty .)
    RETURN          reduce using rule 21 (elsests -> empty .)
    EXIT            reduce using rule 21 (elsests -> empty .)
    PRINT           reduce using rule 21 (elsests -> empty .)
    FOR             reduce using rule 21 (elsests -> empty .)
    WHILE           reduce using rule 21 (elsests -> empty .)
    INT             reduce using rule 21 (elsests -> empty .)
    FLT             reduce using rule 21 (elsests -> empty .)
    CHR             reduce using rule 21 (elsests -> empty .)
    IF              reduce using rule 21 (elsests -> empty .)
    IDVAR           reduce using rule 21 (elsests -> empty .)
    $end            reduce using rule 21 (elsests -> empty .)
    RCB             reduce using rule 21 (elsests -> empty .)


state 139

    (66) dws -> factarr COM dws .

    RCB             reduce using rule 66 (dws -> factarr COM dws .)


state 140

    (14) nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line . rcb
    (17) rcb -> . RCB

    RCB             shift and go to state 129

    rcb                            shift and go to state 143

state 141

    (19) elsests -> ELSE lcb . line rcb
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN lcb line rcb
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb
    (15) nline -> . WHILE LPAREN bexp RPAREN lcb line rcb
    (62) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (63) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (41) dtype -> . INT
    (42) dtype -> . FLT
    (43) dtype -> . CHR
    (44) dtype -> . BOOL
    (60) fline -> . dtype numexp
    (61) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN lcb line rcb elsests
    (22) numexp -> . assign SCOLON
    (58) assign -> . var EQUAL exp
    (59) assign -> . var EQUAL STRING
    (38) var -> . IDVAR
    (39) var -> . IDVAR LBB INTEGER RBB
    (40) var -> . IDVAR LBB IDVAR RBB

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 144
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19

state 142

    (20) elsests -> ELSE ifsts .

    STR             reduce using rule 20 (elsests -> ELSE ifsts .)
    BOOL            reduce using rule 20 (elsests -> ELSE ifsts .)
    RETURN          reduce using rule 20 (elsests -> ELSE ifsts .)
    EXIT            reduce using rule 20 (elsests -> ELSE ifsts .)
    PRINT           reduce using rule 20 (elsests -> ELSE ifsts .)
    FOR             reduce using rule 20 (elsests -> ELSE ifsts .)
    WHILE           reduce using rule 20 (elsests -> ELSE ifsts .)
    INT             reduce using rule 20 (elsests -> ELSE ifsts .)
    FLT             reduce using rule 20 (elsests -> ELSE ifsts .)
    CHR             reduce using rule 20 (elsests -> ELSE ifsts .)
    IF              reduce using rule 20 (elsests -> ELSE ifsts .)
    IDVAR           reduce using rule 20 (elsests -> ELSE ifsts .)
    $end            reduce using rule 20 (elsests -> ELSE ifsts .)
    RCB             reduce using rule 20 (elsests -> ELSE ifsts .)


state 143

    (14) nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .

    STR             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    BOOL            reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    RETURN          reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    EXIT            reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    PRINT           reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    FOR             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    WHILE           reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    INT             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    FLT             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    CHR             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    IF              reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    IDVAR           reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    $end            reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)
    RCB             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN lcb line rcb .)


state 144

    (19) elsests -> ELSE lcb line . rcb
    (17) rcb -> . RCB

    RCB             shift and go to state 129

    rcb                            shift and go to state 145

state 145

    (19) elsests -> ELSE lcb line rcb .

    STR             reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    BOOL            reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    RETURN          reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    EXIT            reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    PRINT           reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    FOR             reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    WHILE           reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    INT             reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    FLT             reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    CHR             reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    IF              reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    IDVAR           reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    $end            reduce using rule 19 (elsests -> ELSE lcb line rcb .)
    RCB             reduce using rule 19 (elsests -> ELSE lcb line rcb .)

