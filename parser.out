Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COM
    COMMENT
    LBB
    RBB
    VOID
    WITH

Grammar

Rule 0     S' -> line
Rule 1     line -> nline line
Rule 2     line -> nline
Rule 3     nline -> dtype var SCOLON
Rule 4     nline -> STR var SCOLON
Rule 5     nline -> dtype numexp
Rule 6     nline -> numexp
Rule 7     nline -> STR var EQUAL strvar SCOLON
Rule 8     nline -> BOOL MAIN LPAREN RPAREN LCB line RCB
Rule 9     nline -> RETURN LPAREN bval RPAREN SCOLON
Rule 10    nline -> ifsts
Rule 11    nline -> EXIT LPAREN RPAREN SCOLON
Rule 12    nline -> PRINT LPAREN nline RPAREN SCOLON
Rule 13    nline -> FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB
Rule 14    nline -> WHILE LPAREN bexp RPAREN LCB line RCB
Rule 15    ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests
Rule 16    elsests -> ELSE LCB line RCB
Rule 17    elsests -> ELSE ifsts
Rule 18    elsests -> empty
Rule 19    numexp -> var EQUAL exp SCOLON
Rule 20    exp -> exp PLUS term
Rule 21    exp -> exp MINUS term
Rule 22    exp -> term
Rule 23    term -> term MUL fact
Rule 24    term -> term DIV fact
Rule 25    term -> term MOD fact
Rule 26    term -> fact
Rule 27    fact -> INTEGER
Rule 28    fact -> FLOAT
Rule 29    fact -> var
Rule 30    fact -> bval
Rule 31    fact -> CHAR
Rule 32    bval -> TRUE
Rule 33    bval -> FALSE
Rule 34    var -> IDVAR
Rule 35    dtype -> INT
Rule 36    dtype -> FLT
Rule 37    dtype -> CHR
Rule 38    dtype -> BOOL
Rule 39    strvar -> STRING
Rule 40    strvar -> var
Rule 41    bexp -> bexp andor bexp2
Rule 42    bexp -> bexp2
Rule 43    bexp2 -> bexp2 rln exp
Rule 44    bexp2 -> exp
Rule 45    rln -> DEQUAL
Rule 46    rln -> GTHEN
Rule 47    rln -> LTHEN
Rule 48    rln -> NOT
Rule 49    andor -> AND
Rule 50    andor -> OR
Rule 51    empty -> <empty>

Terminals, with rules where they appear

AND                  : 49
BOOL                 : 8 38
CHAR                 : 31
CHR                  : 37
COM                  : 
COMMENT              : 
DEQUAL               : 45
DIV                  : 24
ELSE                 : 16 17
EQUAL                : 7 19
EXIT                 : 11
FALSE                : 33
FLOAT                : 28
FLT                  : 36
FOR                  : 13
GTHEN                : 46
IDVAR                : 34
IF                   : 15
INT                  : 35
INTEGER              : 27
LBB                  : 
LCB                  : 8 13 14 15 16
LPAREN               : 8 9 11 12 13 14 15
LTHEN                : 47
MAIN                 : 8
MINUS                : 21
MOD                  : 25
MUL                  : 23
NOT                  : 48
OR                   : 50
PLUS                 : 20
PRINT                : 12
RBB                  : 
RCB                  : 8 13 14 15 16
RETURN               : 9
RPAREN               : 8 9 11 12 13 14 15
SCOLON               : 3 4 7 9 11 12 13 19
STR                  : 4 7
STRING               : 39
TRUE                 : 32
VOID                 : 
WHILE                : 14
WITH                 : 
error                : 

Nonterminals, with rules where they appear

andor                : 41
bexp                 : 13 14 15 41
bexp2                : 41 42 43
bval                 : 9 30
dtype                : 3 5
elsests              : 15
empty                : 18
exp                  : 19 20 21 43 44
fact                 : 23 24 25 26
ifsts                : 10 17
line                 : 1 8 13 14 15 16 0
nline                : 1 2 12 13 13
numexp               : 5 6
rln                  : 43
strvar               : 7
term                 : 20 21 22 23 24 25
var                  : 3 4 7 19 29 40

Parsing method: LALR

state 0

    (0) S' -> . line
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . dtype numexp
    (6) nline -> . numexp
    (7) nline -> . STR var EQUAL strvar SCOLON
    (8) nline -> . BOOL MAIN LPAREN RPAREN LCB line RCB
    (9) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (10) nline -> . ifsts
    (11) nline -> . EXIT LPAREN RPAREN SCOLON
    (12) nline -> . PRINT LPAREN nline RPAREN SCOLON
    (13) nline -> . FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB
    (14) nline -> . WHILE LPAREN bexp RPAREN LCB line RCB
    (35) dtype -> . INT
    (36) dtype -> . FLT
    (37) dtype -> . CHR
    (38) dtype -> . BOOL
    (19) numexp -> . var EQUAL exp SCOLON
    (15) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests
    (34) var -> . IDVAR

    STR             shift and go to state 5
    BOOL            shift and go to state 7
    RETURN          shift and go to state 8
    EXIT            shift and go to state 10
    PRINT           shift and go to state 11
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    INT             shift and go to state 14
    FLT             shift and go to state 15
    CHR             shift and go to state 16
    IF              shift and go to state 17
    IDVAR           shift and go to state 18

    line                           shift and go to state 1
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    numexp                         shift and go to state 6
    ifsts                          shift and go to state 9

state 1

    (0) S' -> line .



state 2

    (1) line -> nline . line
    (2) line -> nline .
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . dtype numexp
    (6) nline -> . numexp
    (7) nline -> . STR var EQUAL strvar SCOLON
    (8) nline -> . BOOL MAIN LPAREN RPAREN LCB line RCB
    (9) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (10) nline -> . ifsts
    (11) nline -> . EXIT LPAREN RPAREN SCOLON
    (12) nline -> . PRINT LPAREN nline RPAREN SCOLON
    (13) nline -> . FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB
    (14) nline -> . WHILE LPAREN bexp RPAREN LCB line RCB
    (35) dtype -> . INT
    (36) dtype -> . FLT
    (37) dtype -> . CHR
    (38) dtype -> . BOOL
    (19) numexp -> . var EQUAL exp SCOLON
    (15) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests
    (34) var -> . IDVAR

    $end            reduce using rule 2 (line -> nline .)
    RCB             reduce using rule 2 (line -> nline .)
    STR             shift and go to state 5
    BOOL            shift and go to state 7
    RETURN          shift and go to state 8
    EXIT            shift and go to state 10
    PRINT           shift and go to state 11
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    INT             shift and go to state 14
    FLT             shift and go to state 15
    CHR             shift and go to state 16
    IF              shift and go to state 17
    IDVAR           shift and go to state 18

    nline                          shift and go to state 2
    line                           shift and go to state 19
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    numexp                         shift and go to state 6
    ifsts                          shift and go to state 9

state 3

    (3) nline -> dtype . var SCOLON
    (5) nline -> dtype . numexp
    (34) var -> . IDVAR
    (19) numexp -> . var EQUAL exp SCOLON

    IDVAR           shift and go to state 18

    var                            shift and go to state 20
    numexp                         shift and go to state 21

state 4

    (19) numexp -> var . EQUAL exp SCOLON

    EQUAL           shift and go to state 22


state 5

    (4) nline -> STR . var SCOLON
    (7) nline -> STR . var EQUAL strvar SCOLON
    (34) var -> . IDVAR

    IDVAR           shift and go to state 18

    var                            shift and go to state 23

state 6

    (6) nline -> numexp .

    STR             reduce using rule 6 (nline -> numexp .)
    BOOL            reduce using rule 6 (nline -> numexp .)
    RETURN          reduce using rule 6 (nline -> numexp .)
    EXIT            reduce using rule 6 (nline -> numexp .)
    PRINT           reduce using rule 6 (nline -> numexp .)
    FOR             reduce using rule 6 (nline -> numexp .)
    WHILE           reduce using rule 6 (nline -> numexp .)
    INT             reduce using rule 6 (nline -> numexp .)
    FLT             reduce using rule 6 (nline -> numexp .)
    CHR             reduce using rule 6 (nline -> numexp .)
    IF              reduce using rule 6 (nline -> numexp .)
    IDVAR           reduce using rule 6 (nline -> numexp .)
    $end            reduce using rule 6 (nline -> numexp .)
    RCB             reduce using rule 6 (nline -> numexp .)
    RPAREN          reduce using rule 6 (nline -> numexp .)
    INTEGER         reduce using rule 6 (nline -> numexp .)
    FLOAT           reduce using rule 6 (nline -> numexp .)
    CHAR            reduce using rule 6 (nline -> numexp .)
    TRUE            reduce using rule 6 (nline -> numexp .)
    FALSE           reduce using rule 6 (nline -> numexp .)


state 7

    (8) nline -> BOOL . MAIN LPAREN RPAREN LCB line RCB
    (38) dtype -> BOOL .

    MAIN            shift and go to state 24
    IDVAR           reduce using rule 38 (dtype -> BOOL .)


state 8

    (9) nline -> RETURN . LPAREN bval RPAREN SCOLON

    LPAREN          shift and go to state 25


state 9

    (10) nline -> ifsts .

    STR             reduce using rule 10 (nline -> ifsts .)
    BOOL            reduce using rule 10 (nline -> ifsts .)
    RETURN          reduce using rule 10 (nline -> ifsts .)
    EXIT            reduce using rule 10 (nline -> ifsts .)
    PRINT           reduce using rule 10 (nline -> ifsts .)
    FOR             reduce using rule 10 (nline -> ifsts .)
    WHILE           reduce using rule 10 (nline -> ifsts .)
    INT             reduce using rule 10 (nline -> ifsts .)
    FLT             reduce using rule 10 (nline -> ifsts .)
    CHR             reduce using rule 10 (nline -> ifsts .)
    IF              reduce using rule 10 (nline -> ifsts .)
    IDVAR           reduce using rule 10 (nline -> ifsts .)
    $end            reduce using rule 10 (nline -> ifsts .)
    RCB             reduce using rule 10 (nline -> ifsts .)
    RPAREN          reduce using rule 10 (nline -> ifsts .)
    INTEGER         reduce using rule 10 (nline -> ifsts .)
    FLOAT           reduce using rule 10 (nline -> ifsts .)
    CHAR            reduce using rule 10 (nline -> ifsts .)
    TRUE            reduce using rule 10 (nline -> ifsts .)
    FALSE           reduce using rule 10 (nline -> ifsts .)


state 10

    (11) nline -> EXIT . LPAREN RPAREN SCOLON

    LPAREN          shift and go to state 26


state 11

    (12) nline -> PRINT . LPAREN nline RPAREN SCOLON

    LPAREN          shift and go to state 27


state 12

    (13) nline -> FOR . LPAREN nline bexp SCOLON nline RPAREN LCB line RCB

    LPAREN          shift and go to state 28


state 13

    (14) nline -> WHILE . LPAREN bexp RPAREN LCB line RCB

    LPAREN          shift and go to state 29


state 14

    (35) dtype -> INT .

    IDVAR           reduce using rule 35 (dtype -> INT .)


state 15

    (36) dtype -> FLT .

    IDVAR           reduce using rule 36 (dtype -> FLT .)


state 16

    (37) dtype -> CHR .

    IDVAR           reduce using rule 37 (dtype -> CHR .)


state 17

    (15) ifsts -> IF . LPAREN bexp RPAREN LCB line RCB elsests

    LPAREN          shift and go to state 30


state 18

    (34) var -> IDVAR .

    EQUAL           reduce using rule 34 (var -> IDVAR .)
    SCOLON          reduce using rule 34 (var -> IDVAR .)
    MUL             reduce using rule 34 (var -> IDVAR .)
    DIV             reduce using rule 34 (var -> IDVAR .)
    MOD             reduce using rule 34 (var -> IDVAR .)
    PLUS            reduce using rule 34 (var -> IDVAR .)
    MINUS           reduce using rule 34 (var -> IDVAR .)
    DEQUAL          reduce using rule 34 (var -> IDVAR .)
    GTHEN           reduce using rule 34 (var -> IDVAR .)
    LTHEN           reduce using rule 34 (var -> IDVAR .)
    NOT             reduce using rule 34 (var -> IDVAR .)
    RPAREN          reduce using rule 34 (var -> IDVAR .)
    AND             reduce using rule 34 (var -> IDVAR .)
    OR              reduce using rule 34 (var -> IDVAR .)


state 19

    (1) line -> nline line .

    $end            reduce using rule 1 (line -> nline line .)
    RCB             reduce using rule 1 (line -> nline line .)


state 20

    (3) nline -> dtype var . SCOLON
    (19) numexp -> var . EQUAL exp SCOLON

    SCOLON          shift and go to state 31
    EQUAL           shift and go to state 22


state 21

    (5) nline -> dtype numexp .

    STR             reduce using rule 5 (nline -> dtype numexp .)
    BOOL            reduce using rule 5 (nline -> dtype numexp .)
    RETURN          reduce using rule 5 (nline -> dtype numexp .)
    EXIT            reduce using rule 5 (nline -> dtype numexp .)
    PRINT           reduce using rule 5 (nline -> dtype numexp .)
    FOR             reduce using rule 5 (nline -> dtype numexp .)
    WHILE           reduce using rule 5 (nline -> dtype numexp .)
    INT             reduce using rule 5 (nline -> dtype numexp .)
    FLT             reduce using rule 5 (nline -> dtype numexp .)
    CHR             reduce using rule 5 (nline -> dtype numexp .)
    IF              reduce using rule 5 (nline -> dtype numexp .)
    IDVAR           reduce using rule 5 (nline -> dtype numexp .)
    $end            reduce using rule 5 (nline -> dtype numexp .)
    RCB             reduce using rule 5 (nline -> dtype numexp .)
    RPAREN          reduce using rule 5 (nline -> dtype numexp .)
    INTEGER         reduce using rule 5 (nline -> dtype numexp .)
    FLOAT           reduce using rule 5 (nline -> dtype numexp .)
    CHAR            reduce using rule 5 (nline -> dtype numexp .)
    TRUE            reduce using rule 5 (nline -> dtype numexp .)
    FALSE           reduce using rule 5 (nline -> dtype numexp .)


state 22

    (19) numexp -> var EQUAL . exp SCOLON
    (20) exp -> . exp PLUS term
    (21) exp -> . exp MINUS term
    (22) exp -> . term
    (23) term -> . term MUL fact
    (24) term -> . term DIV fact
    (25) term -> . term MOD fact
    (26) term -> . fact
    (27) fact -> . INTEGER
    (28) fact -> . FLOAT
    (29) fact -> . var
    (30) fact -> . bval
    (31) fact -> . CHAR
    (34) var -> . IDVAR
    (32) bval -> . TRUE
    (33) bval -> . FALSE

    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    CHAR            shift and go to state 39
    IDVAR           shift and go to state 18
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    var                            shift and go to state 32
    exp                            shift and go to state 33
    term                           shift and go to state 34
    fact                           shift and go to state 35
    bval                           shift and go to state 38

state 23

    (4) nline -> STR var . SCOLON
    (7) nline -> STR var . EQUAL strvar SCOLON

    SCOLON          shift and go to state 42
    EQUAL           shift and go to state 43


state 24

    (8) nline -> BOOL MAIN . LPAREN RPAREN LCB line RCB

    LPAREN          shift and go to state 44


state 25

    (9) nline -> RETURN LPAREN . bval RPAREN SCOLON
    (32) bval -> . TRUE
    (33) bval -> . FALSE

    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    bval                           shift and go to state 45

state 26

    (11) nline -> EXIT LPAREN . RPAREN SCOLON

    RPAREN          shift and go to state 46


state 27

    (12) nline -> PRINT LPAREN . nline RPAREN SCOLON
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . dtype numexp
    (6) nline -> . numexp
    (7) nline -> . STR var EQUAL strvar SCOLON
    (8) nline -> . BOOL MAIN LPAREN RPAREN LCB line RCB
    (9) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (10) nline -> . ifsts
    (11) nline -> . EXIT LPAREN RPAREN SCOLON
    (12) nline -> . PRINT LPAREN nline RPAREN SCOLON
    (13) nline -> . FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB
    (14) nline -> . WHILE LPAREN bexp RPAREN LCB line RCB
    (35) dtype -> . INT
    (36) dtype -> . FLT
    (37) dtype -> . CHR
    (38) dtype -> . BOOL
    (19) numexp -> . var EQUAL exp SCOLON
    (15) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests
    (34) var -> . IDVAR

    STR             shift and go to state 5
    BOOL            shift and go to state 7
    RETURN          shift and go to state 8
    EXIT            shift and go to state 10
    PRINT           shift and go to state 11
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    INT             shift and go to state 14
    FLT             shift and go to state 15
    CHR             shift and go to state 16
    IF              shift and go to state 17
    IDVAR           shift and go to state 18

    nline                          shift and go to state 47
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    numexp                         shift and go to state 6
    ifsts                          shift and go to state 9

state 28

    (13) nline -> FOR LPAREN . nline bexp SCOLON nline RPAREN LCB line RCB
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . dtype numexp
    (6) nline -> . numexp
    (7) nline -> . STR var EQUAL strvar SCOLON
    (8) nline -> . BOOL MAIN LPAREN RPAREN LCB line RCB
    (9) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (10) nline -> . ifsts
    (11) nline -> . EXIT LPAREN RPAREN SCOLON
    (12) nline -> . PRINT LPAREN nline RPAREN SCOLON
    (13) nline -> . FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB
    (14) nline -> . WHILE LPAREN bexp RPAREN LCB line RCB
    (35) dtype -> . INT
    (36) dtype -> . FLT
    (37) dtype -> . CHR
    (38) dtype -> . BOOL
    (19) numexp -> . var EQUAL exp SCOLON
    (15) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests
    (34) var -> . IDVAR

    STR             shift and go to state 5
    BOOL            shift and go to state 7
    RETURN          shift and go to state 8
    EXIT            shift and go to state 10
    PRINT           shift and go to state 11
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    INT             shift and go to state 14
    FLT             shift and go to state 15
    CHR             shift and go to state 16
    IF              shift and go to state 17
    IDVAR           shift and go to state 18

    nline                          shift and go to state 48
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    numexp                         shift and go to state 6
    ifsts                          shift and go to state 9

state 29

    (14) nline -> WHILE LPAREN . bexp RPAREN LCB line RCB
    (41) bexp -> . bexp andor bexp2
    (42) bexp -> . bexp2
    (43) bexp2 -> . bexp2 rln exp
    (44) bexp2 -> . exp
    (20) exp -> . exp PLUS term
    (21) exp -> . exp MINUS term
    (22) exp -> . term
    (23) term -> . term MUL fact
    (24) term -> . term DIV fact
    (25) term -> . term MOD fact
    (26) term -> . fact
    (27) fact -> . INTEGER
    (28) fact -> . FLOAT
    (29) fact -> . var
    (30) fact -> . bval
    (31) fact -> . CHAR
    (34) var -> . IDVAR
    (32) bval -> . TRUE
    (33) bval -> . FALSE

    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    CHAR            shift and go to state 39
    IDVAR           shift and go to state 18
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    bexp                           shift and go to state 49
    bexp2                          shift and go to state 50
    exp                            shift and go to state 51
    term                           shift and go to state 34
    fact                           shift and go to state 35
    var                            shift and go to state 32
    bval                           shift and go to state 38

state 30

    (15) ifsts -> IF LPAREN . bexp RPAREN LCB line RCB elsests
    (41) bexp -> . bexp andor bexp2
    (42) bexp -> . bexp2
    (43) bexp2 -> . bexp2 rln exp
    (44) bexp2 -> . exp
    (20) exp -> . exp PLUS term
    (21) exp -> . exp MINUS term
    (22) exp -> . term
    (23) term -> . term MUL fact
    (24) term -> . term DIV fact
    (25) term -> . term MOD fact
    (26) term -> . fact
    (27) fact -> . INTEGER
    (28) fact -> . FLOAT
    (29) fact -> . var
    (30) fact -> . bval
    (31) fact -> . CHAR
    (34) var -> . IDVAR
    (32) bval -> . TRUE
    (33) bval -> . FALSE

    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    CHAR            shift and go to state 39
    IDVAR           shift and go to state 18
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    bexp                           shift and go to state 52
    bexp2                          shift and go to state 50
    exp                            shift and go to state 51
    term                           shift and go to state 34
    fact                           shift and go to state 35
    var                            shift and go to state 32
    bval                           shift and go to state 38

state 31

    (3) nline -> dtype var SCOLON .

    STR             reduce using rule 3 (nline -> dtype var SCOLON .)
    BOOL            reduce using rule 3 (nline -> dtype var SCOLON .)
    RETURN          reduce using rule 3 (nline -> dtype var SCOLON .)
    EXIT            reduce using rule 3 (nline -> dtype var SCOLON .)
    PRINT           reduce using rule 3 (nline -> dtype var SCOLON .)
    FOR             reduce using rule 3 (nline -> dtype var SCOLON .)
    WHILE           reduce using rule 3 (nline -> dtype var SCOLON .)
    INT             reduce using rule 3 (nline -> dtype var SCOLON .)
    FLT             reduce using rule 3 (nline -> dtype var SCOLON .)
    CHR             reduce using rule 3 (nline -> dtype var SCOLON .)
    IF              reduce using rule 3 (nline -> dtype var SCOLON .)
    IDVAR           reduce using rule 3 (nline -> dtype var SCOLON .)
    $end            reduce using rule 3 (nline -> dtype var SCOLON .)
    RCB             reduce using rule 3 (nline -> dtype var SCOLON .)
    RPAREN          reduce using rule 3 (nline -> dtype var SCOLON .)
    INTEGER         reduce using rule 3 (nline -> dtype var SCOLON .)
    FLOAT           reduce using rule 3 (nline -> dtype var SCOLON .)
    CHAR            reduce using rule 3 (nline -> dtype var SCOLON .)
    TRUE            reduce using rule 3 (nline -> dtype var SCOLON .)
    FALSE           reduce using rule 3 (nline -> dtype var SCOLON .)


state 32

    (29) fact -> var .

    MUL             reduce using rule 29 (fact -> var .)
    DIV             reduce using rule 29 (fact -> var .)
    MOD             reduce using rule 29 (fact -> var .)
    SCOLON          reduce using rule 29 (fact -> var .)
    PLUS            reduce using rule 29 (fact -> var .)
    MINUS           reduce using rule 29 (fact -> var .)
    DEQUAL          reduce using rule 29 (fact -> var .)
    GTHEN           reduce using rule 29 (fact -> var .)
    LTHEN           reduce using rule 29 (fact -> var .)
    NOT             reduce using rule 29 (fact -> var .)
    RPAREN          reduce using rule 29 (fact -> var .)
    AND             reduce using rule 29 (fact -> var .)
    OR              reduce using rule 29 (fact -> var .)


state 33

    (19) numexp -> var EQUAL exp . SCOLON
    (20) exp -> exp . PLUS term
    (21) exp -> exp . MINUS term

    SCOLON          shift and go to state 53
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55


state 34

    (22) exp -> term .
    (23) term -> term . MUL fact
    (24) term -> term . DIV fact
    (25) term -> term . MOD fact

    SCOLON          reduce using rule 22 (exp -> term .)
    PLUS            reduce using rule 22 (exp -> term .)
    MINUS           reduce using rule 22 (exp -> term .)
    DEQUAL          reduce using rule 22 (exp -> term .)
    GTHEN           reduce using rule 22 (exp -> term .)
    LTHEN           reduce using rule 22 (exp -> term .)
    NOT             reduce using rule 22 (exp -> term .)
    RPAREN          reduce using rule 22 (exp -> term .)
    AND             reduce using rule 22 (exp -> term .)
    OR              reduce using rule 22 (exp -> term .)
    MUL             shift and go to state 56
    DIV             shift and go to state 57
    MOD             shift and go to state 58


state 35

    (26) term -> fact .

    MUL             reduce using rule 26 (term -> fact .)
    DIV             reduce using rule 26 (term -> fact .)
    MOD             reduce using rule 26 (term -> fact .)
    SCOLON          reduce using rule 26 (term -> fact .)
    PLUS            reduce using rule 26 (term -> fact .)
    MINUS           reduce using rule 26 (term -> fact .)
    DEQUAL          reduce using rule 26 (term -> fact .)
    GTHEN           reduce using rule 26 (term -> fact .)
    LTHEN           reduce using rule 26 (term -> fact .)
    NOT             reduce using rule 26 (term -> fact .)
    RPAREN          reduce using rule 26 (term -> fact .)
    AND             reduce using rule 26 (term -> fact .)
    OR              reduce using rule 26 (term -> fact .)


state 36

    (27) fact -> INTEGER .

    MUL             reduce using rule 27 (fact -> INTEGER .)
    DIV             reduce using rule 27 (fact -> INTEGER .)
    MOD             reduce using rule 27 (fact -> INTEGER .)
    SCOLON          reduce using rule 27 (fact -> INTEGER .)
    PLUS            reduce using rule 27 (fact -> INTEGER .)
    MINUS           reduce using rule 27 (fact -> INTEGER .)
    DEQUAL          reduce using rule 27 (fact -> INTEGER .)
    GTHEN           reduce using rule 27 (fact -> INTEGER .)
    LTHEN           reduce using rule 27 (fact -> INTEGER .)
    NOT             reduce using rule 27 (fact -> INTEGER .)
    RPAREN          reduce using rule 27 (fact -> INTEGER .)
    AND             reduce using rule 27 (fact -> INTEGER .)
    OR              reduce using rule 27 (fact -> INTEGER .)


state 37

    (28) fact -> FLOAT .

    MUL             reduce using rule 28 (fact -> FLOAT .)
    DIV             reduce using rule 28 (fact -> FLOAT .)
    MOD             reduce using rule 28 (fact -> FLOAT .)
    SCOLON          reduce using rule 28 (fact -> FLOAT .)
    PLUS            reduce using rule 28 (fact -> FLOAT .)
    MINUS           reduce using rule 28 (fact -> FLOAT .)
    DEQUAL          reduce using rule 28 (fact -> FLOAT .)
    GTHEN           reduce using rule 28 (fact -> FLOAT .)
    LTHEN           reduce using rule 28 (fact -> FLOAT .)
    NOT             reduce using rule 28 (fact -> FLOAT .)
    RPAREN          reduce using rule 28 (fact -> FLOAT .)
    AND             reduce using rule 28 (fact -> FLOAT .)
    OR              reduce using rule 28 (fact -> FLOAT .)


state 38

    (30) fact -> bval .

    MUL             reduce using rule 30 (fact -> bval .)
    DIV             reduce using rule 30 (fact -> bval .)
    MOD             reduce using rule 30 (fact -> bval .)
    SCOLON          reduce using rule 30 (fact -> bval .)
    PLUS            reduce using rule 30 (fact -> bval .)
    MINUS           reduce using rule 30 (fact -> bval .)
    DEQUAL          reduce using rule 30 (fact -> bval .)
    GTHEN           reduce using rule 30 (fact -> bval .)
    LTHEN           reduce using rule 30 (fact -> bval .)
    NOT             reduce using rule 30 (fact -> bval .)
    RPAREN          reduce using rule 30 (fact -> bval .)
    AND             reduce using rule 30 (fact -> bval .)
    OR              reduce using rule 30 (fact -> bval .)


state 39

    (31) fact -> CHAR .

    MUL             reduce using rule 31 (fact -> CHAR .)
    DIV             reduce using rule 31 (fact -> CHAR .)
    MOD             reduce using rule 31 (fact -> CHAR .)
    SCOLON          reduce using rule 31 (fact -> CHAR .)
    PLUS            reduce using rule 31 (fact -> CHAR .)
    MINUS           reduce using rule 31 (fact -> CHAR .)
    DEQUAL          reduce using rule 31 (fact -> CHAR .)
    GTHEN           reduce using rule 31 (fact -> CHAR .)
    LTHEN           reduce using rule 31 (fact -> CHAR .)
    NOT             reduce using rule 31 (fact -> CHAR .)
    RPAREN          reduce using rule 31 (fact -> CHAR .)
    AND             reduce using rule 31 (fact -> CHAR .)
    OR              reduce using rule 31 (fact -> CHAR .)


state 40

    (32) bval -> TRUE .

    MUL             reduce using rule 32 (bval -> TRUE .)
    DIV             reduce using rule 32 (bval -> TRUE .)
    MOD             reduce using rule 32 (bval -> TRUE .)
    SCOLON          reduce using rule 32 (bval -> TRUE .)
    PLUS            reduce using rule 32 (bval -> TRUE .)
    MINUS           reduce using rule 32 (bval -> TRUE .)
    RPAREN          reduce using rule 32 (bval -> TRUE .)
    DEQUAL          reduce using rule 32 (bval -> TRUE .)
    GTHEN           reduce using rule 32 (bval -> TRUE .)
    LTHEN           reduce using rule 32 (bval -> TRUE .)
    NOT             reduce using rule 32 (bval -> TRUE .)
    AND             reduce using rule 32 (bval -> TRUE .)
    OR              reduce using rule 32 (bval -> TRUE .)


state 41

    (33) bval -> FALSE .

    MUL             reduce using rule 33 (bval -> FALSE .)
    DIV             reduce using rule 33 (bval -> FALSE .)
    MOD             reduce using rule 33 (bval -> FALSE .)
    SCOLON          reduce using rule 33 (bval -> FALSE .)
    PLUS            reduce using rule 33 (bval -> FALSE .)
    MINUS           reduce using rule 33 (bval -> FALSE .)
    RPAREN          reduce using rule 33 (bval -> FALSE .)
    DEQUAL          reduce using rule 33 (bval -> FALSE .)
    GTHEN           reduce using rule 33 (bval -> FALSE .)
    LTHEN           reduce using rule 33 (bval -> FALSE .)
    NOT             reduce using rule 33 (bval -> FALSE .)
    AND             reduce using rule 33 (bval -> FALSE .)
    OR              reduce using rule 33 (bval -> FALSE .)


state 42

    (4) nline -> STR var SCOLON .

    STR             reduce using rule 4 (nline -> STR var SCOLON .)
    BOOL            reduce using rule 4 (nline -> STR var SCOLON .)
    RETURN          reduce using rule 4 (nline -> STR var SCOLON .)
    EXIT            reduce using rule 4 (nline -> STR var SCOLON .)
    PRINT           reduce using rule 4 (nline -> STR var SCOLON .)
    FOR             reduce using rule 4 (nline -> STR var SCOLON .)
    WHILE           reduce using rule 4 (nline -> STR var SCOLON .)
    INT             reduce using rule 4 (nline -> STR var SCOLON .)
    FLT             reduce using rule 4 (nline -> STR var SCOLON .)
    CHR             reduce using rule 4 (nline -> STR var SCOLON .)
    IF              reduce using rule 4 (nline -> STR var SCOLON .)
    IDVAR           reduce using rule 4 (nline -> STR var SCOLON .)
    $end            reduce using rule 4 (nline -> STR var SCOLON .)
    RCB             reduce using rule 4 (nline -> STR var SCOLON .)
    RPAREN          reduce using rule 4 (nline -> STR var SCOLON .)
    INTEGER         reduce using rule 4 (nline -> STR var SCOLON .)
    FLOAT           reduce using rule 4 (nline -> STR var SCOLON .)
    CHAR            reduce using rule 4 (nline -> STR var SCOLON .)
    TRUE            reduce using rule 4 (nline -> STR var SCOLON .)
    FALSE           reduce using rule 4 (nline -> STR var SCOLON .)


state 43

    (7) nline -> STR var EQUAL . strvar SCOLON
    (39) strvar -> . STRING
    (40) strvar -> . var
    (34) var -> . IDVAR

    STRING          shift and go to state 61
    IDVAR           shift and go to state 18

    var                            shift and go to state 59
    strvar                         shift and go to state 60

state 44

    (8) nline -> BOOL MAIN LPAREN . RPAREN LCB line RCB

    RPAREN          shift and go to state 62


state 45

    (9) nline -> RETURN LPAREN bval . RPAREN SCOLON

    RPAREN          shift and go to state 63


state 46

    (11) nline -> EXIT LPAREN RPAREN . SCOLON

    SCOLON          shift and go to state 64


state 47

    (12) nline -> PRINT LPAREN nline . RPAREN SCOLON

    RPAREN          shift and go to state 65


state 48

    (13) nline -> FOR LPAREN nline . bexp SCOLON nline RPAREN LCB line RCB
    (41) bexp -> . bexp andor bexp2
    (42) bexp -> . bexp2
    (43) bexp2 -> . bexp2 rln exp
    (44) bexp2 -> . exp
    (20) exp -> . exp PLUS term
    (21) exp -> . exp MINUS term
    (22) exp -> . term
    (23) term -> . term MUL fact
    (24) term -> . term DIV fact
    (25) term -> . term MOD fact
    (26) term -> . fact
    (27) fact -> . INTEGER
    (28) fact -> . FLOAT
    (29) fact -> . var
    (30) fact -> . bval
    (31) fact -> . CHAR
    (34) var -> . IDVAR
    (32) bval -> . TRUE
    (33) bval -> . FALSE

    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    CHAR            shift and go to state 39
    IDVAR           shift and go to state 18
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    bexp                           shift and go to state 66
    bexp2                          shift and go to state 50
    exp                            shift and go to state 51
    term                           shift and go to state 34
    fact                           shift and go to state 35
    var                            shift and go to state 32
    bval                           shift and go to state 38

state 49

    (14) nline -> WHILE LPAREN bexp . RPAREN LCB line RCB
    (41) bexp -> bexp . andor bexp2
    (49) andor -> . AND
    (50) andor -> . OR

    RPAREN          shift and go to state 67
    AND             shift and go to state 69
    OR              shift and go to state 70

    andor                          shift and go to state 68

state 50

    (42) bexp -> bexp2 .
    (43) bexp2 -> bexp2 . rln exp
    (45) rln -> . DEQUAL
    (46) rln -> . GTHEN
    (47) rln -> . LTHEN
    (48) rln -> . NOT

    RPAREN          reduce using rule 42 (bexp -> bexp2 .)
    AND             reduce using rule 42 (bexp -> bexp2 .)
    OR              reduce using rule 42 (bexp -> bexp2 .)
    SCOLON          reduce using rule 42 (bexp -> bexp2 .)
    DEQUAL          shift and go to state 72
    GTHEN           shift and go to state 73
    LTHEN           shift and go to state 74
    NOT             shift and go to state 75

    rln                            shift and go to state 71

state 51

    (44) bexp2 -> exp .
    (20) exp -> exp . PLUS term
    (21) exp -> exp . MINUS term

    DEQUAL          reduce using rule 44 (bexp2 -> exp .)
    GTHEN           reduce using rule 44 (bexp2 -> exp .)
    LTHEN           reduce using rule 44 (bexp2 -> exp .)
    NOT             reduce using rule 44 (bexp2 -> exp .)
    RPAREN          reduce using rule 44 (bexp2 -> exp .)
    AND             reduce using rule 44 (bexp2 -> exp .)
    OR              reduce using rule 44 (bexp2 -> exp .)
    SCOLON          reduce using rule 44 (bexp2 -> exp .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55


state 52

    (15) ifsts -> IF LPAREN bexp . RPAREN LCB line RCB elsests
    (41) bexp -> bexp . andor bexp2
    (49) andor -> . AND
    (50) andor -> . OR

    RPAREN          shift and go to state 76
    AND             shift and go to state 69
    OR              shift and go to state 70

    andor                          shift and go to state 68

state 53

    (19) numexp -> var EQUAL exp SCOLON .

    STR             reduce using rule 19 (numexp -> var EQUAL exp SCOLON .)
    BOOL            reduce using rule 19 (numexp -> var EQUAL exp SCOLON .)
    RETURN          reduce using rule 19 (numexp -> var EQUAL exp SCOLON .)
    EXIT            reduce using rule 19 (numexp -> var EQUAL exp SCOLON .)
    PRINT           reduce using rule 19 (numexp -> var EQUAL exp SCOLON .)
    FOR             reduce using rule 19 (numexp -> var EQUAL exp SCOLON .)
    WHILE           reduce using rule 19 (numexp -> var EQUAL exp SCOLON .)
    INT             reduce using rule 19 (numexp -> var EQUAL exp SCOLON .)
    FLT             reduce using rule 19 (numexp -> var EQUAL exp SCOLON .)
    CHR             reduce using rule 19 (numexp -> var EQUAL exp SCOLON .)
    IF              reduce using rule 19 (numexp -> var EQUAL exp SCOLON .)
    IDVAR           reduce using rule 19 (numexp -> var EQUAL exp SCOLON .)
    $end            reduce using rule 19 (numexp -> var EQUAL exp SCOLON .)
    RCB             reduce using rule 19 (numexp -> var EQUAL exp SCOLON .)
    RPAREN          reduce using rule 19 (numexp -> var EQUAL exp SCOLON .)
    INTEGER         reduce using rule 19 (numexp -> var EQUAL exp SCOLON .)
    FLOAT           reduce using rule 19 (numexp -> var EQUAL exp SCOLON .)
    CHAR            reduce using rule 19 (numexp -> var EQUAL exp SCOLON .)
    TRUE            reduce using rule 19 (numexp -> var EQUAL exp SCOLON .)
    FALSE           reduce using rule 19 (numexp -> var EQUAL exp SCOLON .)


state 54

    (20) exp -> exp PLUS . term
    (23) term -> . term MUL fact
    (24) term -> . term DIV fact
    (25) term -> . term MOD fact
    (26) term -> . fact
    (27) fact -> . INTEGER
    (28) fact -> . FLOAT
    (29) fact -> . var
    (30) fact -> . bval
    (31) fact -> . CHAR
    (34) var -> . IDVAR
    (32) bval -> . TRUE
    (33) bval -> . FALSE

    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    CHAR            shift and go to state 39
    IDVAR           shift and go to state 18
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    term                           shift and go to state 77
    fact                           shift and go to state 35
    var                            shift and go to state 32
    bval                           shift and go to state 38

state 55

    (21) exp -> exp MINUS . term
    (23) term -> . term MUL fact
    (24) term -> . term DIV fact
    (25) term -> . term MOD fact
    (26) term -> . fact
    (27) fact -> . INTEGER
    (28) fact -> . FLOAT
    (29) fact -> . var
    (30) fact -> . bval
    (31) fact -> . CHAR
    (34) var -> . IDVAR
    (32) bval -> . TRUE
    (33) bval -> . FALSE

    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    CHAR            shift and go to state 39
    IDVAR           shift and go to state 18
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    term                           shift and go to state 78
    fact                           shift and go to state 35
    var                            shift and go to state 32
    bval                           shift and go to state 38

state 56

    (23) term -> term MUL . fact
    (27) fact -> . INTEGER
    (28) fact -> . FLOAT
    (29) fact -> . var
    (30) fact -> . bval
    (31) fact -> . CHAR
    (34) var -> . IDVAR
    (32) bval -> . TRUE
    (33) bval -> . FALSE

    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    CHAR            shift and go to state 39
    IDVAR           shift and go to state 18
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    fact                           shift and go to state 79
    var                            shift and go to state 32
    bval                           shift and go to state 38

state 57

    (24) term -> term DIV . fact
    (27) fact -> . INTEGER
    (28) fact -> . FLOAT
    (29) fact -> . var
    (30) fact -> . bval
    (31) fact -> . CHAR
    (34) var -> . IDVAR
    (32) bval -> . TRUE
    (33) bval -> . FALSE

    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    CHAR            shift and go to state 39
    IDVAR           shift and go to state 18
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    fact                           shift and go to state 80
    var                            shift and go to state 32
    bval                           shift and go to state 38

state 58

    (25) term -> term MOD . fact
    (27) fact -> . INTEGER
    (28) fact -> . FLOAT
    (29) fact -> . var
    (30) fact -> . bval
    (31) fact -> . CHAR
    (34) var -> . IDVAR
    (32) bval -> . TRUE
    (33) bval -> . FALSE

    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    CHAR            shift and go to state 39
    IDVAR           shift and go to state 18
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    fact                           shift and go to state 81
    var                            shift and go to state 32
    bval                           shift and go to state 38

state 59

    (40) strvar -> var .

    SCOLON          reduce using rule 40 (strvar -> var .)


state 60

    (7) nline -> STR var EQUAL strvar . SCOLON

    SCOLON          shift and go to state 82


state 61

    (39) strvar -> STRING .

    SCOLON          reduce using rule 39 (strvar -> STRING .)


state 62

    (8) nline -> BOOL MAIN LPAREN RPAREN . LCB line RCB

    LCB             shift and go to state 83


state 63

    (9) nline -> RETURN LPAREN bval RPAREN . SCOLON

    SCOLON          shift and go to state 84


state 64

    (11) nline -> EXIT LPAREN RPAREN SCOLON .

    STR             reduce using rule 11 (nline -> EXIT LPAREN RPAREN SCOLON .)
    BOOL            reduce using rule 11 (nline -> EXIT LPAREN RPAREN SCOLON .)
    RETURN          reduce using rule 11 (nline -> EXIT LPAREN RPAREN SCOLON .)
    EXIT            reduce using rule 11 (nline -> EXIT LPAREN RPAREN SCOLON .)
    PRINT           reduce using rule 11 (nline -> EXIT LPAREN RPAREN SCOLON .)
    FOR             reduce using rule 11 (nline -> EXIT LPAREN RPAREN SCOLON .)
    WHILE           reduce using rule 11 (nline -> EXIT LPAREN RPAREN SCOLON .)
    INT             reduce using rule 11 (nline -> EXIT LPAREN RPAREN SCOLON .)
    FLT             reduce using rule 11 (nline -> EXIT LPAREN RPAREN SCOLON .)
    CHR             reduce using rule 11 (nline -> EXIT LPAREN RPAREN SCOLON .)
    IF              reduce using rule 11 (nline -> EXIT LPAREN RPAREN SCOLON .)
    IDVAR           reduce using rule 11 (nline -> EXIT LPAREN RPAREN SCOLON .)
    $end            reduce using rule 11 (nline -> EXIT LPAREN RPAREN SCOLON .)
    RCB             reduce using rule 11 (nline -> EXIT LPAREN RPAREN SCOLON .)
    RPAREN          reduce using rule 11 (nline -> EXIT LPAREN RPAREN SCOLON .)
    INTEGER         reduce using rule 11 (nline -> EXIT LPAREN RPAREN SCOLON .)
    FLOAT           reduce using rule 11 (nline -> EXIT LPAREN RPAREN SCOLON .)
    CHAR            reduce using rule 11 (nline -> EXIT LPAREN RPAREN SCOLON .)
    TRUE            reduce using rule 11 (nline -> EXIT LPAREN RPAREN SCOLON .)
    FALSE           reduce using rule 11 (nline -> EXIT LPAREN RPAREN SCOLON .)


state 65

    (12) nline -> PRINT LPAREN nline RPAREN . SCOLON

    SCOLON          shift and go to state 85


state 66

    (13) nline -> FOR LPAREN nline bexp . SCOLON nline RPAREN LCB line RCB
    (41) bexp -> bexp . andor bexp2
    (49) andor -> . AND
    (50) andor -> . OR

    SCOLON          shift and go to state 86
    AND             shift and go to state 69
    OR              shift and go to state 70

    andor                          shift and go to state 68

state 67

    (14) nline -> WHILE LPAREN bexp RPAREN . LCB line RCB

    LCB             shift and go to state 87


state 68

    (41) bexp -> bexp andor . bexp2
    (43) bexp2 -> . bexp2 rln exp
    (44) bexp2 -> . exp
    (20) exp -> . exp PLUS term
    (21) exp -> . exp MINUS term
    (22) exp -> . term
    (23) term -> . term MUL fact
    (24) term -> . term DIV fact
    (25) term -> . term MOD fact
    (26) term -> . fact
    (27) fact -> . INTEGER
    (28) fact -> . FLOAT
    (29) fact -> . var
    (30) fact -> . bval
    (31) fact -> . CHAR
    (34) var -> . IDVAR
    (32) bval -> . TRUE
    (33) bval -> . FALSE

    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    CHAR            shift and go to state 39
    IDVAR           shift and go to state 18
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    bexp2                          shift and go to state 88
    exp                            shift and go to state 51
    term                           shift and go to state 34
    fact                           shift and go to state 35
    var                            shift and go to state 32
    bval                           shift and go to state 38

state 69

    (49) andor -> AND .

    INTEGER         reduce using rule 49 (andor -> AND .)
    FLOAT           reduce using rule 49 (andor -> AND .)
    CHAR            reduce using rule 49 (andor -> AND .)
    IDVAR           reduce using rule 49 (andor -> AND .)
    TRUE            reduce using rule 49 (andor -> AND .)
    FALSE           reduce using rule 49 (andor -> AND .)


state 70

    (50) andor -> OR .

    INTEGER         reduce using rule 50 (andor -> OR .)
    FLOAT           reduce using rule 50 (andor -> OR .)
    CHAR            reduce using rule 50 (andor -> OR .)
    IDVAR           reduce using rule 50 (andor -> OR .)
    TRUE            reduce using rule 50 (andor -> OR .)
    FALSE           reduce using rule 50 (andor -> OR .)


state 71

    (43) bexp2 -> bexp2 rln . exp
    (20) exp -> . exp PLUS term
    (21) exp -> . exp MINUS term
    (22) exp -> . term
    (23) term -> . term MUL fact
    (24) term -> . term DIV fact
    (25) term -> . term MOD fact
    (26) term -> . fact
    (27) fact -> . INTEGER
    (28) fact -> . FLOAT
    (29) fact -> . var
    (30) fact -> . bval
    (31) fact -> . CHAR
    (34) var -> . IDVAR
    (32) bval -> . TRUE
    (33) bval -> . FALSE

    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    CHAR            shift and go to state 39
    IDVAR           shift and go to state 18
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41

    exp                            shift and go to state 89
    term                           shift and go to state 34
    fact                           shift and go to state 35
    var                            shift and go to state 32
    bval                           shift and go to state 38

state 72

    (45) rln -> DEQUAL .

    INTEGER         reduce using rule 45 (rln -> DEQUAL .)
    FLOAT           reduce using rule 45 (rln -> DEQUAL .)
    CHAR            reduce using rule 45 (rln -> DEQUAL .)
    IDVAR           reduce using rule 45 (rln -> DEQUAL .)
    TRUE            reduce using rule 45 (rln -> DEQUAL .)
    FALSE           reduce using rule 45 (rln -> DEQUAL .)


state 73

    (46) rln -> GTHEN .

    INTEGER         reduce using rule 46 (rln -> GTHEN .)
    FLOAT           reduce using rule 46 (rln -> GTHEN .)
    CHAR            reduce using rule 46 (rln -> GTHEN .)
    IDVAR           reduce using rule 46 (rln -> GTHEN .)
    TRUE            reduce using rule 46 (rln -> GTHEN .)
    FALSE           reduce using rule 46 (rln -> GTHEN .)


state 74

    (47) rln -> LTHEN .

    INTEGER         reduce using rule 47 (rln -> LTHEN .)
    FLOAT           reduce using rule 47 (rln -> LTHEN .)
    CHAR            reduce using rule 47 (rln -> LTHEN .)
    IDVAR           reduce using rule 47 (rln -> LTHEN .)
    TRUE            reduce using rule 47 (rln -> LTHEN .)
    FALSE           reduce using rule 47 (rln -> LTHEN .)


state 75

    (48) rln -> NOT .

    INTEGER         reduce using rule 48 (rln -> NOT .)
    FLOAT           reduce using rule 48 (rln -> NOT .)
    CHAR            reduce using rule 48 (rln -> NOT .)
    IDVAR           reduce using rule 48 (rln -> NOT .)
    TRUE            reduce using rule 48 (rln -> NOT .)
    FALSE           reduce using rule 48 (rln -> NOT .)


state 76

    (15) ifsts -> IF LPAREN bexp RPAREN . LCB line RCB elsests

    LCB             shift and go to state 90


state 77

    (20) exp -> exp PLUS term .
    (23) term -> term . MUL fact
    (24) term -> term . DIV fact
    (25) term -> term . MOD fact

    SCOLON          reduce using rule 20 (exp -> exp PLUS term .)
    PLUS            reduce using rule 20 (exp -> exp PLUS term .)
    MINUS           reduce using rule 20 (exp -> exp PLUS term .)
    DEQUAL          reduce using rule 20 (exp -> exp PLUS term .)
    GTHEN           reduce using rule 20 (exp -> exp PLUS term .)
    LTHEN           reduce using rule 20 (exp -> exp PLUS term .)
    NOT             reduce using rule 20 (exp -> exp PLUS term .)
    RPAREN          reduce using rule 20 (exp -> exp PLUS term .)
    AND             reduce using rule 20 (exp -> exp PLUS term .)
    OR              reduce using rule 20 (exp -> exp PLUS term .)
    MUL             shift and go to state 56
    DIV             shift and go to state 57
    MOD             shift and go to state 58


state 78

    (21) exp -> exp MINUS term .
    (23) term -> term . MUL fact
    (24) term -> term . DIV fact
    (25) term -> term . MOD fact

    SCOLON          reduce using rule 21 (exp -> exp MINUS term .)
    PLUS            reduce using rule 21 (exp -> exp MINUS term .)
    MINUS           reduce using rule 21 (exp -> exp MINUS term .)
    DEQUAL          reduce using rule 21 (exp -> exp MINUS term .)
    GTHEN           reduce using rule 21 (exp -> exp MINUS term .)
    LTHEN           reduce using rule 21 (exp -> exp MINUS term .)
    NOT             reduce using rule 21 (exp -> exp MINUS term .)
    RPAREN          reduce using rule 21 (exp -> exp MINUS term .)
    AND             reduce using rule 21 (exp -> exp MINUS term .)
    OR              reduce using rule 21 (exp -> exp MINUS term .)
    MUL             shift and go to state 56
    DIV             shift and go to state 57
    MOD             shift and go to state 58


state 79

    (23) term -> term MUL fact .

    MUL             reduce using rule 23 (term -> term MUL fact .)
    DIV             reduce using rule 23 (term -> term MUL fact .)
    MOD             reduce using rule 23 (term -> term MUL fact .)
    SCOLON          reduce using rule 23 (term -> term MUL fact .)
    PLUS            reduce using rule 23 (term -> term MUL fact .)
    MINUS           reduce using rule 23 (term -> term MUL fact .)
    DEQUAL          reduce using rule 23 (term -> term MUL fact .)
    GTHEN           reduce using rule 23 (term -> term MUL fact .)
    LTHEN           reduce using rule 23 (term -> term MUL fact .)
    NOT             reduce using rule 23 (term -> term MUL fact .)
    RPAREN          reduce using rule 23 (term -> term MUL fact .)
    AND             reduce using rule 23 (term -> term MUL fact .)
    OR              reduce using rule 23 (term -> term MUL fact .)


state 80

    (24) term -> term DIV fact .

    MUL             reduce using rule 24 (term -> term DIV fact .)
    DIV             reduce using rule 24 (term -> term DIV fact .)
    MOD             reduce using rule 24 (term -> term DIV fact .)
    SCOLON          reduce using rule 24 (term -> term DIV fact .)
    PLUS            reduce using rule 24 (term -> term DIV fact .)
    MINUS           reduce using rule 24 (term -> term DIV fact .)
    DEQUAL          reduce using rule 24 (term -> term DIV fact .)
    GTHEN           reduce using rule 24 (term -> term DIV fact .)
    LTHEN           reduce using rule 24 (term -> term DIV fact .)
    NOT             reduce using rule 24 (term -> term DIV fact .)
    RPAREN          reduce using rule 24 (term -> term DIV fact .)
    AND             reduce using rule 24 (term -> term DIV fact .)
    OR              reduce using rule 24 (term -> term DIV fact .)


state 81

    (25) term -> term MOD fact .

    MUL             reduce using rule 25 (term -> term MOD fact .)
    DIV             reduce using rule 25 (term -> term MOD fact .)
    MOD             reduce using rule 25 (term -> term MOD fact .)
    SCOLON          reduce using rule 25 (term -> term MOD fact .)
    PLUS            reduce using rule 25 (term -> term MOD fact .)
    MINUS           reduce using rule 25 (term -> term MOD fact .)
    DEQUAL          reduce using rule 25 (term -> term MOD fact .)
    GTHEN           reduce using rule 25 (term -> term MOD fact .)
    LTHEN           reduce using rule 25 (term -> term MOD fact .)
    NOT             reduce using rule 25 (term -> term MOD fact .)
    RPAREN          reduce using rule 25 (term -> term MOD fact .)
    AND             reduce using rule 25 (term -> term MOD fact .)
    OR              reduce using rule 25 (term -> term MOD fact .)


state 82

    (7) nline -> STR var EQUAL strvar SCOLON .

    STR             reduce using rule 7 (nline -> STR var EQUAL strvar SCOLON .)
    BOOL            reduce using rule 7 (nline -> STR var EQUAL strvar SCOLON .)
    RETURN          reduce using rule 7 (nline -> STR var EQUAL strvar SCOLON .)
    EXIT            reduce using rule 7 (nline -> STR var EQUAL strvar SCOLON .)
    PRINT           reduce using rule 7 (nline -> STR var EQUAL strvar SCOLON .)
    FOR             reduce using rule 7 (nline -> STR var EQUAL strvar SCOLON .)
    WHILE           reduce using rule 7 (nline -> STR var EQUAL strvar SCOLON .)
    INT             reduce using rule 7 (nline -> STR var EQUAL strvar SCOLON .)
    FLT             reduce using rule 7 (nline -> STR var EQUAL strvar SCOLON .)
    CHR             reduce using rule 7 (nline -> STR var EQUAL strvar SCOLON .)
    IF              reduce using rule 7 (nline -> STR var EQUAL strvar SCOLON .)
    IDVAR           reduce using rule 7 (nline -> STR var EQUAL strvar SCOLON .)
    $end            reduce using rule 7 (nline -> STR var EQUAL strvar SCOLON .)
    RCB             reduce using rule 7 (nline -> STR var EQUAL strvar SCOLON .)
    RPAREN          reduce using rule 7 (nline -> STR var EQUAL strvar SCOLON .)
    INTEGER         reduce using rule 7 (nline -> STR var EQUAL strvar SCOLON .)
    FLOAT           reduce using rule 7 (nline -> STR var EQUAL strvar SCOLON .)
    CHAR            reduce using rule 7 (nline -> STR var EQUAL strvar SCOLON .)
    TRUE            reduce using rule 7 (nline -> STR var EQUAL strvar SCOLON .)
    FALSE           reduce using rule 7 (nline -> STR var EQUAL strvar SCOLON .)


state 83

    (8) nline -> BOOL MAIN LPAREN RPAREN LCB . line RCB
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . dtype numexp
    (6) nline -> . numexp
    (7) nline -> . STR var EQUAL strvar SCOLON
    (8) nline -> . BOOL MAIN LPAREN RPAREN LCB line RCB
    (9) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (10) nline -> . ifsts
    (11) nline -> . EXIT LPAREN RPAREN SCOLON
    (12) nline -> . PRINT LPAREN nline RPAREN SCOLON
    (13) nline -> . FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB
    (14) nline -> . WHILE LPAREN bexp RPAREN LCB line RCB
    (35) dtype -> . INT
    (36) dtype -> . FLT
    (37) dtype -> . CHR
    (38) dtype -> . BOOL
    (19) numexp -> . var EQUAL exp SCOLON
    (15) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests
    (34) var -> . IDVAR

    STR             shift and go to state 5
    BOOL            shift and go to state 7
    RETURN          shift and go to state 8
    EXIT            shift and go to state 10
    PRINT           shift and go to state 11
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    INT             shift and go to state 14
    FLT             shift and go to state 15
    CHR             shift and go to state 16
    IF              shift and go to state 17
    IDVAR           shift and go to state 18

    line                           shift and go to state 91
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    numexp                         shift and go to state 6
    ifsts                          shift and go to state 9

state 84

    (9) nline -> RETURN LPAREN bval RPAREN SCOLON .

    STR             reduce using rule 9 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    BOOL            reduce using rule 9 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    RETURN          reduce using rule 9 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    EXIT            reduce using rule 9 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    PRINT           reduce using rule 9 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    FOR             reduce using rule 9 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    WHILE           reduce using rule 9 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    INT             reduce using rule 9 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    FLT             reduce using rule 9 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    CHR             reduce using rule 9 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    IF              reduce using rule 9 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    IDVAR           reduce using rule 9 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    $end            reduce using rule 9 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    RCB             reduce using rule 9 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    RPAREN          reduce using rule 9 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    INTEGER         reduce using rule 9 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    FLOAT           reduce using rule 9 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    CHAR            reduce using rule 9 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    TRUE            reduce using rule 9 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    FALSE           reduce using rule 9 (nline -> RETURN LPAREN bval RPAREN SCOLON .)


state 85

    (12) nline -> PRINT LPAREN nline RPAREN SCOLON .

    STR             reduce using rule 12 (nline -> PRINT LPAREN nline RPAREN SCOLON .)
    BOOL            reduce using rule 12 (nline -> PRINT LPAREN nline RPAREN SCOLON .)
    RETURN          reduce using rule 12 (nline -> PRINT LPAREN nline RPAREN SCOLON .)
    EXIT            reduce using rule 12 (nline -> PRINT LPAREN nline RPAREN SCOLON .)
    PRINT           reduce using rule 12 (nline -> PRINT LPAREN nline RPAREN SCOLON .)
    FOR             reduce using rule 12 (nline -> PRINT LPAREN nline RPAREN SCOLON .)
    WHILE           reduce using rule 12 (nline -> PRINT LPAREN nline RPAREN SCOLON .)
    INT             reduce using rule 12 (nline -> PRINT LPAREN nline RPAREN SCOLON .)
    FLT             reduce using rule 12 (nline -> PRINT LPAREN nline RPAREN SCOLON .)
    CHR             reduce using rule 12 (nline -> PRINT LPAREN nline RPAREN SCOLON .)
    IF              reduce using rule 12 (nline -> PRINT LPAREN nline RPAREN SCOLON .)
    IDVAR           reduce using rule 12 (nline -> PRINT LPAREN nline RPAREN SCOLON .)
    $end            reduce using rule 12 (nline -> PRINT LPAREN nline RPAREN SCOLON .)
    RCB             reduce using rule 12 (nline -> PRINT LPAREN nline RPAREN SCOLON .)
    RPAREN          reduce using rule 12 (nline -> PRINT LPAREN nline RPAREN SCOLON .)
    INTEGER         reduce using rule 12 (nline -> PRINT LPAREN nline RPAREN SCOLON .)
    FLOAT           reduce using rule 12 (nline -> PRINT LPAREN nline RPAREN SCOLON .)
    CHAR            reduce using rule 12 (nline -> PRINT LPAREN nline RPAREN SCOLON .)
    TRUE            reduce using rule 12 (nline -> PRINT LPAREN nline RPAREN SCOLON .)
    FALSE           reduce using rule 12 (nline -> PRINT LPAREN nline RPAREN SCOLON .)


state 86

    (13) nline -> FOR LPAREN nline bexp SCOLON . nline RPAREN LCB line RCB
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . dtype numexp
    (6) nline -> . numexp
    (7) nline -> . STR var EQUAL strvar SCOLON
    (8) nline -> . BOOL MAIN LPAREN RPAREN LCB line RCB
    (9) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (10) nline -> . ifsts
    (11) nline -> . EXIT LPAREN RPAREN SCOLON
    (12) nline -> . PRINT LPAREN nline RPAREN SCOLON
    (13) nline -> . FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB
    (14) nline -> . WHILE LPAREN bexp RPAREN LCB line RCB
    (35) dtype -> . INT
    (36) dtype -> . FLT
    (37) dtype -> . CHR
    (38) dtype -> . BOOL
    (19) numexp -> . var EQUAL exp SCOLON
    (15) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests
    (34) var -> . IDVAR

    STR             shift and go to state 5
    BOOL            shift and go to state 7
    RETURN          shift and go to state 8
    EXIT            shift and go to state 10
    PRINT           shift and go to state 11
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    INT             shift and go to state 14
    FLT             shift and go to state 15
    CHR             shift and go to state 16
    IF              shift and go to state 17
    IDVAR           shift and go to state 18

    nline                          shift and go to state 92
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    numexp                         shift and go to state 6
    ifsts                          shift and go to state 9

state 87

    (14) nline -> WHILE LPAREN bexp RPAREN LCB . line RCB
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . dtype numexp
    (6) nline -> . numexp
    (7) nline -> . STR var EQUAL strvar SCOLON
    (8) nline -> . BOOL MAIN LPAREN RPAREN LCB line RCB
    (9) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (10) nline -> . ifsts
    (11) nline -> . EXIT LPAREN RPAREN SCOLON
    (12) nline -> . PRINT LPAREN nline RPAREN SCOLON
    (13) nline -> . FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB
    (14) nline -> . WHILE LPAREN bexp RPAREN LCB line RCB
    (35) dtype -> . INT
    (36) dtype -> . FLT
    (37) dtype -> . CHR
    (38) dtype -> . BOOL
    (19) numexp -> . var EQUAL exp SCOLON
    (15) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests
    (34) var -> . IDVAR

    STR             shift and go to state 5
    BOOL            shift and go to state 7
    RETURN          shift and go to state 8
    EXIT            shift and go to state 10
    PRINT           shift and go to state 11
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    INT             shift and go to state 14
    FLT             shift and go to state 15
    CHR             shift and go to state 16
    IF              shift and go to state 17
    IDVAR           shift and go to state 18

    line                           shift and go to state 93
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    numexp                         shift and go to state 6
    ifsts                          shift and go to state 9

state 88

    (41) bexp -> bexp andor bexp2 .
    (43) bexp2 -> bexp2 . rln exp
    (45) rln -> . DEQUAL
    (46) rln -> . GTHEN
    (47) rln -> . LTHEN
    (48) rln -> . NOT

    RPAREN          reduce using rule 41 (bexp -> bexp andor bexp2 .)
    AND             reduce using rule 41 (bexp -> bexp andor bexp2 .)
    OR              reduce using rule 41 (bexp -> bexp andor bexp2 .)
    SCOLON          reduce using rule 41 (bexp -> bexp andor bexp2 .)
    DEQUAL          shift and go to state 72
    GTHEN           shift and go to state 73
    LTHEN           shift and go to state 74
    NOT             shift and go to state 75

    rln                            shift and go to state 71

state 89

    (43) bexp2 -> bexp2 rln exp .
    (20) exp -> exp . PLUS term
    (21) exp -> exp . MINUS term

    DEQUAL          reduce using rule 43 (bexp2 -> bexp2 rln exp .)
    GTHEN           reduce using rule 43 (bexp2 -> bexp2 rln exp .)
    LTHEN           reduce using rule 43 (bexp2 -> bexp2 rln exp .)
    NOT             reduce using rule 43 (bexp2 -> bexp2 rln exp .)
    RPAREN          reduce using rule 43 (bexp2 -> bexp2 rln exp .)
    AND             reduce using rule 43 (bexp2 -> bexp2 rln exp .)
    OR              reduce using rule 43 (bexp2 -> bexp2 rln exp .)
    SCOLON          reduce using rule 43 (bexp2 -> bexp2 rln exp .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55


state 90

    (15) ifsts -> IF LPAREN bexp RPAREN LCB . line RCB elsests
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . dtype numexp
    (6) nline -> . numexp
    (7) nline -> . STR var EQUAL strvar SCOLON
    (8) nline -> . BOOL MAIN LPAREN RPAREN LCB line RCB
    (9) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (10) nline -> . ifsts
    (11) nline -> . EXIT LPAREN RPAREN SCOLON
    (12) nline -> . PRINT LPAREN nline RPAREN SCOLON
    (13) nline -> . FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB
    (14) nline -> . WHILE LPAREN bexp RPAREN LCB line RCB
    (35) dtype -> . INT
    (36) dtype -> . FLT
    (37) dtype -> . CHR
    (38) dtype -> . BOOL
    (19) numexp -> . var EQUAL exp SCOLON
    (15) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests
    (34) var -> . IDVAR

    STR             shift and go to state 5
    BOOL            shift and go to state 7
    RETURN          shift and go to state 8
    EXIT            shift and go to state 10
    PRINT           shift and go to state 11
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    INT             shift and go to state 14
    FLT             shift and go to state 15
    CHR             shift and go to state 16
    IF              shift and go to state 17
    IDVAR           shift and go to state 18

    line                           shift and go to state 94
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    numexp                         shift and go to state 6
    ifsts                          shift and go to state 9

state 91

    (8) nline -> BOOL MAIN LPAREN RPAREN LCB line . RCB

    RCB             shift and go to state 95


state 92

    (13) nline -> FOR LPAREN nline bexp SCOLON nline . RPAREN LCB line RCB

    RPAREN          shift and go to state 96


state 93

    (14) nline -> WHILE LPAREN bexp RPAREN LCB line . RCB

    RCB             shift and go to state 97


state 94

    (15) ifsts -> IF LPAREN bexp RPAREN LCB line . RCB elsests

    RCB             shift and go to state 98


state 95

    (8) nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .

    STR             reduce using rule 8 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    BOOL            reduce using rule 8 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    RETURN          reduce using rule 8 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    EXIT            reduce using rule 8 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    PRINT           reduce using rule 8 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    FOR             reduce using rule 8 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    WHILE           reduce using rule 8 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    INT             reduce using rule 8 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    FLT             reduce using rule 8 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    CHR             reduce using rule 8 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    IF              reduce using rule 8 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    IDVAR           reduce using rule 8 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    $end            reduce using rule 8 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    RCB             reduce using rule 8 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    RPAREN          reduce using rule 8 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    INTEGER         reduce using rule 8 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    FLOAT           reduce using rule 8 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    CHAR            reduce using rule 8 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    TRUE            reduce using rule 8 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    FALSE           reduce using rule 8 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)


state 96

    (13) nline -> FOR LPAREN nline bexp SCOLON nline RPAREN . LCB line RCB

    LCB             shift and go to state 99


state 97

    (14) nline -> WHILE LPAREN bexp RPAREN LCB line RCB .

    STR             reduce using rule 14 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    BOOL            reduce using rule 14 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    RETURN          reduce using rule 14 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    EXIT            reduce using rule 14 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    PRINT           reduce using rule 14 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    FOR             reduce using rule 14 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    WHILE           reduce using rule 14 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    INT             reduce using rule 14 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    FLT             reduce using rule 14 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    CHR             reduce using rule 14 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    IF              reduce using rule 14 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    IDVAR           reduce using rule 14 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    $end            reduce using rule 14 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    RCB             reduce using rule 14 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    RPAREN          reduce using rule 14 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    INTEGER         reduce using rule 14 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    FLOAT           reduce using rule 14 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    CHAR            reduce using rule 14 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    TRUE            reduce using rule 14 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    FALSE           reduce using rule 14 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)


state 98

    (15) ifsts -> IF LPAREN bexp RPAREN LCB line RCB . elsests
    (16) elsests -> . ELSE LCB line RCB
    (17) elsests -> . ELSE ifsts
    (18) elsests -> . empty
    (51) empty -> .

    ELSE            shift and go to state 101
    STR             reduce using rule 51 (empty -> .)
    BOOL            reduce using rule 51 (empty -> .)
    RETURN          reduce using rule 51 (empty -> .)
    EXIT            reduce using rule 51 (empty -> .)
    PRINT           reduce using rule 51 (empty -> .)
    FOR             reduce using rule 51 (empty -> .)
    WHILE           reduce using rule 51 (empty -> .)
    INT             reduce using rule 51 (empty -> .)
    FLT             reduce using rule 51 (empty -> .)
    CHR             reduce using rule 51 (empty -> .)
    IF              reduce using rule 51 (empty -> .)
    IDVAR           reduce using rule 51 (empty -> .)
    $end            reduce using rule 51 (empty -> .)
    RCB             reduce using rule 51 (empty -> .)
    RPAREN          reduce using rule 51 (empty -> .)
    INTEGER         reduce using rule 51 (empty -> .)
    FLOAT           reduce using rule 51 (empty -> .)
    CHAR            reduce using rule 51 (empty -> .)
    TRUE            reduce using rule 51 (empty -> .)
    FALSE           reduce using rule 51 (empty -> .)

    elsests                        shift and go to state 100
    empty                          shift and go to state 102

state 99

    (13) nline -> FOR LPAREN nline bexp SCOLON nline RPAREN LCB . line RCB
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . dtype numexp
    (6) nline -> . numexp
    (7) nline -> . STR var EQUAL strvar SCOLON
    (8) nline -> . BOOL MAIN LPAREN RPAREN LCB line RCB
    (9) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (10) nline -> . ifsts
    (11) nline -> . EXIT LPAREN RPAREN SCOLON
    (12) nline -> . PRINT LPAREN nline RPAREN SCOLON
    (13) nline -> . FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB
    (14) nline -> . WHILE LPAREN bexp RPAREN LCB line RCB
    (35) dtype -> . INT
    (36) dtype -> . FLT
    (37) dtype -> . CHR
    (38) dtype -> . BOOL
    (19) numexp -> . var EQUAL exp SCOLON
    (15) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests
    (34) var -> . IDVAR

    STR             shift and go to state 5
    BOOL            shift and go to state 7
    RETURN          shift and go to state 8
    EXIT            shift and go to state 10
    PRINT           shift and go to state 11
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    INT             shift and go to state 14
    FLT             shift and go to state 15
    CHR             shift and go to state 16
    IF              shift and go to state 17
    IDVAR           shift and go to state 18

    nline                          shift and go to state 2
    line                           shift and go to state 103
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    numexp                         shift and go to state 6
    ifsts                          shift and go to state 9

state 100

    (15) ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .

    STR             reduce using rule 15 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    BOOL            reduce using rule 15 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    RETURN          reduce using rule 15 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    EXIT            reduce using rule 15 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    PRINT           reduce using rule 15 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    FOR             reduce using rule 15 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    WHILE           reduce using rule 15 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    INT             reduce using rule 15 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    FLT             reduce using rule 15 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    CHR             reduce using rule 15 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    IF              reduce using rule 15 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    IDVAR           reduce using rule 15 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    $end            reduce using rule 15 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    RCB             reduce using rule 15 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    RPAREN          reduce using rule 15 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    INTEGER         reduce using rule 15 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    FLOAT           reduce using rule 15 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    CHAR            reduce using rule 15 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    TRUE            reduce using rule 15 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    FALSE           reduce using rule 15 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)


state 101

    (16) elsests -> ELSE . LCB line RCB
    (17) elsests -> ELSE . ifsts
    (15) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests

    LCB             shift and go to state 104
    IF              shift and go to state 17

    ifsts                          shift and go to state 105

state 102

    (18) elsests -> empty .

    STR             reduce using rule 18 (elsests -> empty .)
    BOOL            reduce using rule 18 (elsests -> empty .)
    RETURN          reduce using rule 18 (elsests -> empty .)
    EXIT            reduce using rule 18 (elsests -> empty .)
    PRINT           reduce using rule 18 (elsests -> empty .)
    FOR             reduce using rule 18 (elsests -> empty .)
    WHILE           reduce using rule 18 (elsests -> empty .)
    INT             reduce using rule 18 (elsests -> empty .)
    FLT             reduce using rule 18 (elsests -> empty .)
    CHR             reduce using rule 18 (elsests -> empty .)
    IF              reduce using rule 18 (elsests -> empty .)
    IDVAR           reduce using rule 18 (elsests -> empty .)
    $end            reduce using rule 18 (elsests -> empty .)
    RCB             reduce using rule 18 (elsests -> empty .)
    RPAREN          reduce using rule 18 (elsests -> empty .)
    INTEGER         reduce using rule 18 (elsests -> empty .)
    FLOAT           reduce using rule 18 (elsests -> empty .)
    CHAR            reduce using rule 18 (elsests -> empty .)
    TRUE            reduce using rule 18 (elsests -> empty .)
    FALSE           reduce using rule 18 (elsests -> empty .)


state 103

    (13) nline -> FOR LPAREN nline bexp SCOLON nline RPAREN LCB line . RCB

    RCB             shift and go to state 106


state 104

    (16) elsests -> ELSE LCB . line RCB
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . dtype numexp
    (6) nline -> . numexp
    (7) nline -> . STR var EQUAL strvar SCOLON
    (8) nline -> . BOOL MAIN LPAREN RPAREN LCB line RCB
    (9) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (10) nline -> . ifsts
    (11) nline -> . EXIT LPAREN RPAREN SCOLON
    (12) nline -> . PRINT LPAREN nline RPAREN SCOLON
    (13) nline -> . FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB
    (14) nline -> . WHILE LPAREN bexp RPAREN LCB line RCB
    (35) dtype -> . INT
    (36) dtype -> . FLT
    (37) dtype -> . CHR
    (38) dtype -> . BOOL
    (19) numexp -> . var EQUAL exp SCOLON
    (15) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests
    (34) var -> . IDVAR

    STR             shift and go to state 5
    BOOL            shift and go to state 7
    RETURN          shift and go to state 8
    EXIT            shift and go to state 10
    PRINT           shift and go to state 11
    FOR             shift and go to state 12
    WHILE           shift and go to state 13
    INT             shift and go to state 14
    FLT             shift and go to state 15
    CHR             shift and go to state 16
    IF              shift and go to state 17
    IDVAR           shift and go to state 18

    line                           shift and go to state 107
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    numexp                         shift and go to state 6
    ifsts                          shift and go to state 9

state 105

    (17) elsests -> ELSE ifsts .

    STR             reduce using rule 17 (elsests -> ELSE ifsts .)
    BOOL            reduce using rule 17 (elsests -> ELSE ifsts .)
    RETURN          reduce using rule 17 (elsests -> ELSE ifsts .)
    EXIT            reduce using rule 17 (elsests -> ELSE ifsts .)
    PRINT           reduce using rule 17 (elsests -> ELSE ifsts .)
    FOR             reduce using rule 17 (elsests -> ELSE ifsts .)
    WHILE           reduce using rule 17 (elsests -> ELSE ifsts .)
    INT             reduce using rule 17 (elsests -> ELSE ifsts .)
    FLT             reduce using rule 17 (elsests -> ELSE ifsts .)
    CHR             reduce using rule 17 (elsests -> ELSE ifsts .)
    IF              reduce using rule 17 (elsests -> ELSE ifsts .)
    IDVAR           reduce using rule 17 (elsests -> ELSE ifsts .)
    $end            reduce using rule 17 (elsests -> ELSE ifsts .)
    RCB             reduce using rule 17 (elsests -> ELSE ifsts .)
    RPAREN          reduce using rule 17 (elsests -> ELSE ifsts .)
    INTEGER         reduce using rule 17 (elsests -> ELSE ifsts .)
    FLOAT           reduce using rule 17 (elsests -> ELSE ifsts .)
    CHAR            reduce using rule 17 (elsests -> ELSE ifsts .)
    TRUE            reduce using rule 17 (elsests -> ELSE ifsts .)
    FALSE           reduce using rule 17 (elsests -> ELSE ifsts .)


state 106

    (13) nline -> FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB .

    STR             reduce using rule 13 (nline -> FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB .)
    BOOL            reduce using rule 13 (nline -> FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB .)
    RETURN          reduce using rule 13 (nline -> FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB .)
    EXIT            reduce using rule 13 (nline -> FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB .)
    PRINT           reduce using rule 13 (nline -> FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB .)
    FOR             reduce using rule 13 (nline -> FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB .)
    WHILE           reduce using rule 13 (nline -> FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB .)
    INT             reduce using rule 13 (nline -> FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB .)
    FLT             reduce using rule 13 (nline -> FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB .)
    CHR             reduce using rule 13 (nline -> FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB .)
    IF              reduce using rule 13 (nline -> FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB .)
    IDVAR           reduce using rule 13 (nline -> FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB .)
    $end            reduce using rule 13 (nline -> FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB .)
    RCB             reduce using rule 13 (nline -> FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB .)
    RPAREN          reduce using rule 13 (nline -> FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB .)
    INTEGER         reduce using rule 13 (nline -> FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB .)
    FLOAT           reduce using rule 13 (nline -> FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB .)
    CHAR            reduce using rule 13 (nline -> FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB .)
    TRUE            reduce using rule 13 (nline -> FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB .)
    FALSE           reduce using rule 13 (nline -> FOR LPAREN nline bexp SCOLON nline RPAREN LCB line RCB .)


state 107

    (16) elsests -> ELSE LCB line . RCB

    RCB             shift and go to state 108


state 108

    (16) elsests -> ELSE LCB line RCB .

    STR             reduce using rule 16 (elsests -> ELSE LCB line RCB .)
    BOOL            reduce using rule 16 (elsests -> ELSE LCB line RCB .)
    RETURN          reduce using rule 16 (elsests -> ELSE LCB line RCB .)
    EXIT            reduce using rule 16 (elsests -> ELSE LCB line RCB .)
    PRINT           reduce using rule 16 (elsests -> ELSE LCB line RCB .)
    FOR             reduce using rule 16 (elsests -> ELSE LCB line RCB .)
    WHILE           reduce using rule 16 (elsests -> ELSE LCB line RCB .)
    INT             reduce using rule 16 (elsests -> ELSE LCB line RCB .)
    FLT             reduce using rule 16 (elsests -> ELSE LCB line RCB .)
    CHR             reduce using rule 16 (elsests -> ELSE LCB line RCB .)
    IF              reduce using rule 16 (elsests -> ELSE LCB line RCB .)
    IDVAR           reduce using rule 16 (elsests -> ELSE LCB line RCB .)
    $end            reduce using rule 16 (elsests -> ELSE LCB line RCB .)
    RCB             reduce using rule 16 (elsests -> ELSE LCB line RCB .)
    RPAREN          reduce using rule 16 (elsests -> ELSE LCB line RCB .)
    INTEGER         reduce using rule 16 (elsests -> ELSE LCB line RCB .)
    FLOAT           reduce using rule 16 (elsests -> ELSE LCB line RCB .)
    CHAR            reduce using rule 16 (elsests -> ELSE LCB line RCB .)
    TRUE            reduce using rule 16 (elsests -> ELSE LCB line RCB .)
    FALSE           reduce using rule 16 (elsests -> ELSE LCB line RCB .)

