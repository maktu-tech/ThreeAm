Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    VOID
    WITH

Grammar

Rule 0     S' -> line
Rule 1     line -> nline line
Rule 2     line -> nline
Rule 3     nline -> dtype var SCOLON
Rule 4     nline -> STR var SCOLON
Rule 5     nline -> fline
Rule 6     nline -> STR IDVAR EQUAL strvar SCOLON
Rule 7     nline -> BOOL MAIN LPAREN RPAREN LCB line RCB
Rule 8     nline -> RETURN LPAREN bval RPAREN SCOLON
Rule 9     nline -> ifsts
Rule 10    nline -> EXIT LPAREN RPAREN SCOLON
Rule 11    nline -> PRINT LPAREN pline RPAREN SCOLON
Rule 12    pline -> exp
Rule 13    pline -> STRING
Rule 14    nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB
Rule 15    nline -> WHILE LPAREN bexp RPAREN LCB line RCB
Rule 16    ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests
Rule 17    elsests -> ELSE LCB line RCB
Rule 18    elsests -> ELSE ifsts
Rule 19    elsests -> empty
Rule 20    numexp -> assign SCOLON
Rule 21    exp -> exp PLUS term
Rule 22    exp -> exp MINUS term
Rule 23    exp -> term
Rule 24    term -> term MUL fact
Rule 25    term -> term DIV fact
Rule 26    term -> term MOD fact
Rule 27    term -> fact
Rule 28    fact -> INTEGER
Rule 29    fact -> FLOAT
Rule 30    fact -> var
Rule 31    fact -> bval
Rule 32    fact -> CHAR
Rule 33    bval -> TRUE
Rule 34    bval -> FALSE
Rule 35    var -> IDVAR
Rule 36    var -> IDVAR LBB INTEGER RBB
Rule 37    dtype -> INT
Rule 38    dtype -> FLT
Rule 39    dtype -> CHR
Rule 40    dtype -> BOOL
Rule 41    strvar -> STRING
Rule 42    strvar -> var
Rule 43    bexp -> bexp andor bexp2
Rule 44    bexp -> bexp2
Rule 45    bexp2 -> bexp2 rln exp
Rule 46    bexp2 -> exp
Rule 47    rln -> DEQUAL
Rule 48    rln -> GTHEN
Rule 49    rln -> LTHEN
Rule 50    rln -> NOT
Rule 51    andor -> AND
Rule 52    andor -> OR
Rule 53    empty -> <empty>
Rule 54    assign -> var EQUAL exp
Rule 55    fline -> dtype numexp
Rule 56    fline -> numexp
Rule 57    nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON
Rule 58    nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON
Rule 59    arrt -> var
Rule 60    arrt -> LCB dws RCB
Rule 61    dws -> factarr COM dws
Rule 62    dws -> factarr
Rule 63    factarr -> fact
Rule 64    factarr -> STRING

Terminals, with rules where they appear

AND                  : 51
BOOL                 : 7 40
CHAR                 : 32
CHR                  : 39
COM                  : 61
COMMENT              : 
DEQUAL               : 47
DIV                  : 25
ELSE                 : 17 18
EQUAL                : 6 54 57 58
EXIT                 : 10
FALSE                : 34
FLOAT                : 29
FLT                  : 38
FOR                  : 14
GTHEN                : 48
IDVAR                : 6 35 36 57 58
IF                   : 16
INT                  : 37
INTEGER              : 28 36
LBB                  : 36 57 58
LCB                  : 7 14 15 16 17 60
LPAREN               : 7 8 10 11 14 15 16
LTHEN                : 49
MAIN                 : 7
MINUS                : 22
MOD                  : 26
MUL                  : 24
NOT                  : 50
OR                   : 52
PLUS                 : 21
PRINT                : 11
RBB                  : 36 57 58
RCB                  : 7 14 15 16 17 60
RETURN               : 8
RPAREN               : 7 8 10 11 14 15 16
SCOLON               : 3 4 6 8 10 11 14 20 57 58
STR                  : 4 6 58
STRING               : 13 41 64
TRUE                 : 33
VOID                 : 
WHILE                : 15
WITH                 : 
error                : 

Nonterminals, with rules where they appear

andor                : 43
arrt                 : 57 58
assign               : 14 20
bexp                 : 14 15 16 43
bexp2                : 43 44 45
bval                 : 8 31
dtype                : 3 55 57
dws                  : 60 61
elsests              : 16
empty                : 19
exp                  : 12 21 22 45 46 54
fact                 : 24 25 26 27 63
factarr              : 61 62
fline                : 5 14
ifsts                : 9 18
line                 : 1 7 14 15 16 17 0
nline                : 1 2
numexp               : 55 56
pline                : 11
rln                  : 45
strvar               : 6
term                 : 21 22 23 24 25 26
var                  : 3 4 30 42 54 59

Parsing method: LALR

state 0

    (0) S' -> . line
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN LCB line RCB
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB
    (15) nline -> . WHILE LPAREN bexp RPAREN LCB line RCB
    (57) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (58) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (37) dtype -> . INT
    (38) dtype -> . FLT
    (39) dtype -> . CHR
    (40) dtype -> . BOOL
    (55) fline -> . dtype numexp
    (56) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests
    (20) numexp -> . assign SCOLON
    (54) assign -> . var EQUAL exp
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 1
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19

state 1

    (0) S' -> line .



state 2

    (1) line -> nline . line
    (2) line -> nline .
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN LCB line RCB
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB
    (15) nline -> . WHILE LPAREN bexp RPAREN LCB line RCB
    (57) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (58) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (37) dtype -> . INT
    (38) dtype -> . FLT
    (39) dtype -> . CHR
    (40) dtype -> . BOOL
    (55) fline -> . dtype numexp
    (56) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests
    (20) numexp -> . assign SCOLON
    (54) assign -> . var EQUAL exp
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB

    $end            reduce using rule 2 (line -> nline .)
    RCB             reduce using rule 2 (line -> nline .)
    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    nline                          shift and go to state 2
    line                           shift and go to state 21
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19

state 3

    (3) nline -> dtype . var SCOLON
    (57) nline -> dtype . LBB RBB IDVAR EQUAL arrt SCOLON
    (55) fline -> dtype . numexp
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB
    (20) numexp -> . assign SCOLON
    (54) assign -> . var EQUAL exp

    LBB             shift and go to state 23
    IDVAR           shift and go to state 7

    var                            shift and go to state 22
    numexp                         shift and go to state 24
    assign                         shift and go to state 14

state 4

    (54) assign -> var . EQUAL exp

    EQUAL           shift and go to state 25


state 5

    (4) nline -> STR . var SCOLON
    (6) nline -> STR . IDVAR EQUAL strvar SCOLON
    (58) nline -> STR . LBB RBB IDVAR EQUAL arrt SCOLON
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB

    IDVAR           shift and go to state 27
    LBB             shift and go to state 28

    var                            shift and go to state 26

state 6

    (5) nline -> fline .

    STR             reduce using rule 5 (nline -> fline .)
    BOOL            reduce using rule 5 (nline -> fline .)
    RETURN          reduce using rule 5 (nline -> fline .)
    EXIT            reduce using rule 5 (nline -> fline .)
    PRINT           reduce using rule 5 (nline -> fline .)
    FOR             reduce using rule 5 (nline -> fline .)
    WHILE           reduce using rule 5 (nline -> fline .)
    INT             reduce using rule 5 (nline -> fline .)
    FLT             reduce using rule 5 (nline -> fline .)
    CHR             reduce using rule 5 (nline -> fline .)
    IF              reduce using rule 5 (nline -> fline .)
    IDVAR           reduce using rule 5 (nline -> fline .)
    $end            reduce using rule 5 (nline -> fline .)
    RCB             reduce using rule 5 (nline -> fline .)


state 7

    (35) var -> IDVAR .
    (36) var -> IDVAR . LBB INTEGER RBB

    EQUAL           reduce using rule 35 (var -> IDVAR .)
    SCOLON          reduce using rule 35 (var -> IDVAR .)
    MUL             reduce using rule 35 (var -> IDVAR .)
    DIV             reduce using rule 35 (var -> IDVAR .)
    MOD             reduce using rule 35 (var -> IDVAR .)
    PLUS            reduce using rule 35 (var -> IDVAR .)
    MINUS           reduce using rule 35 (var -> IDVAR .)
    RPAREN          reduce using rule 35 (var -> IDVAR .)
    DEQUAL          reduce using rule 35 (var -> IDVAR .)
    GTHEN           reduce using rule 35 (var -> IDVAR .)
    LTHEN           reduce using rule 35 (var -> IDVAR .)
    NOT             reduce using rule 35 (var -> IDVAR .)
    AND             reduce using rule 35 (var -> IDVAR .)
    OR              reduce using rule 35 (var -> IDVAR .)
    COM             reduce using rule 35 (var -> IDVAR .)
    RCB             reduce using rule 35 (var -> IDVAR .)
    LBB             shift and go to state 29


state 8

    (7) nline -> BOOL . MAIN LPAREN RPAREN LCB line RCB
    (40) dtype -> BOOL .

    MAIN            shift and go to state 30
    LBB             reduce using rule 40 (dtype -> BOOL .)
    IDVAR           reduce using rule 40 (dtype -> BOOL .)


state 9

    (8) nline -> RETURN . LPAREN bval RPAREN SCOLON

    LPAREN          shift and go to state 31


state 10

    (9) nline -> ifsts .

    STR             reduce using rule 9 (nline -> ifsts .)
    BOOL            reduce using rule 9 (nline -> ifsts .)
    RETURN          reduce using rule 9 (nline -> ifsts .)
    EXIT            reduce using rule 9 (nline -> ifsts .)
    PRINT           reduce using rule 9 (nline -> ifsts .)
    FOR             reduce using rule 9 (nline -> ifsts .)
    WHILE           reduce using rule 9 (nline -> ifsts .)
    INT             reduce using rule 9 (nline -> ifsts .)
    FLT             reduce using rule 9 (nline -> ifsts .)
    CHR             reduce using rule 9 (nline -> ifsts .)
    IF              reduce using rule 9 (nline -> ifsts .)
    IDVAR           reduce using rule 9 (nline -> ifsts .)
    $end            reduce using rule 9 (nline -> ifsts .)
    RCB             reduce using rule 9 (nline -> ifsts .)


state 11

    (10) nline -> EXIT . LPAREN RPAREN SCOLON

    LPAREN          shift and go to state 32


state 12

    (11) nline -> PRINT . LPAREN pline RPAREN SCOLON

    LPAREN          shift and go to state 33


state 13

    (14) nline -> FOR . LPAREN fline bexp SCOLON assign RPAREN LCB line RCB

    LPAREN          shift and go to state 34


state 14

    (20) numexp -> assign . SCOLON

    SCOLON          shift and go to state 35


state 15

    (15) nline -> WHILE . LPAREN bexp RPAREN LCB line RCB

    LPAREN          shift and go to state 36


state 16

    (37) dtype -> INT .

    LBB             reduce using rule 37 (dtype -> INT .)
    IDVAR           reduce using rule 37 (dtype -> INT .)


state 17

    (38) dtype -> FLT .

    LBB             reduce using rule 38 (dtype -> FLT .)
    IDVAR           reduce using rule 38 (dtype -> FLT .)


state 18

    (39) dtype -> CHR .

    LBB             reduce using rule 39 (dtype -> CHR .)
    IDVAR           reduce using rule 39 (dtype -> CHR .)


state 19

    (56) fline -> numexp .

    STR             reduce using rule 56 (fline -> numexp .)
    BOOL            reduce using rule 56 (fline -> numexp .)
    RETURN          reduce using rule 56 (fline -> numexp .)
    EXIT            reduce using rule 56 (fline -> numexp .)
    PRINT           reduce using rule 56 (fline -> numexp .)
    FOR             reduce using rule 56 (fline -> numexp .)
    WHILE           reduce using rule 56 (fline -> numexp .)
    INT             reduce using rule 56 (fline -> numexp .)
    FLT             reduce using rule 56 (fline -> numexp .)
    CHR             reduce using rule 56 (fline -> numexp .)
    IF              reduce using rule 56 (fline -> numexp .)
    IDVAR           reduce using rule 56 (fline -> numexp .)
    $end            reduce using rule 56 (fline -> numexp .)
    RCB             reduce using rule 56 (fline -> numexp .)
    INTEGER         reduce using rule 56 (fline -> numexp .)
    FLOAT           reduce using rule 56 (fline -> numexp .)
    CHAR            reduce using rule 56 (fline -> numexp .)
    TRUE            reduce using rule 56 (fline -> numexp .)
    FALSE           reduce using rule 56 (fline -> numexp .)


state 20

    (16) ifsts -> IF . LPAREN bexp RPAREN LCB line RCB elsests

    LPAREN          shift and go to state 37


state 21

    (1) line -> nline line .

    $end            reduce using rule 1 (line -> nline line .)
    RCB             reduce using rule 1 (line -> nline line .)


state 22

    (3) nline -> dtype var . SCOLON
    (54) assign -> var . EQUAL exp

    SCOLON          shift and go to state 38
    EQUAL           shift and go to state 25


state 23

    (57) nline -> dtype LBB . RBB IDVAR EQUAL arrt SCOLON

    RBB             shift and go to state 39


state 24

    (55) fline -> dtype numexp .

    STR             reduce using rule 55 (fline -> dtype numexp .)
    BOOL            reduce using rule 55 (fline -> dtype numexp .)
    RETURN          reduce using rule 55 (fline -> dtype numexp .)
    EXIT            reduce using rule 55 (fline -> dtype numexp .)
    PRINT           reduce using rule 55 (fline -> dtype numexp .)
    FOR             reduce using rule 55 (fline -> dtype numexp .)
    WHILE           reduce using rule 55 (fline -> dtype numexp .)
    INT             reduce using rule 55 (fline -> dtype numexp .)
    FLT             reduce using rule 55 (fline -> dtype numexp .)
    CHR             reduce using rule 55 (fline -> dtype numexp .)
    IF              reduce using rule 55 (fline -> dtype numexp .)
    IDVAR           reduce using rule 55 (fline -> dtype numexp .)
    $end            reduce using rule 55 (fline -> dtype numexp .)
    RCB             reduce using rule 55 (fline -> dtype numexp .)
    INTEGER         reduce using rule 55 (fline -> dtype numexp .)
    FLOAT           reduce using rule 55 (fline -> dtype numexp .)
    CHAR            reduce using rule 55 (fline -> dtype numexp .)
    TRUE            reduce using rule 55 (fline -> dtype numexp .)
    FALSE           reduce using rule 55 (fline -> dtype numexp .)


state 25

    (54) assign -> var EQUAL . exp
    (21) exp -> . exp PLUS term
    (22) exp -> . exp MINUS term
    (23) exp -> . term
    (24) term -> . term MUL fact
    (25) term -> . term DIV fact
    (26) term -> . term MOD fact
    (27) term -> . fact
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . var
    (31) fact -> . bval
    (32) fact -> . CHAR
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB
    (33) bval -> . TRUE
    (34) bval -> . FALSE

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 47
    IDVAR           shift and go to state 7
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    var                            shift and go to state 40
    exp                            shift and go to state 41
    term                           shift and go to state 42
    fact                           shift and go to state 43
    bval                           shift and go to state 46

state 26

    (4) nline -> STR var . SCOLON

    SCOLON          shift and go to state 50


state 27

    (6) nline -> STR IDVAR . EQUAL strvar SCOLON
    (35) var -> IDVAR .
    (36) var -> IDVAR . LBB INTEGER RBB

    EQUAL           shift and go to state 51
    SCOLON          reduce using rule 35 (var -> IDVAR .)
    LBB             shift and go to state 29


state 28

    (58) nline -> STR LBB . RBB IDVAR EQUAL arrt SCOLON

    RBB             shift and go to state 52


state 29

    (36) var -> IDVAR LBB . INTEGER RBB

    INTEGER         shift and go to state 53


state 30

    (7) nline -> BOOL MAIN . LPAREN RPAREN LCB line RCB

    LPAREN          shift and go to state 54


state 31

    (8) nline -> RETURN LPAREN . bval RPAREN SCOLON
    (33) bval -> . TRUE
    (34) bval -> . FALSE

    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    bval                           shift and go to state 55

state 32

    (10) nline -> EXIT LPAREN . RPAREN SCOLON

    RPAREN          shift and go to state 56


state 33

    (11) nline -> PRINT LPAREN . pline RPAREN SCOLON
    (12) pline -> . exp
    (13) pline -> . STRING
    (21) exp -> . exp PLUS term
    (22) exp -> . exp MINUS term
    (23) exp -> . term
    (24) term -> . term MUL fact
    (25) term -> . term DIV fact
    (26) term -> . term MOD fact
    (27) term -> . fact
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . var
    (31) fact -> . bval
    (32) fact -> . CHAR
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB
    (33) bval -> . TRUE
    (34) bval -> . FALSE

    STRING          shift and go to state 59
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 47
    IDVAR           shift and go to state 7
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    pline                          shift and go to state 57
    exp                            shift and go to state 58
    term                           shift and go to state 42
    fact                           shift and go to state 43
    var                            shift and go to state 40
    bval                           shift and go to state 46

state 34

    (14) nline -> FOR LPAREN . fline bexp SCOLON assign RPAREN LCB line RCB
    (55) fline -> . dtype numexp
    (56) fline -> . numexp
    (37) dtype -> . INT
    (38) dtype -> . FLT
    (39) dtype -> . CHR
    (40) dtype -> . BOOL
    (20) numexp -> . assign SCOLON
    (54) assign -> . var EQUAL exp
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB

    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    BOOL            shift and go to state 62
    IDVAR           shift and go to state 7

    fline                          shift and go to state 60
    assign                         shift and go to state 14
    dtype                          shift and go to state 61
    numexp                         shift and go to state 19
    var                            shift and go to state 4

state 35

    (20) numexp -> assign SCOLON .

    STR             reduce using rule 20 (numexp -> assign SCOLON .)
    BOOL            reduce using rule 20 (numexp -> assign SCOLON .)
    RETURN          reduce using rule 20 (numexp -> assign SCOLON .)
    EXIT            reduce using rule 20 (numexp -> assign SCOLON .)
    PRINT           reduce using rule 20 (numexp -> assign SCOLON .)
    FOR             reduce using rule 20 (numexp -> assign SCOLON .)
    WHILE           reduce using rule 20 (numexp -> assign SCOLON .)
    INT             reduce using rule 20 (numexp -> assign SCOLON .)
    FLT             reduce using rule 20 (numexp -> assign SCOLON .)
    CHR             reduce using rule 20 (numexp -> assign SCOLON .)
    IF              reduce using rule 20 (numexp -> assign SCOLON .)
    IDVAR           reduce using rule 20 (numexp -> assign SCOLON .)
    $end            reduce using rule 20 (numexp -> assign SCOLON .)
    RCB             reduce using rule 20 (numexp -> assign SCOLON .)
    INTEGER         reduce using rule 20 (numexp -> assign SCOLON .)
    FLOAT           reduce using rule 20 (numexp -> assign SCOLON .)
    CHAR            reduce using rule 20 (numexp -> assign SCOLON .)
    TRUE            reduce using rule 20 (numexp -> assign SCOLON .)
    FALSE           reduce using rule 20 (numexp -> assign SCOLON .)


state 36

    (15) nline -> WHILE LPAREN . bexp RPAREN LCB line RCB
    (43) bexp -> . bexp andor bexp2
    (44) bexp -> . bexp2
    (45) bexp2 -> . bexp2 rln exp
    (46) bexp2 -> . exp
    (21) exp -> . exp PLUS term
    (22) exp -> . exp MINUS term
    (23) exp -> . term
    (24) term -> . term MUL fact
    (25) term -> . term DIV fact
    (26) term -> . term MOD fact
    (27) term -> . fact
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . var
    (31) fact -> . bval
    (32) fact -> . CHAR
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB
    (33) bval -> . TRUE
    (34) bval -> . FALSE

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 47
    IDVAR           shift and go to state 7
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    bexp                           shift and go to state 63
    bexp2                          shift and go to state 64
    exp                            shift and go to state 65
    term                           shift and go to state 42
    fact                           shift and go to state 43
    var                            shift and go to state 40
    bval                           shift and go to state 46

state 37

    (16) ifsts -> IF LPAREN . bexp RPAREN LCB line RCB elsests
    (43) bexp -> . bexp andor bexp2
    (44) bexp -> . bexp2
    (45) bexp2 -> . bexp2 rln exp
    (46) bexp2 -> . exp
    (21) exp -> . exp PLUS term
    (22) exp -> . exp MINUS term
    (23) exp -> . term
    (24) term -> . term MUL fact
    (25) term -> . term DIV fact
    (26) term -> . term MOD fact
    (27) term -> . fact
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . var
    (31) fact -> . bval
    (32) fact -> . CHAR
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB
    (33) bval -> . TRUE
    (34) bval -> . FALSE

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 47
    IDVAR           shift and go to state 7
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    bexp                           shift and go to state 66
    bexp2                          shift and go to state 64
    exp                            shift and go to state 65
    term                           shift and go to state 42
    fact                           shift and go to state 43
    var                            shift and go to state 40
    bval                           shift and go to state 46

state 38

    (3) nline -> dtype var SCOLON .

    STR             reduce using rule 3 (nline -> dtype var SCOLON .)
    BOOL            reduce using rule 3 (nline -> dtype var SCOLON .)
    RETURN          reduce using rule 3 (nline -> dtype var SCOLON .)
    EXIT            reduce using rule 3 (nline -> dtype var SCOLON .)
    PRINT           reduce using rule 3 (nline -> dtype var SCOLON .)
    FOR             reduce using rule 3 (nline -> dtype var SCOLON .)
    WHILE           reduce using rule 3 (nline -> dtype var SCOLON .)
    INT             reduce using rule 3 (nline -> dtype var SCOLON .)
    FLT             reduce using rule 3 (nline -> dtype var SCOLON .)
    CHR             reduce using rule 3 (nline -> dtype var SCOLON .)
    IF              reduce using rule 3 (nline -> dtype var SCOLON .)
    IDVAR           reduce using rule 3 (nline -> dtype var SCOLON .)
    $end            reduce using rule 3 (nline -> dtype var SCOLON .)
    RCB             reduce using rule 3 (nline -> dtype var SCOLON .)


state 39

    (57) nline -> dtype LBB RBB . IDVAR EQUAL arrt SCOLON

    IDVAR           shift and go to state 67


state 40

    (30) fact -> var .

    MUL             reduce using rule 30 (fact -> var .)
    DIV             reduce using rule 30 (fact -> var .)
    MOD             reduce using rule 30 (fact -> var .)
    PLUS            reduce using rule 30 (fact -> var .)
    MINUS           reduce using rule 30 (fact -> var .)
    SCOLON          reduce using rule 30 (fact -> var .)
    RPAREN          reduce using rule 30 (fact -> var .)
    DEQUAL          reduce using rule 30 (fact -> var .)
    GTHEN           reduce using rule 30 (fact -> var .)
    LTHEN           reduce using rule 30 (fact -> var .)
    NOT             reduce using rule 30 (fact -> var .)
    AND             reduce using rule 30 (fact -> var .)
    OR              reduce using rule 30 (fact -> var .)
    COM             reduce using rule 30 (fact -> var .)
    RCB             reduce using rule 30 (fact -> var .)


state 41

    (54) assign -> var EQUAL exp .
    (21) exp -> exp . PLUS term
    (22) exp -> exp . MINUS term

    SCOLON          reduce using rule 54 (assign -> var EQUAL exp .)
    RPAREN          reduce using rule 54 (assign -> var EQUAL exp .)
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69


state 42

    (23) exp -> term .
    (24) term -> term . MUL fact
    (25) term -> term . DIV fact
    (26) term -> term . MOD fact

    PLUS            reduce using rule 23 (exp -> term .)
    MINUS           reduce using rule 23 (exp -> term .)
    SCOLON          reduce using rule 23 (exp -> term .)
    RPAREN          reduce using rule 23 (exp -> term .)
    DEQUAL          reduce using rule 23 (exp -> term .)
    GTHEN           reduce using rule 23 (exp -> term .)
    LTHEN           reduce using rule 23 (exp -> term .)
    NOT             reduce using rule 23 (exp -> term .)
    AND             reduce using rule 23 (exp -> term .)
    OR              reduce using rule 23 (exp -> term .)
    MUL             shift and go to state 70
    DIV             shift and go to state 71
    MOD             shift and go to state 72


state 43

    (27) term -> fact .

    MUL             reduce using rule 27 (term -> fact .)
    DIV             reduce using rule 27 (term -> fact .)
    MOD             reduce using rule 27 (term -> fact .)
    PLUS            reduce using rule 27 (term -> fact .)
    MINUS           reduce using rule 27 (term -> fact .)
    SCOLON          reduce using rule 27 (term -> fact .)
    RPAREN          reduce using rule 27 (term -> fact .)
    DEQUAL          reduce using rule 27 (term -> fact .)
    GTHEN           reduce using rule 27 (term -> fact .)
    LTHEN           reduce using rule 27 (term -> fact .)
    NOT             reduce using rule 27 (term -> fact .)
    AND             reduce using rule 27 (term -> fact .)
    OR              reduce using rule 27 (term -> fact .)


state 44

    (28) fact -> INTEGER .

    MUL             reduce using rule 28 (fact -> INTEGER .)
    DIV             reduce using rule 28 (fact -> INTEGER .)
    MOD             reduce using rule 28 (fact -> INTEGER .)
    PLUS            reduce using rule 28 (fact -> INTEGER .)
    MINUS           reduce using rule 28 (fact -> INTEGER .)
    SCOLON          reduce using rule 28 (fact -> INTEGER .)
    RPAREN          reduce using rule 28 (fact -> INTEGER .)
    DEQUAL          reduce using rule 28 (fact -> INTEGER .)
    GTHEN           reduce using rule 28 (fact -> INTEGER .)
    LTHEN           reduce using rule 28 (fact -> INTEGER .)
    NOT             reduce using rule 28 (fact -> INTEGER .)
    AND             reduce using rule 28 (fact -> INTEGER .)
    OR              reduce using rule 28 (fact -> INTEGER .)
    COM             reduce using rule 28 (fact -> INTEGER .)
    RCB             reduce using rule 28 (fact -> INTEGER .)


state 45

    (29) fact -> FLOAT .

    MUL             reduce using rule 29 (fact -> FLOAT .)
    DIV             reduce using rule 29 (fact -> FLOAT .)
    MOD             reduce using rule 29 (fact -> FLOAT .)
    PLUS            reduce using rule 29 (fact -> FLOAT .)
    MINUS           reduce using rule 29 (fact -> FLOAT .)
    SCOLON          reduce using rule 29 (fact -> FLOAT .)
    RPAREN          reduce using rule 29 (fact -> FLOAT .)
    DEQUAL          reduce using rule 29 (fact -> FLOAT .)
    GTHEN           reduce using rule 29 (fact -> FLOAT .)
    LTHEN           reduce using rule 29 (fact -> FLOAT .)
    NOT             reduce using rule 29 (fact -> FLOAT .)
    AND             reduce using rule 29 (fact -> FLOAT .)
    OR              reduce using rule 29 (fact -> FLOAT .)
    COM             reduce using rule 29 (fact -> FLOAT .)
    RCB             reduce using rule 29 (fact -> FLOAT .)


state 46

    (31) fact -> bval .

    MUL             reduce using rule 31 (fact -> bval .)
    DIV             reduce using rule 31 (fact -> bval .)
    MOD             reduce using rule 31 (fact -> bval .)
    PLUS            reduce using rule 31 (fact -> bval .)
    MINUS           reduce using rule 31 (fact -> bval .)
    SCOLON          reduce using rule 31 (fact -> bval .)
    RPAREN          reduce using rule 31 (fact -> bval .)
    DEQUAL          reduce using rule 31 (fact -> bval .)
    GTHEN           reduce using rule 31 (fact -> bval .)
    LTHEN           reduce using rule 31 (fact -> bval .)
    NOT             reduce using rule 31 (fact -> bval .)
    AND             reduce using rule 31 (fact -> bval .)
    OR              reduce using rule 31 (fact -> bval .)
    COM             reduce using rule 31 (fact -> bval .)
    RCB             reduce using rule 31 (fact -> bval .)


state 47

    (32) fact -> CHAR .

    MUL             reduce using rule 32 (fact -> CHAR .)
    DIV             reduce using rule 32 (fact -> CHAR .)
    MOD             reduce using rule 32 (fact -> CHAR .)
    PLUS            reduce using rule 32 (fact -> CHAR .)
    MINUS           reduce using rule 32 (fact -> CHAR .)
    SCOLON          reduce using rule 32 (fact -> CHAR .)
    RPAREN          reduce using rule 32 (fact -> CHAR .)
    DEQUAL          reduce using rule 32 (fact -> CHAR .)
    GTHEN           reduce using rule 32 (fact -> CHAR .)
    LTHEN           reduce using rule 32 (fact -> CHAR .)
    NOT             reduce using rule 32 (fact -> CHAR .)
    AND             reduce using rule 32 (fact -> CHAR .)
    OR              reduce using rule 32 (fact -> CHAR .)
    COM             reduce using rule 32 (fact -> CHAR .)
    RCB             reduce using rule 32 (fact -> CHAR .)


state 48

    (33) bval -> TRUE .

    MUL             reduce using rule 33 (bval -> TRUE .)
    DIV             reduce using rule 33 (bval -> TRUE .)
    MOD             reduce using rule 33 (bval -> TRUE .)
    PLUS            reduce using rule 33 (bval -> TRUE .)
    MINUS           reduce using rule 33 (bval -> TRUE .)
    SCOLON          reduce using rule 33 (bval -> TRUE .)
    RPAREN          reduce using rule 33 (bval -> TRUE .)
    DEQUAL          reduce using rule 33 (bval -> TRUE .)
    GTHEN           reduce using rule 33 (bval -> TRUE .)
    LTHEN           reduce using rule 33 (bval -> TRUE .)
    NOT             reduce using rule 33 (bval -> TRUE .)
    AND             reduce using rule 33 (bval -> TRUE .)
    OR              reduce using rule 33 (bval -> TRUE .)
    COM             reduce using rule 33 (bval -> TRUE .)
    RCB             reduce using rule 33 (bval -> TRUE .)


state 49

    (34) bval -> FALSE .

    MUL             reduce using rule 34 (bval -> FALSE .)
    DIV             reduce using rule 34 (bval -> FALSE .)
    MOD             reduce using rule 34 (bval -> FALSE .)
    PLUS            reduce using rule 34 (bval -> FALSE .)
    MINUS           reduce using rule 34 (bval -> FALSE .)
    SCOLON          reduce using rule 34 (bval -> FALSE .)
    RPAREN          reduce using rule 34 (bval -> FALSE .)
    DEQUAL          reduce using rule 34 (bval -> FALSE .)
    GTHEN           reduce using rule 34 (bval -> FALSE .)
    LTHEN           reduce using rule 34 (bval -> FALSE .)
    NOT             reduce using rule 34 (bval -> FALSE .)
    AND             reduce using rule 34 (bval -> FALSE .)
    OR              reduce using rule 34 (bval -> FALSE .)
    COM             reduce using rule 34 (bval -> FALSE .)
    RCB             reduce using rule 34 (bval -> FALSE .)


state 50

    (4) nline -> STR var SCOLON .

    STR             reduce using rule 4 (nline -> STR var SCOLON .)
    BOOL            reduce using rule 4 (nline -> STR var SCOLON .)
    RETURN          reduce using rule 4 (nline -> STR var SCOLON .)
    EXIT            reduce using rule 4 (nline -> STR var SCOLON .)
    PRINT           reduce using rule 4 (nline -> STR var SCOLON .)
    FOR             reduce using rule 4 (nline -> STR var SCOLON .)
    WHILE           reduce using rule 4 (nline -> STR var SCOLON .)
    INT             reduce using rule 4 (nline -> STR var SCOLON .)
    FLT             reduce using rule 4 (nline -> STR var SCOLON .)
    CHR             reduce using rule 4 (nline -> STR var SCOLON .)
    IF              reduce using rule 4 (nline -> STR var SCOLON .)
    IDVAR           reduce using rule 4 (nline -> STR var SCOLON .)
    $end            reduce using rule 4 (nline -> STR var SCOLON .)
    RCB             reduce using rule 4 (nline -> STR var SCOLON .)


state 51

    (6) nline -> STR IDVAR EQUAL . strvar SCOLON
    (41) strvar -> . STRING
    (42) strvar -> . var
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB

    STRING          shift and go to state 74
    IDVAR           shift and go to state 7

    strvar                         shift and go to state 73
    var                            shift and go to state 75

state 52

    (58) nline -> STR LBB RBB . IDVAR EQUAL arrt SCOLON

    IDVAR           shift and go to state 76


state 53

    (36) var -> IDVAR LBB INTEGER . RBB

    RBB             shift and go to state 77


state 54

    (7) nline -> BOOL MAIN LPAREN . RPAREN LCB line RCB

    RPAREN          shift and go to state 78


state 55

    (8) nline -> RETURN LPAREN bval . RPAREN SCOLON

    RPAREN          shift and go to state 79


state 56

    (10) nline -> EXIT LPAREN RPAREN . SCOLON

    SCOLON          shift and go to state 80


state 57

    (11) nline -> PRINT LPAREN pline . RPAREN SCOLON

    RPAREN          shift and go to state 81


state 58

    (12) pline -> exp .
    (21) exp -> exp . PLUS term
    (22) exp -> exp . MINUS term

    RPAREN          reduce using rule 12 (pline -> exp .)
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69


state 59

    (13) pline -> STRING .

    RPAREN          reduce using rule 13 (pline -> STRING .)


state 60

    (14) nline -> FOR LPAREN fline . bexp SCOLON assign RPAREN LCB line RCB
    (43) bexp -> . bexp andor bexp2
    (44) bexp -> . bexp2
    (45) bexp2 -> . bexp2 rln exp
    (46) bexp2 -> . exp
    (21) exp -> . exp PLUS term
    (22) exp -> . exp MINUS term
    (23) exp -> . term
    (24) term -> . term MUL fact
    (25) term -> . term DIV fact
    (26) term -> . term MOD fact
    (27) term -> . fact
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . var
    (31) fact -> . bval
    (32) fact -> . CHAR
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB
    (33) bval -> . TRUE
    (34) bval -> . FALSE

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 47
    IDVAR           shift and go to state 7
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    bexp                           shift and go to state 82
    bexp2                          shift and go to state 64
    exp                            shift and go to state 65
    term                           shift and go to state 42
    fact                           shift and go to state 43
    var                            shift and go to state 40
    bval                           shift and go to state 46

state 61

    (55) fline -> dtype . numexp
    (20) numexp -> . assign SCOLON
    (54) assign -> . var EQUAL exp
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB

    IDVAR           shift and go to state 7

    numexp                         shift and go to state 24
    assign                         shift and go to state 14
    var                            shift and go to state 4

state 62

    (40) dtype -> BOOL .

    IDVAR           reduce using rule 40 (dtype -> BOOL .)


state 63

    (15) nline -> WHILE LPAREN bexp . RPAREN LCB line RCB
    (43) bexp -> bexp . andor bexp2
    (51) andor -> . AND
    (52) andor -> . OR

    RPAREN          shift and go to state 83
    AND             shift and go to state 85
    OR              shift and go to state 86

    andor                          shift and go to state 84

state 64

    (44) bexp -> bexp2 .
    (45) bexp2 -> bexp2 . rln exp
    (47) rln -> . DEQUAL
    (48) rln -> . GTHEN
    (49) rln -> . LTHEN
    (50) rln -> . NOT

    RPAREN          reduce using rule 44 (bexp -> bexp2 .)
    AND             reduce using rule 44 (bexp -> bexp2 .)
    OR              reduce using rule 44 (bexp -> bexp2 .)
    SCOLON          reduce using rule 44 (bexp -> bexp2 .)
    DEQUAL          shift and go to state 88
    GTHEN           shift and go to state 89
    LTHEN           shift and go to state 90
    NOT             shift and go to state 91

    rln                            shift and go to state 87

state 65

    (46) bexp2 -> exp .
    (21) exp -> exp . PLUS term
    (22) exp -> exp . MINUS term

    DEQUAL          reduce using rule 46 (bexp2 -> exp .)
    GTHEN           reduce using rule 46 (bexp2 -> exp .)
    LTHEN           reduce using rule 46 (bexp2 -> exp .)
    NOT             reduce using rule 46 (bexp2 -> exp .)
    RPAREN          reduce using rule 46 (bexp2 -> exp .)
    AND             reduce using rule 46 (bexp2 -> exp .)
    OR              reduce using rule 46 (bexp2 -> exp .)
    SCOLON          reduce using rule 46 (bexp2 -> exp .)
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69


state 66

    (16) ifsts -> IF LPAREN bexp . RPAREN LCB line RCB elsests
    (43) bexp -> bexp . andor bexp2
    (51) andor -> . AND
    (52) andor -> . OR

    RPAREN          shift and go to state 92
    AND             shift and go to state 85
    OR              shift and go to state 86

    andor                          shift and go to state 84

state 67

    (57) nline -> dtype LBB RBB IDVAR . EQUAL arrt SCOLON

    EQUAL           shift and go to state 93


state 68

    (21) exp -> exp PLUS . term
    (24) term -> . term MUL fact
    (25) term -> . term DIV fact
    (26) term -> . term MOD fact
    (27) term -> . fact
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . var
    (31) fact -> . bval
    (32) fact -> . CHAR
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB
    (33) bval -> . TRUE
    (34) bval -> . FALSE

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 47
    IDVAR           shift and go to state 7
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    term                           shift and go to state 94
    fact                           shift and go to state 43
    var                            shift and go to state 40
    bval                           shift and go to state 46

state 69

    (22) exp -> exp MINUS . term
    (24) term -> . term MUL fact
    (25) term -> . term DIV fact
    (26) term -> . term MOD fact
    (27) term -> . fact
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . var
    (31) fact -> . bval
    (32) fact -> . CHAR
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB
    (33) bval -> . TRUE
    (34) bval -> . FALSE

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 47
    IDVAR           shift and go to state 7
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    term                           shift and go to state 95
    fact                           shift and go to state 43
    var                            shift and go to state 40
    bval                           shift and go to state 46

state 70

    (24) term -> term MUL . fact
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . var
    (31) fact -> . bval
    (32) fact -> . CHAR
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB
    (33) bval -> . TRUE
    (34) bval -> . FALSE

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 47
    IDVAR           shift and go to state 7
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    fact                           shift and go to state 96
    var                            shift and go to state 40
    bval                           shift and go to state 46

state 71

    (25) term -> term DIV . fact
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . var
    (31) fact -> . bval
    (32) fact -> . CHAR
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB
    (33) bval -> . TRUE
    (34) bval -> . FALSE

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 47
    IDVAR           shift and go to state 7
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    fact                           shift and go to state 97
    var                            shift and go to state 40
    bval                           shift and go to state 46

state 72

    (26) term -> term MOD . fact
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . var
    (31) fact -> . bval
    (32) fact -> . CHAR
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB
    (33) bval -> . TRUE
    (34) bval -> . FALSE

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 47
    IDVAR           shift and go to state 7
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    fact                           shift and go to state 98
    var                            shift and go to state 40
    bval                           shift and go to state 46

state 73

    (6) nline -> STR IDVAR EQUAL strvar . SCOLON

    SCOLON          shift and go to state 99


state 74

    (41) strvar -> STRING .

    SCOLON          reduce using rule 41 (strvar -> STRING .)


state 75

    (42) strvar -> var .

    SCOLON          reduce using rule 42 (strvar -> var .)


state 76

    (58) nline -> STR LBB RBB IDVAR . EQUAL arrt SCOLON

    EQUAL           shift and go to state 100


state 77

    (36) var -> IDVAR LBB INTEGER RBB .

    EQUAL           reduce using rule 36 (var -> IDVAR LBB INTEGER RBB .)
    SCOLON          reduce using rule 36 (var -> IDVAR LBB INTEGER RBB .)
    MUL             reduce using rule 36 (var -> IDVAR LBB INTEGER RBB .)
    DIV             reduce using rule 36 (var -> IDVAR LBB INTEGER RBB .)
    MOD             reduce using rule 36 (var -> IDVAR LBB INTEGER RBB .)
    PLUS            reduce using rule 36 (var -> IDVAR LBB INTEGER RBB .)
    MINUS           reduce using rule 36 (var -> IDVAR LBB INTEGER RBB .)
    RPAREN          reduce using rule 36 (var -> IDVAR LBB INTEGER RBB .)
    DEQUAL          reduce using rule 36 (var -> IDVAR LBB INTEGER RBB .)
    GTHEN           reduce using rule 36 (var -> IDVAR LBB INTEGER RBB .)
    LTHEN           reduce using rule 36 (var -> IDVAR LBB INTEGER RBB .)
    NOT             reduce using rule 36 (var -> IDVAR LBB INTEGER RBB .)
    AND             reduce using rule 36 (var -> IDVAR LBB INTEGER RBB .)
    OR              reduce using rule 36 (var -> IDVAR LBB INTEGER RBB .)
    COM             reduce using rule 36 (var -> IDVAR LBB INTEGER RBB .)
    RCB             reduce using rule 36 (var -> IDVAR LBB INTEGER RBB .)


state 78

    (7) nline -> BOOL MAIN LPAREN RPAREN . LCB line RCB

    LCB             shift and go to state 101


state 79

    (8) nline -> RETURN LPAREN bval RPAREN . SCOLON

    SCOLON          shift and go to state 102


state 80

    (10) nline -> EXIT LPAREN RPAREN SCOLON .

    STR             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    BOOL            reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    RETURN          reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    EXIT            reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    PRINT           reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    FOR             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    WHILE           reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    INT             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    FLT             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    CHR             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    IF              reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    IDVAR           reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    $end            reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)
    RCB             reduce using rule 10 (nline -> EXIT LPAREN RPAREN SCOLON .)


state 81

    (11) nline -> PRINT LPAREN pline RPAREN . SCOLON

    SCOLON          shift and go to state 103


state 82

    (14) nline -> FOR LPAREN fline bexp . SCOLON assign RPAREN LCB line RCB
    (43) bexp -> bexp . andor bexp2
    (51) andor -> . AND
    (52) andor -> . OR

    SCOLON          shift and go to state 104
    AND             shift and go to state 85
    OR              shift and go to state 86

    andor                          shift and go to state 84

state 83

    (15) nline -> WHILE LPAREN bexp RPAREN . LCB line RCB

    LCB             shift and go to state 105


state 84

    (43) bexp -> bexp andor . bexp2
    (45) bexp2 -> . bexp2 rln exp
    (46) bexp2 -> . exp
    (21) exp -> . exp PLUS term
    (22) exp -> . exp MINUS term
    (23) exp -> . term
    (24) term -> . term MUL fact
    (25) term -> . term DIV fact
    (26) term -> . term MOD fact
    (27) term -> . fact
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . var
    (31) fact -> . bval
    (32) fact -> . CHAR
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB
    (33) bval -> . TRUE
    (34) bval -> . FALSE

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 47
    IDVAR           shift and go to state 7
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    bexp2                          shift and go to state 106
    exp                            shift and go to state 65
    term                           shift and go to state 42
    fact                           shift and go to state 43
    var                            shift and go to state 40
    bval                           shift and go to state 46

state 85

    (51) andor -> AND .

    INTEGER         reduce using rule 51 (andor -> AND .)
    FLOAT           reduce using rule 51 (andor -> AND .)
    CHAR            reduce using rule 51 (andor -> AND .)
    IDVAR           reduce using rule 51 (andor -> AND .)
    TRUE            reduce using rule 51 (andor -> AND .)
    FALSE           reduce using rule 51 (andor -> AND .)


state 86

    (52) andor -> OR .

    INTEGER         reduce using rule 52 (andor -> OR .)
    FLOAT           reduce using rule 52 (andor -> OR .)
    CHAR            reduce using rule 52 (andor -> OR .)
    IDVAR           reduce using rule 52 (andor -> OR .)
    TRUE            reduce using rule 52 (andor -> OR .)
    FALSE           reduce using rule 52 (andor -> OR .)


state 87

    (45) bexp2 -> bexp2 rln . exp
    (21) exp -> . exp PLUS term
    (22) exp -> . exp MINUS term
    (23) exp -> . term
    (24) term -> . term MUL fact
    (25) term -> . term DIV fact
    (26) term -> . term MOD fact
    (27) term -> . fact
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . var
    (31) fact -> . bval
    (32) fact -> . CHAR
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB
    (33) bval -> . TRUE
    (34) bval -> . FALSE

    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 47
    IDVAR           shift and go to state 7
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    exp                            shift and go to state 107
    term                           shift and go to state 42
    fact                           shift and go to state 43
    var                            shift and go to state 40
    bval                           shift and go to state 46

state 88

    (47) rln -> DEQUAL .

    INTEGER         reduce using rule 47 (rln -> DEQUAL .)
    FLOAT           reduce using rule 47 (rln -> DEQUAL .)
    CHAR            reduce using rule 47 (rln -> DEQUAL .)
    IDVAR           reduce using rule 47 (rln -> DEQUAL .)
    TRUE            reduce using rule 47 (rln -> DEQUAL .)
    FALSE           reduce using rule 47 (rln -> DEQUAL .)


state 89

    (48) rln -> GTHEN .

    INTEGER         reduce using rule 48 (rln -> GTHEN .)
    FLOAT           reduce using rule 48 (rln -> GTHEN .)
    CHAR            reduce using rule 48 (rln -> GTHEN .)
    IDVAR           reduce using rule 48 (rln -> GTHEN .)
    TRUE            reduce using rule 48 (rln -> GTHEN .)
    FALSE           reduce using rule 48 (rln -> GTHEN .)


state 90

    (49) rln -> LTHEN .

    INTEGER         reduce using rule 49 (rln -> LTHEN .)
    FLOAT           reduce using rule 49 (rln -> LTHEN .)
    CHAR            reduce using rule 49 (rln -> LTHEN .)
    IDVAR           reduce using rule 49 (rln -> LTHEN .)
    TRUE            reduce using rule 49 (rln -> LTHEN .)
    FALSE           reduce using rule 49 (rln -> LTHEN .)


state 91

    (50) rln -> NOT .

    INTEGER         reduce using rule 50 (rln -> NOT .)
    FLOAT           reduce using rule 50 (rln -> NOT .)
    CHAR            reduce using rule 50 (rln -> NOT .)
    IDVAR           reduce using rule 50 (rln -> NOT .)
    TRUE            reduce using rule 50 (rln -> NOT .)
    FALSE           reduce using rule 50 (rln -> NOT .)


state 92

    (16) ifsts -> IF LPAREN bexp RPAREN . LCB line RCB elsests

    LCB             shift and go to state 108


state 93

    (57) nline -> dtype LBB RBB IDVAR EQUAL . arrt SCOLON
    (59) arrt -> . var
    (60) arrt -> . LCB dws RCB
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB

    LCB             shift and go to state 111
    IDVAR           shift and go to state 7

    arrt                           shift and go to state 109
    var                            shift and go to state 110

state 94

    (21) exp -> exp PLUS term .
    (24) term -> term . MUL fact
    (25) term -> term . DIV fact
    (26) term -> term . MOD fact

    PLUS            reduce using rule 21 (exp -> exp PLUS term .)
    MINUS           reduce using rule 21 (exp -> exp PLUS term .)
    SCOLON          reduce using rule 21 (exp -> exp PLUS term .)
    RPAREN          reduce using rule 21 (exp -> exp PLUS term .)
    DEQUAL          reduce using rule 21 (exp -> exp PLUS term .)
    GTHEN           reduce using rule 21 (exp -> exp PLUS term .)
    LTHEN           reduce using rule 21 (exp -> exp PLUS term .)
    NOT             reduce using rule 21 (exp -> exp PLUS term .)
    AND             reduce using rule 21 (exp -> exp PLUS term .)
    OR              reduce using rule 21 (exp -> exp PLUS term .)
    MUL             shift and go to state 70
    DIV             shift and go to state 71
    MOD             shift and go to state 72


state 95

    (22) exp -> exp MINUS term .
    (24) term -> term . MUL fact
    (25) term -> term . DIV fact
    (26) term -> term . MOD fact

    PLUS            reduce using rule 22 (exp -> exp MINUS term .)
    MINUS           reduce using rule 22 (exp -> exp MINUS term .)
    SCOLON          reduce using rule 22 (exp -> exp MINUS term .)
    RPAREN          reduce using rule 22 (exp -> exp MINUS term .)
    DEQUAL          reduce using rule 22 (exp -> exp MINUS term .)
    GTHEN           reduce using rule 22 (exp -> exp MINUS term .)
    LTHEN           reduce using rule 22 (exp -> exp MINUS term .)
    NOT             reduce using rule 22 (exp -> exp MINUS term .)
    AND             reduce using rule 22 (exp -> exp MINUS term .)
    OR              reduce using rule 22 (exp -> exp MINUS term .)
    MUL             shift and go to state 70
    DIV             shift and go to state 71
    MOD             shift and go to state 72


state 96

    (24) term -> term MUL fact .

    MUL             reduce using rule 24 (term -> term MUL fact .)
    DIV             reduce using rule 24 (term -> term MUL fact .)
    MOD             reduce using rule 24 (term -> term MUL fact .)
    PLUS            reduce using rule 24 (term -> term MUL fact .)
    MINUS           reduce using rule 24 (term -> term MUL fact .)
    SCOLON          reduce using rule 24 (term -> term MUL fact .)
    RPAREN          reduce using rule 24 (term -> term MUL fact .)
    DEQUAL          reduce using rule 24 (term -> term MUL fact .)
    GTHEN           reduce using rule 24 (term -> term MUL fact .)
    LTHEN           reduce using rule 24 (term -> term MUL fact .)
    NOT             reduce using rule 24 (term -> term MUL fact .)
    AND             reduce using rule 24 (term -> term MUL fact .)
    OR              reduce using rule 24 (term -> term MUL fact .)


state 97

    (25) term -> term DIV fact .

    MUL             reduce using rule 25 (term -> term DIV fact .)
    DIV             reduce using rule 25 (term -> term DIV fact .)
    MOD             reduce using rule 25 (term -> term DIV fact .)
    PLUS            reduce using rule 25 (term -> term DIV fact .)
    MINUS           reduce using rule 25 (term -> term DIV fact .)
    SCOLON          reduce using rule 25 (term -> term DIV fact .)
    RPAREN          reduce using rule 25 (term -> term DIV fact .)
    DEQUAL          reduce using rule 25 (term -> term DIV fact .)
    GTHEN           reduce using rule 25 (term -> term DIV fact .)
    LTHEN           reduce using rule 25 (term -> term DIV fact .)
    NOT             reduce using rule 25 (term -> term DIV fact .)
    AND             reduce using rule 25 (term -> term DIV fact .)
    OR              reduce using rule 25 (term -> term DIV fact .)


state 98

    (26) term -> term MOD fact .

    MUL             reduce using rule 26 (term -> term MOD fact .)
    DIV             reduce using rule 26 (term -> term MOD fact .)
    MOD             reduce using rule 26 (term -> term MOD fact .)
    PLUS            reduce using rule 26 (term -> term MOD fact .)
    MINUS           reduce using rule 26 (term -> term MOD fact .)
    SCOLON          reduce using rule 26 (term -> term MOD fact .)
    RPAREN          reduce using rule 26 (term -> term MOD fact .)
    DEQUAL          reduce using rule 26 (term -> term MOD fact .)
    GTHEN           reduce using rule 26 (term -> term MOD fact .)
    LTHEN           reduce using rule 26 (term -> term MOD fact .)
    NOT             reduce using rule 26 (term -> term MOD fact .)
    AND             reduce using rule 26 (term -> term MOD fact .)
    OR              reduce using rule 26 (term -> term MOD fact .)


state 99

    (6) nline -> STR IDVAR EQUAL strvar SCOLON .

    STR             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    BOOL            reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    RETURN          reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    EXIT            reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    PRINT           reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    FOR             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    WHILE           reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    INT             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    FLT             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    CHR             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    IF              reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    IDVAR           reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    $end            reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)
    RCB             reduce using rule 6 (nline -> STR IDVAR EQUAL strvar SCOLON .)


state 100

    (58) nline -> STR LBB RBB IDVAR EQUAL . arrt SCOLON
    (59) arrt -> . var
    (60) arrt -> . LCB dws RCB
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB

    LCB             shift and go to state 111
    IDVAR           shift and go to state 7

    arrt                           shift and go to state 112
    var                            shift and go to state 110

state 101

    (7) nline -> BOOL MAIN LPAREN RPAREN LCB . line RCB
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN LCB line RCB
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB
    (15) nline -> . WHILE LPAREN bexp RPAREN LCB line RCB
    (57) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (58) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (37) dtype -> . INT
    (38) dtype -> . FLT
    (39) dtype -> . CHR
    (40) dtype -> . BOOL
    (55) fline -> . dtype numexp
    (56) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests
    (20) numexp -> . assign SCOLON
    (54) assign -> . var EQUAL exp
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 113
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19

state 102

    (8) nline -> RETURN LPAREN bval RPAREN SCOLON .

    STR             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    BOOL            reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    RETURN          reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    EXIT            reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    PRINT           reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    FOR             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    WHILE           reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    INT             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    FLT             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    CHR             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    IF              reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    IDVAR           reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    $end            reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)
    RCB             reduce using rule 8 (nline -> RETURN LPAREN bval RPAREN SCOLON .)


state 103

    (11) nline -> PRINT LPAREN pline RPAREN SCOLON .

    STR             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    BOOL            reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    RETURN          reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    EXIT            reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    PRINT           reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    FOR             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    WHILE           reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    INT             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    FLT             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    CHR             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    IF              reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    IDVAR           reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    $end            reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)
    RCB             reduce using rule 11 (nline -> PRINT LPAREN pline RPAREN SCOLON .)


state 104

    (14) nline -> FOR LPAREN fline bexp SCOLON . assign RPAREN LCB line RCB
    (54) assign -> . var EQUAL exp
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB

    IDVAR           shift and go to state 7

    assign                         shift and go to state 114
    var                            shift and go to state 4

state 105

    (15) nline -> WHILE LPAREN bexp RPAREN LCB . line RCB
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN LCB line RCB
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB
    (15) nline -> . WHILE LPAREN bexp RPAREN LCB line RCB
    (57) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (58) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (37) dtype -> . INT
    (38) dtype -> . FLT
    (39) dtype -> . CHR
    (40) dtype -> . BOOL
    (55) fline -> . dtype numexp
    (56) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests
    (20) numexp -> . assign SCOLON
    (54) assign -> . var EQUAL exp
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 115
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19

state 106

    (43) bexp -> bexp andor bexp2 .
    (45) bexp2 -> bexp2 . rln exp
    (47) rln -> . DEQUAL
    (48) rln -> . GTHEN
    (49) rln -> . LTHEN
    (50) rln -> . NOT

    RPAREN          reduce using rule 43 (bexp -> bexp andor bexp2 .)
    AND             reduce using rule 43 (bexp -> bexp andor bexp2 .)
    OR              reduce using rule 43 (bexp -> bexp andor bexp2 .)
    SCOLON          reduce using rule 43 (bexp -> bexp andor bexp2 .)
    DEQUAL          shift and go to state 88
    GTHEN           shift and go to state 89
    LTHEN           shift and go to state 90
    NOT             shift and go to state 91

    rln                            shift and go to state 87

state 107

    (45) bexp2 -> bexp2 rln exp .
    (21) exp -> exp . PLUS term
    (22) exp -> exp . MINUS term

    DEQUAL          reduce using rule 45 (bexp2 -> bexp2 rln exp .)
    GTHEN           reduce using rule 45 (bexp2 -> bexp2 rln exp .)
    LTHEN           reduce using rule 45 (bexp2 -> bexp2 rln exp .)
    NOT             reduce using rule 45 (bexp2 -> bexp2 rln exp .)
    RPAREN          reduce using rule 45 (bexp2 -> bexp2 rln exp .)
    AND             reduce using rule 45 (bexp2 -> bexp2 rln exp .)
    OR              reduce using rule 45 (bexp2 -> bexp2 rln exp .)
    SCOLON          reduce using rule 45 (bexp2 -> bexp2 rln exp .)
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69


state 108

    (16) ifsts -> IF LPAREN bexp RPAREN LCB . line RCB elsests
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN LCB line RCB
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB
    (15) nline -> . WHILE LPAREN bexp RPAREN LCB line RCB
    (57) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (58) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (37) dtype -> . INT
    (38) dtype -> . FLT
    (39) dtype -> . CHR
    (40) dtype -> . BOOL
    (55) fline -> . dtype numexp
    (56) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests
    (20) numexp -> . assign SCOLON
    (54) assign -> . var EQUAL exp
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 116
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19

state 109

    (57) nline -> dtype LBB RBB IDVAR EQUAL arrt . SCOLON

    SCOLON          shift and go to state 117


state 110

    (59) arrt -> var .

    SCOLON          reduce using rule 59 (arrt -> var .)


state 111

    (60) arrt -> LCB . dws RCB
    (61) dws -> . factarr COM dws
    (62) dws -> . factarr
    (63) factarr -> . fact
    (64) factarr -> . STRING
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . var
    (31) fact -> . bval
    (32) fact -> . CHAR
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB
    (33) bval -> . TRUE
    (34) bval -> . FALSE

    STRING          shift and go to state 121
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 47
    IDVAR           shift and go to state 7
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    dws                            shift and go to state 118
    factarr                        shift and go to state 119
    fact                           shift and go to state 120
    var                            shift and go to state 40
    bval                           shift and go to state 46

state 112

    (58) nline -> STR LBB RBB IDVAR EQUAL arrt . SCOLON

    SCOLON          shift and go to state 122


state 113

    (7) nline -> BOOL MAIN LPAREN RPAREN LCB line . RCB

    RCB             shift and go to state 123


state 114

    (14) nline -> FOR LPAREN fline bexp SCOLON assign . RPAREN LCB line RCB

    RPAREN          shift and go to state 124


state 115

    (15) nline -> WHILE LPAREN bexp RPAREN LCB line . RCB

    RCB             shift and go to state 125


state 116

    (16) ifsts -> IF LPAREN bexp RPAREN LCB line . RCB elsests

    RCB             shift and go to state 126


state 117

    (57) nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .

    STR             reduce using rule 57 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    BOOL            reduce using rule 57 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    RETURN          reduce using rule 57 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    EXIT            reduce using rule 57 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    PRINT           reduce using rule 57 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    FOR             reduce using rule 57 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    WHILE           reduce using rule 57 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    INT             reduce using rule 57 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    FLT             reduce using rule 57 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    CHR             reduce using rule 57 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    IF              reduce using rule 57 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    IDVAR           reduce using rule 57 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    $end            reduce using rule 57 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)
    RCB             reduce using rule 57 (nline -> dtype LBB RBB IDVAR EQUAL arrt SCOLON .)


state 118

    (60) arrt -> LCB dws . RCB

    RCB             shift and go to state 127


state 119

    (61) dws -> factarr . COM dws
    (62) dws -> factarr .

    COM             shift and go to state 128
    RCB             reduce using rule 62 (dws -> factarr .)


state 120

    (63) factarr -> fact .

    COM             reduce using rule 63 (factarr -> fact .)
    RCB             reduce using rule 63 (factarr -> fact .)


state 121

    (64) factarr -> STRING .

    COM             reduce using rule 64 (factarr -> STRING .)
    RCB             reduce using rule 64 (factarr -> STRING .)


state 122

    (58) nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .

    STR             reduce using rule 58 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    BOOL            reduce using rule 58 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    RETURN          reduce using rule 58 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    EXIT            reduce using rule 58 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    PRINT           reduce using rule 58 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    FOR             reduce using rule 58 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    WHILE           reduce using rule 58 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    INT             reduce using rule 58 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    FLT             reduce using rule 58 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    CHR             reduce using rule 58 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    IF              reduce using rule 58 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    IDVAR           reduce using rule 58 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    $end            reduce using rule 58 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)
    RCB             reduce using rule 58 (nline -> STR LBB RBB IDVAR EQUAL arrt SCOLON .)


state 123

    (7) nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .

    STR             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    BOOL            reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    RETURN          reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    EXIT            reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    PRINT           reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    FOR             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    WHILE           reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    INT             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    FLT             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    CHR             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    IF              reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    IDVAR           reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    $end            reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)
    RCB             reduce using rule 7 (nline -> BOOL MAIN LPAREN RPAREN LCB line RCB .)


state 124

    (14) nline -> FOR LPAREN fline bexp SCOLON assign RPAREN . LCB line RCB

    LCB             shift and go to state 129


state 125

    (15) nline -> WHILE LPAREN bexp RPAREN LCB line RCB .

    STR             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    BOOL            reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    RETURN          reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    EXIT            reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    PRINT           reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    FOR             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    WHILE           reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    INT             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    FLT             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    CHR             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    IF              reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    IDVAR           reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    $end            reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)
    RCB             reduce using rule 15 (nline -> WHILE LPAREN bexp RPAREN LCB line RCB .)


state 126

    (16) ifsts -> IF LPAREN bexp RPAREN LCB line RCB . elsests
    (17) elsests -> . ELSE LCB line RCB
    (18) elsests -> . ELSE ifsts
    (19) elsests -> . empty
    (53) empty -> .

    ELSE            shift and go to state 131
    STR             reduce using rule 53 (empty -> .)
    BOOL            reduce using rule 53 (empty -> .)
    RETURN          reduce using rule 53 (empty -> .)
    EXIT            reduce using rule 53 (empty -> .)
    PRINT           reduce using rule 53 (empty -> .)
    FOR             reduce using rule 53 (empty -> .)
    WHILE           reduce using rule 53 (empty -> .)
    INT             reduce using rule 53 (empty -> .)
    FLT             reduce using rule 53 (empty -> .)
    CHR             reduce using rule 53 (empty -> .)
    IF              reduce using rule 53 (empty -> .)
    IDVAR           reduce using rule 53 (empty -> .)
    $end            reduce using rule 53 (empty -> .)
    RCB             reduce using rule 53 (empty -> .)

    elsests                        shift and go to state 130
    empty                          shift and go to state 132

state 127

    (60) arrt -> LCB dws RCB .

    SCOLON          reduce using rule 60 (arrt -> LCB dws RCB .)


state 128

    (61) dws -> factarr COM . dws
    (61) dws -> . factarr COM dws
    (62) dws -> . factarr
    (63) factarr -> . fact
    (64) factarr -> . STRING
    (28) fact -> . INTEGER
    (29) fact -> . FLOAT
    (30) fact -> . var
    (31) fact -> . bval
    (32) fact -> . CHAR
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB
    (33) bval -> . TRUE
    (34) bval -> . FALSE

    STRING          shift and go to state 121
    INTEGER         shift and go to state 44
    FLOAT           shift and go to state 45
    CHAR            shift and go to state 47
    IDVAR           shift and go to state 7
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49

    factarr                        shift and go to state 119
    dws                            shift and go to state 133
    fact                           shift and go to state 120
    var                            shift and go to state 40
    bval                           shift and go to state 46

state 129

    (14) nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB . line RCB
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN LCB line RCB
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB
    (15) nline -> . WHILE LPAREN bexp RPAREN LCB line RCB
    (57) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (58) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (37) dtype -> . INT
    (38) dtype -> . FLT
    (39) dtype -> . CHR
    (40) dtype -> . BOOL
    (55) fline -> . dtype numexp
    (56) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests
    (20) numexp -> . assign SCOLON
    (54) assign -> . var EQUAL exp
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    fline                          shift and go to state 6
    assign                         shift and go to state 14
    line                           shift and go to state 134
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    ifsts                          shift and go to state 10
    numexp                         shift and go to state 19

state 130

    (16) ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .

    STR             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    BOOL            reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    RETURN          reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    EXIT            reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    PRINT           reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    FOR             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    WHILE           reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    INT             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    FLT             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    CHR             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    IF              reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    IDVAR           reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    $end            reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)
    RCB             reduce using rule 16 (ifsts -> IF LPAREN bexp RPAREN LCB line RCB elsests .)


state 131

    (17) elsests -> ELSE . LCB line RCB
    (18) elsests -> ELSE . ifsts
    (16) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests

    LCB             shift and go to state 135
    IF              shift and go to state 20

    ifsts                          shift and go to state 136

state 132

    (19) elsests -> empty .

    STR             reduce using rule 19 (elsests -> empty .)
    BOOL            reduce using rule 19 (elsests -> empty .)
    RETURN          reduce using rule 19 (elsests -> empty .)
    EXIT            reduce using rule 19 (elsests -> empty .)
    PRINT           reduce using rule 19 (elsests -> empty .)
    FOR             reduce using rule 19 (elsests -> empty .)
    WHILE           reduce using rule 19 (elsests -> empty .)
    INT             reduce using rule 19 (elsests -> empty .)
    FLT             reduce using rule 19 (elsests -> empty .)
    CHR             reduce using rule 19 (elsests -> empty .)
    IF              reduce using rule 19 (elsests -> empty .)
    IDVAR           reduce using rule 19 (elsests -> empty .)
    $end            reduce using rule 19 (elsests -> empty .)
    RCB             reduce using rule 19 (elsests -> empty .)


state 133

    (61) dws -> factarr COM dws .

    RCB             reduce using rule 61 (dws -> factarr COM dws .)


state 134

    (14) nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line . RCB

    RCB             shift and go to state 137


state 135

    (17) elsests -> ELSE LCB . line RCB
    (1) line -> . nline line
    (2) line -> . nline
    (3) nline -> . dtype var SCOLON
    (4) nline -> . STR var SCOLON
    (5) nline -> . fline
    (6) nline -> . STR IDVAR EQUAL strvar SCOLON
    (7) nline -> . BOOL MAIN LPAREN RPAREN LCB line RCB
    (8) nline -> . RETURN LPAREN bval RPAREN SCOLON
    (9) nline -> . ifsts
    (10) nline -> . EXIT LPAREN RPAREN SCOLON
    (11) nline -> . PRINT LPAREN pline RPAREN SCOLON
    (14) nline -> . FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB
    (15) nline -> . WHILE LPAREN bexp RPAREN LCB line RCB
    (57) nline -> . dtype LBB RBB IDVAR EQUAL arrt SCOLON
    (58) nline -> . STR LBB RBB IDVAR EQUAL arrt SCOLON
    (37) dtype -> . INT
    (38) dtype -> . FLT
    (39) dtype -> . CHR
    (40) dtype -> . BOOL
    (55) fline -> . dtype numexp
    (56) fline -> . numexp
    (16) ifsts -> . IF LPAREN bexp RPAREN LCB line RCB elsests
    (20) numexp -> . assign SCOLON
    (54) assign -> . var EQUAL exp
    (35) var -> . IDVAR
    (36) var -> . IDVAR LBB INTEGER RBB

    STR             shift and go to state 5
    BOOL            shift and go to state 8
    RETURN          shift and go to state 9
    EXIT            shift and go to state 11
    PRINT           shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 15
    INT             shift and go to state 16
    FLT             shift and go to state 17
    CHR             shift and go to state 18
    IF              shift and go to state 20
    IDVAR           shift and go to state 7

    line                           shift and go to state 138
    nline                          shift and go to state 2
    dtype                          shift and go to state 3
    var                            shift and go to state 4
    fline                          shift and go to state 6
    ifsts                          shift and go to state 10
    assign                         shift and go to state 14
    numexp                         shift and go to state 19

state 136

    (18) elsests -> ELSE ifsts .

    STR             reduce using rule 18 (elsests -> ELSE ifsts .)
    BOOL            reduce using rule 18 (elsests -> ELSE ifsts .)
    RETURN          reduce using rule 18 (elsests -> ELSE ifsts .)
    EXIT            reduce using rule 18 (elsests -> ELSE ifsts .)
    PRINT           reduce using rule 18 (elsests -> ELSE ifsts .)
    FOR             reduce using rule 18 (elsests -> ELSE ifsts .)
    WHILE           reduce using rule 18 (elsests -> ELSE ifsts .)
    INT             reduce using rule 18 (elsests -> ELSE ifsts .)
    FLT             reduce using rule 18 (elsests -> ELSE ifsts .)
    CHR             reduce using rule 18 (elsests -> ELSE ifsts .)
    IF              reduce using rule 18 (elsests -> ELSE ifsts .)
    IDVAR           reduce using rule 18 (elsests -> ELSE ifsts .)
    $end            reduce using rule 18 (elsests -> ELSE ifsts .)
    RCB             reduce using rule 18 (elsests -> ELSE ifsts .)


state 137

    (14) nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .

    STR             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    BOOL            reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    RETURN          reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    EXIT            reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    PRINT           reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    FOR             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    WHILE           reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    INT             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    FLT             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    CHR             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    IF              reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    IDVAR           reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    $end            reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)
    RCB             reduce using rule 14 (nline -> FOR LPAREN fline bexp SCOLON assign RPAREN LCB line RCB .)


state 138

    (17) elsests -> ELSE LCB line . RCB

    RCB             shift and go to state 139


state 139

    (17) elsests -> ELSE LCB line RCB .

    STR             reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    BOOL            reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    RETURN          reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    EXIT            reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    PRINT           reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    FOR             reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    WHILE           reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    INT             reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    FLT             reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    CHR             reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    IF              reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    IDVAR           reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    $end            reduce using rule 17 (elsests -> ELSE LCB line RCB .)
    RCB             reduce using rule 17 (elsests -> ELSE LCB line RCB .)

